{"version":3,"sources":["analyzer-objects/Analyzer.js","analyzer-objects/Bloc.js","analyzer-objects/CustomTable.js","analyzer-objects/Group.js","analyzer-objects/GroupTable.js","analyzer-objects/Report.js","analyzer-objects/Section.js","analyzer-objects/StatsTable.js","analyzer-objects/WrapTable.js","analyzer-objects/Report/Report_Controls.js","analyzer-objects/Report/Report_Grouped.js","analyzer-objects/Report/Report_Hits.js"],"names":["Analyzer","[object Object]","this","I","Report","new","init","n","d","Options","Decimals","Selected","undefined","toFixed","v","log","Math","log10","Value","Shift","getValue","Unit","shiftForUnit","Decimal","isNumeric","maxL","width","max","f","o","F","name","Log","headerConcLog","Format","Name","shift","rootForUnit","span","dir","dirspan","blankCell","repeat","Type","logValue","out","roundNb","Displayed","GenericRangeName","resolved","ResolvedNames","OriginIndex","RangeIndex","noData","val","c","inner","value","title","Class","Border","Index","Title","ReturnLength","html","HTML","Length","length","toString","array","maxLength","forEach","e","i","cellForValue","ColumnLength","n1","Types","Titles","cell","rowWidth","json","headers","arrayToColumn_Txt","Groups","j","arrayToColumn_HTML","DataPoints","ColumnIndex","console","MaxRow","reduce","acc","gap","Gap","Rows","g","options","style","Collapse","row","divHeight","l","Sync","t","event","target","tr","parentElement","me","cellIndex","scrollActive","Scroll","scrollTop","htmlCollection","getElementsByClassName","format","LogScale","ExportFormat","CV","Aggregation","UI","DataView","rows","cols","data","Data","Flat","Lvl1","Cols","Lvl2","RowHeaders","GroupTable","flattenLevel","ColHeaders","Headers","prepareWrapping","populateData","getConfig","SyncScrolling","Wrapping","WrapTable","export","Dir","Span","Bloc","ID","File","Sections","SectionsTab","TabControl","Multiple","Layout","Tabs","found","sections","section","Changed","resetSection","newSection","index","initSection","push","addTab","Label","SetActive","Content","activateControls","prop","Object","assign","Section","updateContent","CustomTable","id","TitleExport","exportJSON","plate","hasData","p","Group","Tags","type","SetNameAsValue","H","h","TabFactor","stop","ColumnsLength","header","blankHeader","columnSize","valueHeader","a","Category","Values","newTyped","level","HasHeader","flattenSeries","b","small","big","safeCopy","slice","filter","findIndex","splice","input","tags","copy","intersect","RowGroupHeaders","ColGroupHeaders","wrap","temp","mergeTags","SubGroups","newData","map","col","object","s","values","tableStart","export_ColHeaders","track","HeaderIndex","r","rowStart","export_RowHeader","export_RowData","rowEnd","StatRows","export_StatRows","tableEnd","gaps","colHeaders","colValueHeaders","T","arrayToColumn","S","Coordinate","statValue","arrayToRow","Array","fill","Average","SD","N","headerObject","Anchors","Output","Menu","Export","Results","PlateSelect","ResultPlate","PlateDoAll","PairingTarget","GetId","innerHTML","RespTable","window","opener","LoggedPlate","Fields","onSelect","os","oi","saveState","setPlates","do","restoreState","bind","FullWidth","RowNumbers","NoControls","Blocs","Active","LinkCtrl","Default","Chain","Change","enable","disable","refresh","Min","Step","Last","List","NewLine","Show","Plate","Result","pairStatus","append","buttonBar","Click","exportAll","Method","Report_Controls","Report_Grouped","ColumnOnly","Report_Hits","report","blocs","set","OpenedTab","newBloc","source","plates","Form","open","Buttons","cancel","onCancel","close","lastIndexOf","cleanFileName","substring","trim","replace","resultIndex","active","jumpTo","param","ResultIndex","currentPlate","FirstBlocIndex","getSection","Tables","includes","DataArray","setValue","SelectedPlate","start","SelectedIndices","startsWith","Params","Parameters","insertAdjacentHTML","Ranges","Definition","sel","PlatesID","Area","resolveNames","then","names","updateNames","Check","NavBar","Lookup","Preserve","ui","Pairing","Pair","unpaired","Html","pair","Pairs","getDefPlate","DefPlateIndex","Table","Broken","change","O","state","bloc","Cancel","what","refreshRows","update","range","collection","th","string","hasAttribute","getAttribute","setAttribute","pos","indexOf","end","Number","selectedPlate","Items","Numeric","waitMessage","custom","well","output","parser","wellIndex","Promise","resolve","Mapper","scan","Custom","params","getBloc","blocName","Summary","replaceContent","height","HTMLcollection","elt","items","children","maxHeight","overflowY","Z","JSZip","folder","blob","BlobOnly","file","generateAsync","url","URL","createObjectURL","replaceButtons","revokeObjectURL","JSON","StatsTable","ranges","agg","TablesHtml","previousSibling","FileName","fullName","printable","content","parse","save","fileHeader","buildJSON","TxtOnly","Blob","fileName","download","Reporter","addRow","warn","sectionID","div","Count","button","Stop","Total","coll","Range","rowIndex","newName","Names","group","statObject","Wrap_Headers","concat","Wrap_Groups","replaceAll","innerText","stat","Stats","w","stats","cycle","constant","RowCycle","RowValues","HeadTrack","WrapTrack","totalRow","rowTxtGaps","rowHeaders","rowData","blank","head","colLengths","sum","lvl2Index","floor","lvl1Index","m","collected","k","super","zFactor","Controls","P","control","controlHTML","addTabs","compute","zScoreAllPlates","HasChanged","lock","display","unlock","unlockMenu","Neg","Pos","lockMenu","neg","pairNeeded","getControlValues","valueTable","JSONarray","processZscore","plateSummary","valueIndex","groups","controls","stringify","subgroups","groupsZ","groupsW","zScoreFromStats","W","windowFromStats","jsonZ","jsonW","z","abs","classForZ","min","classForW","scores","jsonArray","comb","combinationName","plateCounter","plateIterator","current","next","running","done","plateCount","Grouped","RootID","AvailableID","SelectedID","Areas","Available","OriginID","Concentrations","Conc","statsAllPlates","buttons","addData","prepend","prepareDefinition","msg_welcome","info","dataTransfer","setData","Moving","Item","Origin","preventDefault","classList","contains","document","className","relatedTarget","getData","remove","NewDrop","updateSelectedData","Action","appendChild","Selection","Ready","resolveAllNames","selected","available","availableMenu","Size","onInit","item","toDisplay","category","sourceID","htmlForItem","cat","Drop","Level","cleanSelected","promises","all","defIndex","factor","MaxRange","args","Factor","AreaName","Column","Mapping","definition","RangeIndexBase0","FindAll","find","modeWellPlate","msg_noCol","msg_pleaseWait","msg_clear","isReady","getValues","encodeJSON","Hits","opt","Threshold","Limit","Mode","ControlHigh","ControlLow","CustomHigh","CustomLow","count","itemName","msg","toResolve","High","Low","HitLimit","L","getControlHigh","getControlLow","compareCtrl","aggregateCtrl","reportControl","findHitsGlobal","reportHits","resolveHitNames","findHitsLocal","high","low","percent","diff","counts","emptyJSON","waitMsg","Parser","SelectedRows","Status","Resolvable","Msg","norm","results","logRange","Overflow","Param","abort","totalPlate","pairing","convertRangeNames","def","plateIndex","defPlate","getPair","getPlate","Counts","getValuesLocal","getHits","Well","hitStatus"],"mappings":"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","file":"analyzer.min.js","sourcesContent":["//**************************************************************************************************************\n// ANALYZER object - Allow presentation of result and data analysis in a window separated from the Layout Editor\n//**************************************************************************************************************\nclass Analyzer {\n\tconstructor() {return this}\n\t//Static Methods\n\tstatic init(I) { //Read the method and prepare the report accordingly\n\t\tthis.Report = Report.new(I).init();\n\t\treturn this;\n\t}\n\tstatic roundNb(n) { //Round the number using decimal value recovered from the report control\n\t\tlet d = this.Report.Options.Decimals.Selected;\n\t\tif(n.toFixed === undefined || d == \"All\") {return n} //Not a number or all decimals required\n\t\treturn n.toFixed(d);\n\t}\n\tstatic logValue(v) { //Compute the log10 of the value v for the report passed\n\t\tlet log = Math.log10(v.Value);\n\t\tif(this.Report.Options.Shift.getValue()) { //Shift to the higher unit\n\t\t\treturn log + Unit.shiftForUnit(v.Unit);\n\t\t}\n\t\treturn log;\n\t}\n\tstatic isNumeric(v) { //Returns a boolean to indicate if the value is text or number\n\t\treturn Decimal.isNumeric(v);\n\t}\n\tstatic divHeight(n) { //Compute the height of the div required to display n rows\n\t\treturn (1.65 * (n + 0.5)) + \"em\"; //Row height is ~1.65em (1.25em + 0.4 padding) per default, add half a row to let the user know something is below\n\t}\n\tstatic rowWidth(n, maxL) { //Compute the width of a row to accomodate n elements with their max length given\n\t\tlet width = maxL * n * 0.9 * (1 - (0.2 * maxL/20)); //font-size is 0.9em; the last factor is to shorten longest numbers (up to 20%), because 1 digit is less than 0.9em in width\n\t\twidth = Math.max(width, 2);\n\t\treturn width + \"em\";\n\t}\n\tstatic noData(f) { //The string used to indicate this cell has no data\n\t\tswitch(f) {\n\t\t\tcase \"txt\": return \"Ø\";\n\t\t\tdefault: return \"<span class=\\\"Warning\\\">&Oslash;</span>\";\n\t\t}\n\t}\n\tstatic header(o, F) { //Return the header for the row/col object provided\n\t\tif(o.Unit) {\n\t\t\tlet name = o.Unit;\n\t\t\tif(F.Log) {name = this.headerConcLog(o.Unit, F.Format, F.Shift)}\n\t\t\tswitch(F.Format) {\n\t\t\t\tcase \"html\": return \"<span class=\\\"Header_Conc\\\" name=\\\"\" + o.Unit + \"\\\">\" + name + \"</span>\";\n\t\t\t\tcase \"txt\": return name;\n\t\t\t}\n\t\t}\n\t\treturn o.Name;\n\t}\n\tstatic headerConcLog(name, f, shift) { //Wrap the name into a log10(...) text\n\t\tif(shift) {name = Unit.rootForUnit(name)}\n\t\tswitch(f) {\n\t\t\tcase \"html\": return \"Log<sub>10</sub>(\" + name + \")\";\n\t\t\tcase \"txt\": return \"Log10(\" + name + \")\";\n\t\t}\n\t}\n\tstatic valueHeader(v, F, span, dir) { //Return the html header for the value object v\n\t\tlet dirspan = \"\";\n\t\tif(span) { //Cases where span is undefined or zero are naturally excluded here\n\t\t\tswitch(F.Format) {\n\t\t\t\tcase \"html\": \n\t\t\t\t\tif(dir == \"Row\") {dirspan = \" rowspan=\\\"\" + span + \"\\\"\"}\n\t\t\t\t\telse {dirspan = \" colspan=\\\"\" + span + \"\\\"\"}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"txt\": \n\t\t\t\t\tif(dir === undefined || dir == \"Col\") {dirspan = Analyzer.blankCell(\"txt\").repeat(span - 1)} //No need to span for rows, done elsewhere\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(v.Type == \"Conc\") { //Process concentration headers differently\n\t\t\tlet log = this.logValue(v);\n\t\t\tlet out = \"\";\n\t\t\tswitch(F.Format) {\n\t\t\t\tcase \"html\":\n\t\t\t\t\tif(F.Log) {out = this.roundNb(log)}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(v.Unit == \"MOI\") {out = v.Value} //No decimals needed here\n\t\t\t\t\t\telse {out = this.roundNb(v.Value)} //Other cases\n\t\t\t\t\t}\n\t\t\t\t\treturn \"<th\" + dirspan + \" class=\\\"Value_PlaceHolder Header_Conc\\\" value=\\\"\" + v.Value + \"\\\" logvalue=\\\"\" + log + \"\\\" shift=\\\"\" + Unit.shiftForUnit(v.Unit) + \"\\\">\" + out + \"</th>\";\n\t\t\t\tcase \"txt\": //For text export, format also depends on the displayed option\n\t\t\t\t\tif(F.Log) {\n\t\t\t\t\t\tif(F.Displayed) {return this.roundNb(log) + dirspan + \"\\t\"}\n\t\t\t\t\t\telse {return log + dirspan + \"\\t\"}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(F.Displayed) {\n\t\t\t\t\t\t\tif(v.Unit == \"MOI\") {return v.Value + dirspan + \"\\t\"} //No decimals needed here\n\t\t\t\t\t\t\telse {return this.roundNb(v.Value) + dirspan + \"\\t\"} //Other cases\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {return v.Value + dirspan + \"\\t\"}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v.Type == \"Range\") { //For ranges, output the resolved or generic name\n\t\t\tif(F.GenericRangeName) { //Generic name\n\t\t\t\tswitch(F.Format) {\n\t\t\t\t\tcase \"html\": return \"<th\" + dirspan + \">\" + v.Name + \"</th>\";\n\t\t\t\t\tcase \"txt\": return v.Name + dirspan + \"\\t\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet resolved = this.Report.ResolvedNames[v.OriginIndex]; //Resolved name\n\t\t\tif(resolved !== undefined) {\n\t\t\t\tlet name = resolved[v.RangeIndex - 1];\n\t\t\t\tif(name !== undefined) {\n\t\t\t\t\tswitch(F.Format) {\n\t\t\t\t\t\tcase \"html\": return \"<th\" + dirspan + \" class=\\\"Value_PlaceHolder Header_Range\\\" RootName=\\\"\" + v.Name + \"\\\">\" + name + \"</th>\";\n\t\t\t\t\t\tcase \"txt\": return name + dirspan + \"\\t\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch(F.Format) { //These cases are for regular headers (all the rest)\n\t\t\tcase \"html\": return \"<th\" + dirspan + \">\" + v.Name + \"</th>\";\n\t\t\tcase \"txt\": return v.Name + dirspan + \"\\t\";\n\t\t}\n\t}\n\tstatic cellForValue(v, F, I) { //prepare a cell to hold a numeric or textual value\n\t\tif(F.Format == \"txt\") { //This case is pretty simple\n\t\t\tif(v === \"\" || v === undefined || v === null) {return this.noData(\"txt\")} //Mind the type equality, because 0 == \"\" evaluates to true\n\t\t\tlet val = v;\n\t\t\tif(v.Value !== undefined) {val = v.Value}\n\t\t\tif(F.Displayed) {return this.roundNb(val)}\n\t\t\telse {return val}\n\t\t}\n\t\tlet c = \" class=\\\"\";\n\t\tlet inner = v;\n\t\tlet value = \"\";\n\t\tlet title = \"\";\n\t\tif(v === \"\" || v === undefined || v === null) {inner = this.noData(F.Format)} //Mind the type equality, because 0 == \"\" evaluates to true\n\t\tif(I) { //Look the options\n\t\t\tif(I.Class) {c += I.Class + \" \"}\n\t\t\tif(I.Border && I.Index > 0) {c += \"BorderLeft \"}\n\t\t\tif(I.Type == \"#\" && v !== \"\" && v !== undefined && v !== null) { //Number should use the value placeHolder\n\t\t\t\tinner = this.roundNb(v);\n\t\t\t\tc += \"Value_PlaceHolder\";\n\t\t\t\tvalue = \" value=\\\"\" + v + \"\\\"\";\n\t\t\t}\n\t\t\tif(I.Title) {title = \" title=\\\"\" + I.Title + \"\\\"\"}\n\t\t\tif(I.ReturnLength) {\n\t\t\t\tlet html = \"<td\" + c + \"\\\"\" + value + title + \">\" + inner + \"</td>\";\n\t\t\t\tif(v === \"\" || v === undefined || v === null) {return {HTML: html, Length: 2}}\n\t\t\t\telse {\n\t\t\t\t\tif(inner.length === undefined) { //In case the value is a number that we want to treat as text\n\t\t\t\t\t\treturn {HTML: html, Length: inner.toString().length}\n\t\t\t\t\t}\n\t\t\t\t\treturn {HTML: html, Length: inner.length}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"<td\" + c + \"\\\"\" + value + title + \">\" + inner + \"</td>\";\n\t}\n\tstatic arrayToRow(array, F, I) { //Convert the array of values into an innerTable with a single row\n\t\tlet out = \"\";\n\t\tlet maxLength = 0;\n\t\tif(array.length == 0) {\n\t\t\tswitch(F.Format) {\n\t\t\t\tcase \"txt\": out += this.noData(\"txt\"); break;\n\t\t\t\tcase \"html\": out += \"<td>\" + this.noData() + \"</td>\"; break;\n\t\t\t}\n\t\t}\n\t\tif(F.Format == \"txt\") { //Case txt is simple\n\t\t\tarray.forEach(function(e, i) {\n\t\t\t\tif(i > 0) {out += \"\\t\"}\n\t\t\t\tout += this.cellForValue(e, F, I);\n\t\t\t}, this);\n\t\t\tif(I.ColumnLength !== undefined) { //A padding is needed to reach the max number of columns\n\t\t\t\tlet n1 = I.ColumnLength - array.length;\n\t\t\t\tif(array.length == 0) {n1--} //Not sure why, but needed to work\n\t\t\t\tif(n1 > 0) {out += this.blankCell(\"txt\").repeat(n1)}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\telse { //Following code is only for html\n\t\t\tarray.forEach(function(e, i) {\n\t\t\t\tlet o = {Border: true, Index: i, ReturnLength: true}\n\t\t\t\tif(I) {\n\t\t\t\t\tif(I.Types) {o.Type = I.Types[i]}\n\t\t\t\t\tif(I.Titles) {o.Title = I.Titles[i]}\n\t\t\t\t}\n\t\t\t\tlet cell = this.cellForValue(e, F, o);\n\t\t\t\tout += cell.HTML;\n\t\t\t\tmaxLength = Math.max(maxLength, cell.Length); //Log the max length of the string to display\n\t\t\t}, this);\n\t\t\treturn \"<td class=\\\"Border\\\"><div class=\\\"InnerTable_Wrapper\\\"><table class=\\\"InnerTableRow\\\" style=\\\"min-width: \" + this.rowWidth(array.length, maxLength) + \"\\\"><tr>\" + out + \"</tr></table></div></td>\";\n\t\t}\n\t}\n\tstatic arrayToColumn(i, json, F, headers) { //Produce a column output for the subgroup object i\n\t\tswitch(F.Format) {\n\t\t\tcase \"txt\": return this.arrayToColumn_Txt(i, json, F, headers);\n\t\t\tcase \"html\": \n\t\t\t\tlet out = \"\";\n\t\t\t\tjson.Groups.forEach(function(c, j) { //Loop the cols\t\n\t\t\t\t\tout += this.arrayToColumn_HTML(c.DataPoints[i], F);\n\t\t\t\t\tF.ColumnIndex++;\n\t\t\t\t}, this);\n\t\t\t\treturn out;\n\t\t}\n\t}\n\tstatic arrayToColumn_Txt(i, json, F, headers) { //Produce a column output for the subgroup object i, in a txt format\n\t\tconsole.log(i, json, F, headers);\n\t\tlet out = \"\";\n\t\tlet MaxRow = json.Groups.reduce(function(acc, val) {return Math.max(acc, val.DataPoints[i].length)}, 0); //Maximum number of row to expect\n\t\tlet gap = this.blankCell(\"txt\"); //Gap to append to each row to keep the alignment\n\t\tif(F.Gap !== undefined) {gap = this.blankCell(\"txt\").repeat(F.Gap)} //Use the precalculated value if it exists\n\t\telse { //In case of headers, a second gap is needed\n\t\t\tif(headers !== undefined && headers !== null) {\n\t\t\t\tif(headers.Rows !== undefined) {gap += this.blankCell(\"txt\")} \n\t\t\t}\n\t\t}\n\t\tif(MaxRow == 0) {return this.noData(\"txt\")}\n\t\tfor(let j=0; j<MaxRow; j++) { //Produce the row-per-row output\n\t\t\tif(j > 0) {out += \"\\n\" + gap}\n\t\t\tjson.Groups.forEach(function(g) { //Loop the columns\n\t\t\t\tlet val = g.DataPoints[i][j]; //Value at this location\n\t\t\t\tif(val !== undefined) {out += this.cellForValue(val, F, {Type: \"#\"})} //Add it if defined\n\t\t\t\telse { //No value defined here\n\t\t\t\t\tif(j == 0) {out += this.noData(\"txt\")} //If this was the first row, it means the column is empty\n\t\t\t\t}\n\t\t\t\tout += \"\\t\"; //In all cases, insert a gap to keep the alignment\n\t\t\t}, this);\n\t\t}\n\t\treturn out;\n\t}\n\tstatic arrayToColumn_HTML(array, F) { //Convert the array provided into a single column html table\n\t\tlet options = this.Report.Options;\n\t\tlet style = \"\";\n\t\tif(options.Collapse.getValue()) {\n\t\t\tlet row = options.Rows.getValue();\n\t\t\tstyle = \" style=\\\"max-height: \" + this.divHeight(row);\n\t\t\tif(array.length <= row) {style += \"; overflow-y: unset\\\"\"}\n\t\t\telse {style += \"; overflow-y: scroll\\\"\"}\n\t\t}\n\t\tlet l = array.length;\n\t\t//if(l > 1) {html += \" style=\\\"vertical-align: top\\\"\"} //Maybe better not to use it, to be consistent in formatting\n\t\tlet html = \"<td class=\\\"Border\\\" style=\\\"vertical-align: top\\\">\";\n\t\thtml += \"<div class=\\\"InnerTable_Wrapper\\\"\" + style;\n\t\tif(F.Sync) {html += \" onmouseenter=\\\"Analyzer.scrollActive = \" + F.ColumnIndex + \"\\\" onscroll=\\\"Analyzer.syncScrolling()\\\"\"}\n\t\thtml += \"><table class=\\\"InnerTable\\\">\";\n\t\tarray.forEach(function(val, i) {\n\t\t\tlet v = val;\n\t\t\tlet o = {Type: \"#\"}\n\t\t\tif(val !== undefined && val !== null) {\n\t\t\t\tif(val.Value !== undefined) {v = val.Value}\n\t\t\t\tif(val.Class !== undefined) {o.Class = val.Class}\n\t\t\t\tif(val.Type !== undefined) {o.Type = val.Type}\n\t\t\t}\n\t\t\tif(this.isNumeric(v) == false) {o.Type = \"Text\"} //Correct the type if needed\n\t\t\thtml += \"<tr>\" + this.cellForValue(v, F, o) + \"</tr>\"; \n\t\t}, this);\n\t\tif(l == 0) {html += \"<tr><td>\" + this.noData() + \"</td></tr>\"} //The array was empty\n\t\thtml += \"</table></div></td>\";\n\t\treturn html;\n\t}\n\tstatic syncScrolling() { //Sync column scrolling within a table\n\t\tlet t = event.target;\n\t\tlet tr = t.parentElement;\n\t\tlet me = tr.cellIndex - 1;\n\t\tlet i = this.scrollActive;\n\t\tif(i == me) { //This is the element triggering the scroll on the other divs\n\t\t\tthis.Scroll = t.scrollTop; //Log its scroll value\n\t\t\tlet htmlCollection = tr.parentElement.getElementsByClassName(\"InnerTable_Wrapper\"); //This is NOT an array, so we have to use a for loop to traverse it\n\t\t\tlet l = htmlCollection.length;\n\t\t\tfor(let j=0; j<l; j++) { //For each synchronized div\n\t\t\t\tif(j != i) { //If you are not the one that triggered the scroll\n\t\t\t\t\tlet div = htmlCollection[j];\n\t\t\t\t\tdiv.scrollTop = this.Scroll; //Update the scroll position. This will trigger the scroll event for this element, which will do nothing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//*************************************************************************\n//NEW METHODS USING A COMMON JSON OBJECT AS STANDARD BETWEEN HTML/TXT/GRAPH\n//*************************************************************************\n\tstatic getConfig(format) { //Return a formatting object using the configuration from the UI\n\t\tlet log = undefined;\n\t\tif(this.Report.Options.LogScale !== undefined) { //Not all reports support this option\n\t\t\tlog = this.Report.Options.LogScale.getValue();\n\t\t}\n\t\treturn { //Formatting object\n\t\t\tDisplayed: (this.Report.Options.ExportFormat.getValue() == 1), //true means use the displayed data,\n\t\t\tLog: log,\n\t\t\tFormat: format,\n\t\t\tCV: this.Report.Options.CV.getValue(),\n\t\t\tShift: this.Report.Options.Shift.getValue(),\n\t\t\tAggregation: this.Report.UI.DataView.Selected,\n\t\t\tColumnIndex: 0, //For synchronized scrolling; will be incremented on the fly as columns are added\n\t\t}; \n\t}\n\tstatic encodeJSON(rows, cols, data) { //Encode the incoming rows, cols and data into a common JSON object, and return it\n\t\tlet o = {Data: []}; //Initialize the object\n\t\tlet Flat = {Lvl1: {Rows: [], Cols: []}, Lvl2: {Rows: [], Cols: []} };\n\t\tlet RowHeaders = GroupTable.flattenLevel(rows[0], Flat.Lvl1.Rows); //Start by flattening all this mess and build the headers, for each level 1\n\t\tlet ColHeaders = GroupTable.flattenLevel(cols[0], Flat.Lvl1.Cols);\n\t\tif(RowHeaders !== undefined || ColHeaders !== undefined) { //If at least one header exists\n\t\t\to.Headers = {Rows: RowHeaders, Cols: ColHeaders}\n\t\t}\n\t\tGroupTable.prepareWrapping(rows, cols, Flat, o); //Prepare the wrapping based on lvl2\n\t\tGroupTable.populateData(o.Data, data)//Compute the datapoints arrays\n\t\treturn o;\n\t}\n\tstatic exportJSON(j, format) { //Convert the json object into a readable string, html or txt depending on the format\n\t\tlet F = this.getConfig(format);\n\t\tif(j.SyncScrolling) {F.Sync = true}\n\t\tif(j.GenericRangeName) {F.GenericRangeName = true}\n\t\tif(j.Wrapping) { //In case of wrapping, a wrapper table is necessary\n\t\t\tlet table = new WrapTable(j.Wrapping); //Returns a WrapTable object that can be interacted with\n\t\t\treturn table.export(j, F); //Returns the final html string\n\t\t}\n\t\telse {\n\t\t\treturn GroupTable.export(j, F, j.Headers);\n\t\t}\n\t}\n\tstatic tableStart(f) {\n\t\tif(f == \"html\") {return \"<table class=\\\"OuterTable\\\">\"}\n\t\treturn \"\";\n\t}\n\tstatic tableEnd(f) {\n\t\tif(f == \"html\") {return \"</table>\"}\n\t\treturn \"\";\n\t}\n\tstatic rowStart(f) {\n\t\tif(f == \"html\") {return \"<tr>\"}\n\t\treturn \"\";\n\t}\n\tstatic rowEnd(f) {\n\t\tswitch(f) {\n\t\t\tcase \"html\": return \"</tr>\";\n\t\t\tcase \"txt\": return \"\\n\";\n\t\t}\n\t}\n\tstatic blankCell(f) {\n\t\tswitch(f) {\n\t\t\tcase \"html\": return \"<td></td>\";\n\t\t\tcase \"txt\": return \"\\t\";\n\t\t}\n\t}\n\tstatic blankHeader(f, I) {\n\t\tswitch(f) {\n\t\t\tcase \"html\": \n\t\t\t\tlet span = \"\";\n\t\t\t\tif(I) {\n\t\t\t\t\tif(I.Dir == \"Row\") {span = \" rowspan=\\\"\" + I.Span + \"\\\"\"}\n\t\t\t\t\telse {span = \" colspan=\\\"\" + I.Span + \"\\\"\"}\n\t\t\t\t}\n\t\t\t\treturn \"<th\" + span + \"></th>\";\n\t\t\tcase \"txt\": return \"\\t\";\n\t\t}\n\t}\n}","//*****************************************************************************\n// BLOC object - First layer used to organize reporting of data in the analyzer\n//*****************************************************************************\nclass Bloc {\n\tconstructor(I) {\n\t\tthis.ID = I.ID;\n\t\tthis.Name = I.Name; //Internal name\n\t\tthis.File = I.File; //Name of the file associated to this bloc\n\t\tthis.Sections = [];\n\t\tthis.SectionsTab = new TabControl({ //Tab to manipulate the Section objects\n\t\t\tID: I.ID,\n\t\t\tMultiple: true,\n\t\t\tLayout: \"Horizontal\",\n\t\t\tTabs: [],\n\t\t});\n\t\treturn this;\n\t}\n\t//Static methods\n\n\t//Methods\n\tinit() { //Initialize the bloc on the page\n\t\tthis.SectionsTab.init();\n\t\treturn this;\n\t}\n\tgetSection(name, I) { //Return the section object with the given name, for the bloc provided\n\t\tlet found = false;\n\t\tlet i = 0;\n\t\tlet sections = this.Sections;\n\t\tlet l = sections.length;\n\t\twhile(!found && i<l) { //Loop to see if the section exists\n\t\t\tif(sections[i].Name == name) {found = true}\n\t\t\telse {i++}\n\t\t}\n\t\tif(found) { //Section already exists\n\t\t\tlet section = this.Sections[i];\n\t\t\tif(I !== undefined && (I.Type == \"Multiple\" || I.Type == \"StatsTable\")) { //Special case for these tables\n\t\t\t\tif(I.Changed == false) {return section} //No changes means we can keep aggregating using the same section\n\t\t\t\telse {return this.resetSection(name, i, I)} // In this case, must recompute the section but the index remains\n\t\t\t}\n\t\t\telse {return section}\n\t\t}\n\t\telse {return this.newSection(name, i, I)} //Create the section\n\t}\n\tnewSection(name, index, I) { //Create a new section for this bloc\n\t\tlet section = this.initSection(name, index, I);\n\t\tthis.Sections.push(section);\n\t\tthis.SectionsTab.addTab({Label: name, SetActive: true, Content: {Type: \"HTML\", Value: section.HTML(name)} });\n\t\tsection.activateControls(); //Activate the controls\n\t\treturn section;\n\t}\n\tinitSection(name, index, I) {\n\t\tlet id = this.ID + \"_\" + index;\n\t\tlet prop = {Name: name, Bloc: this, ID: id};\n\t\tif(I) {Object.assign(prop, I)} //\"Concat\" properties of I and param\n\t\tlet section = new Section(prop);\n\t\treturn section;\n\t}\n\tresetSection(name, index, I) { //Reset the contents of the section at index i\n\t\tlet section = this.initSection(name, index, I); //Recompute the section at the same index\n\t\tthis.Sections[index] = section; //Replace old section\n\t\tthis.SectionsTab.Tabs[index].updateContent({Type: \"HTML\", Value: section.HTML(name)}) //Update the tab\n\t\tsection.activateControls(); //Activate the controls\n\t\treturn section; //Return the newly created section\n\t}\n}","//********************************************************************************************************\n// CUSTOMTABLE object - Object to represent an individual table in a section that can host several of them\n//********************************************************************************************************\nclass CustomTable {\n\tconstructor(id, json) {\n\t\tthis.ID = id;\n\t\tthis.Data = json; //For these tables, the json must be supplied directly. Hence the custom\n\t\tthis.Title = json.Title;\n\t\treturn this;\n\t}\n\t//Getter, Setter\n\tget TitleExport() { //Return the title for export as text\n\t\tif(this.Title === undefined) {return \"\"}\n\t\treturn this.Title;\n\t}\n\t//Methods\n\thtml() { //Return the html to initialize this table\n\t\tlet html = \"\";\n\t\thtml += \"<div id=\\\"\" + this.ID + \"\\\" class=\\\"DynTable_Wrap\\\">\";\n\t\tif(this.Title !== undefined) {\n\t\t\thtml += \"<fieldset class=\\\"DynTable_Container\\\">\";\n\t\t\thtml += \"<legend class=\\\"DynTable_Title\\\">\" + this.Title + \"</legend>\";\n\t\t}\n\t\thtml += Analyzer.exportJSON(this.Data, \"html\");\n\t\tif(this.Title !== undefined) {html += \"</fieldset>\"}\n\t\thtml += \"</div>\";\n\t\treturn html;\n\t}\n\tbuildJSON() { //For compatibility with StatsTable\n\t\treturn this.Data;\n\t}\n\taddRow(data, plate) { //Add a row of data for the plate provided\n\t\tif(this.hasData(plate)) {return this} //This row of data already exists, nothing needed here\n\t\tthis.Data.Data[0].Groups.forEach(function(g, i) {\n\t\t\tg.DataPoints[0].push(data.Data[0].Groups[i].DataPoints[0][0]); //It is assumed that data are supplied one by one\n\t\t});\n\t\treturn this;\n\t}\n\thasData(p) { //Check if the data already exist in the table. Use the first column as comparator\n\t\tlet found = false;\n\t\tlet data = this.Data.Data[0].Groups[0].DataPoints[0]; //First column is the comparator\n\t\tlet i = 0;\n\t\tlet max = data.length;\n\t\twhile(found === false && i < max) { //A while loop is more efficient because it stops when the match is found\n\t\t\tif(data[i] == p) {found = true}\n\t\t\ti++;\n\t\t}\n\t\treturn found;\n\t}\n\tresetSection(name, i, I) { //Erase the previous contents and redraw\n\t\tconsole.log(\"resetSection not implemented for CustomTable. SO GET YOUR FINGERS OUT OF YOUR ASS MOTHERFUCKER!!!\");\n\t}\n}","//********************************************************************************************\n// GROUP object - Class representing an array of datapoints, used to build graphs or 2D tables\n//********************************************************************************************\nclass Group {\n\tconstructor(I) {\n\t\tthis.DataPoints = []; //Initialize DataPoints array\n\t\tthis.Name = (I.Name || \"\");\n\t\tthis.Value = I.Value;\n\t\tthis.Tags = (I.Tags || []);\n\t\tthis.RangeIndex = I.RangeIndex;\n\t\tthis.OriginIndex = I.OriginIndex;\n\t\tthis.Type = I.Type;\n\t\tthis.Unit = I.Unit;\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic newTyped(o, type, I) { //Returns a new Group object as a copy of o with its type property set as needed\n\t\tlet n = new Group(o); //A copy of o\n\t\tn.Type = type; //Set the desired type\n\t\tif(type == \"Conc\") {n.Unit = n.Name}\n\t\tif(type == \"Range\") {n.OriginIndex = I.OriginIndex}\n\t\tif(I && I.SetNameAsValue) {n.Name = (o.Value).toString()}\n\t\treturn n;\n\t}\n\tstatic colHeaders(H, F) { //Return the output for the array of header objects passed\n\t\tlet out = \"\";\n\t\tlet ColumnIndex = 0; //Tracker of ColumnIndex array index, for row aggregation\n\t\tH.forEach(function(h, i) { //Append the headers\n\t\t\tlet TabFactor = 0; //The sum of the column length for this header\n\t\t\tif(F.Format == \"txt\") { //Need to sum all the column length corresponding to the current header\n\t\t\t\tlet j = 0;\n\t\t\t\tlet stop = 1; //How many steps to make for this header\n\t\t\t\tif(h !== null && h !== undefined) {stop = h.Span}\n\t\t\t\twhile(j < stop) { //Sum all the needed lengths\n\t\t\t\t\tswitch(F.Aggregation) {\n\t\t\t\t\t\tcase \"Row\": //Use the precalculated lengths\n\t\t\t\t\t\t\t//TabFactor += F.ColumnsLength[ColumnIndex + j];\n\t\t\t\t\t\t\tlet l = F.ColumnsLength[ColumnIndex + j];\n\t\t\t\t\t\t\tif(l > 0) {TabFactor += l}\n\t\t\t\t\t\t\telse {TabFactor++} //At least one gap should anyway be added\n\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\tcase \"Avg, SD, N\": TabFactor += 3; break; //All columns have same size\n\t\t\t\t\t\tdefault: TabFactor++; break; //All other cases, just add one\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tColumnIndex += j; //Set the starting index for next header\n\t\t\t}\n\t\t\tif(h !== null && h !== undefined) { //JSON parsing yields empty array elements as null\n\t\t\t\tlet span = h.Span;\n\t\t\t\tswitch(F.Format) {\n\t\t\t\t\tcase \"html\": out += \"<th colspan=\\\"\" + span + \"\\\">\" + Analyzer.header(h, F) + \"</th>\"; break;\n\t\t\t\t\tcase \"txt\":\n\t\t\t\t\t\tout += Analyzer.header(h, F);\n\t\t\t\t\t\tout += Analyzer.blankCell(\"txt\").repeat(TabFactor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { //An empty slot is required to keep the alignment\n\t\t\t\tswitch(F.Format) {\n\t\t\t\t\tcase \"html\": out += Analyzer.blankHeader(\"html\"); break;\n\t\t\t\t\tcase \"txt\": \n\t\t\t\t\t\tif(TabFactor == 0) {out += Analyzer.blankCell(\"txt\")} //A blank is needed here as well\n\t\t\t\t\t\telse {out += Analyzer.blankCell(\"txt\").repeat(TabFactor)}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn out;\n\t}\n\tstatic colValueHeaders(o, F) { //Return the output for the array of value header available as columns\n\t\tlet out = \"\";\n\t\tif(o.Groups.length > 0)\t{\n\t\t\to.Groups.forEach(function(g, j) {\n\t\t\t\tlet columnSize = 1;\n\t\t\t\tif(F.Format == \"txt\") {\n\t\t\t\t\tswitch(F.Aggregation) { //Two cases requires addition of additional spans\n\t\t\t\t\t\tcase \"Row\": //Add as many gap as the max number of elements in the dataPoints arrays\n\t\t\t\t\t\t\tcolumnSize = F.ColumnsLength[j]; break;\n\t\t\t\t\t\tcase \"Avg, SD, N\": columnSize = 3; break; //Need to accomodate all three columns\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout += Analyzer.valueHeader(g, F, columnSize);\n\t\t\t});\n\t\t}\n\t\telse {out += Analyzer.blankHeader(F.Format)} //This is to ensure that at least one column exists\n\t\treturn out;\n\t}\n\n}","//*******************************************************************\n// GROUPTABLE object - Class used for the building of 2D group tables\n//*******************************************************************\nclass GroupTable {\n\tconstructor() {return}\n\t//Static Methods\n\tstatic flattenSeries(a, array) { //Flatten the incoming area into a new object that will be pushed into the provided array. Returns the header information for this area, if any\n\t\tswitch(a.Category) {\n\t\t\tcase \"Concentrations\": //In this case, flatten the values\n\t\t\t\ta.Values.forEach(function(v) {\n\t\t\t\t\tarray.push(Group.newTyped(v, \"Conc\", {SetNameAsValue: true})); //Keep the value field to calculate the log when needed\n\t\t\t\t});\n\t\t\t\treturn {Type: \"Conc\", Name: a.Name, Span: a.Values.length, Unit: a.Unit} //Output the corresponding header\n\t\t\tcase \"Ranges\":\n\t\t\t\ta.Values.forEach(function(v) {\n\t\t\t\t\tarray.push(Group.newTyped(v, \"Range\", {OriginIndex: a.OriginIndex})); //Keep the Range metadata to access its definition\n\t\t\t\t});\n\t\t\t\treturn {Type: \"Range\", Name: a.Name, Span: a.Values.length, OriginIndex: a.OriginIndex} //Output the corresponding header\n\t\t\tdefault:\n\t\t\t\tarray.push(new Group(a)); //Push in the array\n\t\t\t\treturn; //Returns nothing as there are no headers required\n\t\t}\n\t}\n\tstatic flattenLevel(level, array) { //Flatten an array containing areas to be flattened within the provided array, and return the corresponding header array\n\t\tlet header = [];\n\t\tlet HasHeader = false;\n\t\tlevel.forEach(function(l) { //Flatten each areas within the input array and collect the corresponding headers\n\t\t\tlet h = this.flattenSeries(l, array); //Flatten it\n\t\t\theader.push(h); //Push the corresponding header\n\t\t\tif(h !== undefined) {HasHeader = true} //At least one element had a header\n\t\t}, this);\n\t\tif(HasHeader) {return header} //Only return a header if at least one element had a header\n\t}\n\tstatic intersect(a, b) { //Return the intersection of the 2 input tag arrays\n//*****************************************************************************************************\n//This method computes the intersection of 2 arrays in a manner that is consistent with the specific\n//structure of the tag arrays: these arrays do not have redundant elements, are limited to <1536 elts\n//and their elements are pure numerical values (indices). Do not use it as a general method to compute\n//the intersection of any two arrays!\n//Because we need to travel one of the two array in full all the time with the filter function, better\n//use the smallest one for this task. The other array that is bigger will be reduce at every step and\n//we do not need to travel it in full since the findIndex method will stop at the first occurence.\n//So for performance optimization, it seems to be a good idea to check which array is smaller.\n//*****************************************************************************************************\n\t\tlet small = a;\n\t\tlet big = b;\n\t\tif(a.length > b.length) {small = b; big = a} //Check and assign the small array to the filter procedure\n\t\tlet safeCopy = big.slice(); //A shallow copy that we will manipulate during the procedure\n\t\tlet inter = small.filter(function(e) { //Return a new array containing the elements that pass the test.\n\t\t\tlet i = safeCopy.findIndex(function(c) {return c == e}); //This loop will stop at the first occurence\n\t\t\tif(i > -1) {\n\t\t\t\tsafeCopy.splice(i, 1); //Remove this element to accelerate next search\n\t\t\t\treturn true; //This element should be kept as it intersects both arrays\n\t\t\t}\n\t\t\treturn false; //Not a duplicate: discard it\n\t\t});\n\t\treturn inter;\n\t}\n\tstatic mergeTags(input, tags) { //Re-process the tags of level1 areas based on level2 tags provided\n\t\tlet copy = [];\n\t\tinput.forEach(function(a) { //Go through the level1 areas\n\t\t\tlet n = new Group(a); //Copy all properties of a into a new object\n\t\t\tn.Tags = this.intersect(a.Tags, tags);; //Update the tags\n\t\t\tcopy.push(n);\n\t\t}, this);\n\t\treturn copy;\n\t}\n\tstatic prepareWrapping(rows, cols, Flat, o) { //Prepare the wrapping for the object o, based on lvl 2 data\n\t\tlet RowGroupHeaders = undefined;\n\t\tlet ColGroupHeaders = undefined;\n\t\tif(rows[1].length > 0) { //Re-process level1 tags according to level2 grouping\n\t\t\tRowGroupHeaders = this.flattenLevel(rows[1], Flat.Lvl2.Rows);\n\t\t\tFlat.Lvl2.Rows.forEach(function(wrap) { //Each level2 item play the role of a wrapper for all level 1\n\t\t\t\tlet temp = this.mergeTags(Flat.Lvl1.Rows, wrap.Tags); //Re-process the tags and output the modified array\n\t\t\t\to.Data.push({SubGroups: temp, Groups: []}); //Push as a new object\n\t\t\t}, this);\n\t\t}\n\t\telse { //There is no wrapping for the rows, so there will be only one object to build\n\t\t\to.Data.push({SubGroups: Flat.Lvl1.Rows, Groups: []});\n\t\t}\n\t\tif(cols[1].length > 0) { //Re-process level1 tags according to level2 grouping\n\t\t\tColGroupHeaders = this.flattenLevel(cols[1], Flat.Lvl2.Cols);\n\t\t\tlet newData = [];\n\t\t\tFlat.Lvl2.Cols.forEach(function(wrap) { //Each level2 item play the role of a wrapper for all level 1\n\t\t\t\tlet temp = this.mergeTags(Flat.Lvl1.Cols, wrap.Tags); //Re-process the tags and output the modified array\n\t\t\t\to.Data.forEach(function(d) { //Apply the object as groups to all existing object with a subgroup\n\t\t\t\t\tlet g = temp.map(function(t) {return new Group(t)}); //A copy of the object is needed\n\t\t\t\t\tnewData.push({SubGroups: d.SubGroups, Groups: g}); //Push the updated copy\n\t\t\t\t});\n\t\t\t}, this);\n\t\t\to.Data = newData; //Use the newly generated array. In this construction, objects are appended col-by-col\n\t\t}\n\t\telse { //There is no wrapping for the cols, so there will be only one object to propagate along the existing objects\n\t\t\to.Data.forEach(function(d) { //Apply the object as groups to all existing object with a subgroup\n\t\t\t\td.Groups = Flat.Lvl1.Cols.map(function(col) {\n\t\t\t\t\treturn new Group(col);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif(rows[1].length > 0 || cols[1].length > 0) { //Build the wrapping object if necessary\n\t\t\to.Wrapping = {Data: {SubGroups: Flat.Lvl2.Rows, Groups: Flat.Lvl2.Cols} }\n\t\t\tif(ColGroupHeaders !== undefined || RowGroupHeaders !== undefined) { //Complete with headers when needed\n\t\t\t\to.Wrapping.Headers = {Rows: RowGroupHeaders, Cols: ColGroupHeaders}\n\t\t\t}\n\t\t}\n\t}\n\tstatic populateData(object, data) { //Populate data within the array of objects\n\t\tobject.forEach(function(o) { //For each object\n\t\t\to.Groups.forEach(function(g) { //For each column\n\t\t\t\tlet t = g.Tags;\n\t\t\t\tif(o.SubGroups.length > 0) {\n\t\t\t\t\to.SubGroups.forEach(function(s) { //For each row\n\t\t\t\t\t\tlet inter = this.intersect(s.Tags, t); //Compute the intersection\n\t\t\t\t\t\tlet values = inter.map(function(v) {return data[v]});//Tag arrays contains well indices that can be used to retrieve the values in the data array\n\t\t\t\t\t\tg.DataPoints.push(values); //Push the constructed data array\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\telse { //Case of a table with only column representation\n\t\t\t\t\tg.DataPoints.push(t.map(function(v) {return data[v]})); //No intersection required, the tag indicates which values to aggregate\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}, this);\n\t}\n//*************************************************\n//Methods for the export of the json to HTML OR TXT\n//*************************************************\n\tstatic export(json, F, headers) { //Output the passed json as a html/txt string. Headers can optionally be switched off\n\t\tlet out = \"\";\n\t\tlet f = F.Format;\n\t\tlet data = json.Data[0]; //Without wrapping, all data are contained in a single data array\n\t\tF.ColumnsLength = data.Groups.map(function(g) { //Compute the array that tells the max number of subcolumns for each columns\n\t\t\treturn g.DataPoints.reduce(function(acc, val) {return Math.max(acc, val.length)}, 0);\n\t\t});\n\t\tout += Analyzer.tableStart(f);\n\t\tout += this.export_ColHeaders(data, F, headers); //Column headers\n\t\tlet track = {Index: 0, HeaderIndex: 0}; //Keeps track of the header indices during the loop\n\t\tif(data.SubGroups.length > 0) {\n\t\t\tdata.SubGroups.forEach(function(r, i) { //Loop the rows\n\t\t\t\tout += Analyzer.rowStart(f);\n\t\t\t\tout += this.export_RowHeader(r, i, track, F, headers) //Header for this row\n\t\t\t\tout += this.export_RowData(i, data, F, headers); //Formatted innerTable data for the row\n\t\t\t\tout += Analyzer.rowEnd(f);\n\t\t\t}, this);\n\t\t}\n\t\telse { //Case of a table with only column representation\n\t\t\tout += Analyzer.rowStart(f);\n\t\t\tout += Analyzer.blankCell(f); //Empty cells for the row headers that are absent\n\t\t\tout += this.export_RowData(0, data, F, headers); //Formatted innerTable data for the row\n\t\t\tout += Analyzer.rowEnd(f);\n\t\t\tif(json.StatRows) { //Last series of rows with statistics, when needed\n\t\t\t\tout += WrapTable.export_StatRows(json, F); //Important to use the full json here, as this method is generic\n\t\t\t}\n\t\t}\n\t\tout += Analyzer.tableEnd(f);\n\t\treturn out;\n\t}\n\tstatic export_ColHeaders(o, F, headers, gaps) { //Prepare the output for the column headers of the GrouTable passed as an object\n\t\tlet out = \"\";\n\t\tlet gap = \"\";\n\t\tlet f = F.Format;\n\t\tif(gaps) {gap = Analyzer.blankCell(f).repeat(gaps)} //Additional gaps to be added when needed. Cases undefined and 0 are both excluded\n\t\tif(headers !== undefined) { //Create the headers\n\t\t\tif(headers.Rows !== undefined) {gap += Analyzer.blankCell(f)} //A blank will be needed to accomodate the row headers\n\t\t\tif(headers.Cols !== undefined) {\n\t\t\t\tout += Analyzer.rowStart(f);\n\t\t\t\tout += gap + Analyzer.blankCell(f); //Leave another blank for the row header\n\t\t\t\tout += Group.colHeaders(headers.Cols, F);\n\t\t\t\tout += Analyzer.rowEnd(f);\n\t\t\t}\n\t\t}\n\t\tout += Analyzer.rowStart(f);\n\t\tout += gap + Analyzer.blankCell(f); //Blank(s) to accomodate row headers\n\t\tout += Group.colValueHeaders(o, F);\n\t\tout += Analyzer.rowEnd(f);\n\t\treturn out;\n\t}\n\tstatic export_RowHeader(row, i, T, F, headers) { //Prepare the html header of row, index i\n\t\tlet out = \"\";\n\t\tif(headers !== undefined && headers.Rows !== undefined) { //If headers are present, check when if it is the right index to append it\n\t\t\tif(i == T.Index) { //This is the right position\n\t\t\t\tlet h = headers.Rows[T.HeaderIndex];\n\t\t\t\tif(h !== undefined && h !== null) { //JSON parsing yields empty array elements as null\n\t\t\t\t\tswitch(F.Format) {\n\t\t\t\t\t\tcase \"html\": out += \"<th rowspan=\\\"\" + h.Span + \"\\\">\" + Analyzer.header(h, F) + \"</th>\"; break;\n\t\t\t\t\t\tcase \"txt\": out += Analyzer.header(h, F) + \"\\t\"; break;\n\t\t\t\t\t}\n\t\t\t\t\tT.Index += h.Span;\n\t\t\t\t}\n\t\t\t\telse { //An empty slot is required to keep the alignment\n\t\t\t\t\tout += Analyzer.blankHeader(F.Format);\n\t\t\t\t\tT.Index += 1;\n\t\t\t\t}\n\t\t\t\tT.HeaderIndex++;\n\t\t\t}\n\t\t\telse { //For txt, need to add a blank for alignement because there is no rowspan as in html\n\t\t\t\tif(F.Format == \"txt\") {out += Analyzer.blankCell(\"txt\")}\n\t\t\t}\n\t\t}\n\t\tout += Analyzer.valueHeader(row, F); //Values of this Header for the row\n\t\treturn out;\n\t}\n\tstatic export_RowData(i, json, F, headers) { //Prepare the data table for the row index i of the json object\n\t\tlet out = \"\";\n\t\tif(F.Aggregation == \"Column\") { //The Col aggregation is more complex and needs to be treated row-per-row\n\t\t\treturn Analyzer.arrayToColumn(i, json, F, headers);\n\t\t}\n\t\tjson.Groups.forEach(function(c, j) { //For all other cases, proceed normally by looping the cols\n\t\t\tif(j > 0 && F.Format == \"txt\") {out += \"\\t\"}\n\t\t\tlet S = Coordinate.statValue(c.DataPoints[i]); //Get the stats for this array\n\t\t\tswitch(F.Aggregation) {\n\t\t\t\tcase \"Row\": //Display values as a horizontal table\n\t\t\t\t\tout += Analyzer.arrayToRow(c.DataPoints[i], F, {Types: Array(c.DataPoints[i].length).fill(\"#\"), ColumnLength: F.ColumnsLength[j]});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Average\": //Only the average is shown\n\t\t\t\t\tout += Analyzer.cellForValue(S.Average, F, {Class: \"BorderSpaced\", Type: \"#\"});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Avg, SD, N\": //Avg, SD, N; Similar to row but with fixed column lengths of 3\n\t\t\t\t\tout += Analyzer.arrayToRow([S.Average, S.SD, S.N], F, Coordinate.headerObject(\"Row\"));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\treturn out;\n\t}\n}","//****************************************************************************\n// REPORT object - Holds the values and controls available to analyze the data\n//****************************************************************************\nclass Report {\n\tconstructor(o, I) {\n\t\tthis.Title = o.Title;\n\t\tthis.Anchors = {\n\t\t\tOutput: \"Output\",\n\t\t\tMenu: \"Menu\",\n\t\t\tOptions: \"Options\",\n\t\t\tExport: \"Export\",\n\t\t\tResults: \"Results\",\n\t\t\tPlateSelect: \"PlateSelect\",\n\t\t\tResultPlate: \"ResultPlate\",\n\t\t\tPlateDoAll: \"PlateDoAll\",\n\t\t\tPairingTarget: \"PairingTarget\",\n\t\t}\n\t\tlet html = \"\";\n\t\thtml += \"<div id=\\\"\" + this.Anchors.Menu + \"\\\"></div>\";\n\t\thtml += \"<div id=\\\"\" + this.Anchors.Output + \"\\\"></div>\"\n\t\tGetId(\"Main\").innerHTML = html;\n\t\tthis.ResolvedNames = []; //Array to collect the names for the definition plates currently selected \n\t\tthis.Results = new RespTable({ //RespTable object controling the available result files\n\t\t\tID: this.Anchors.Results,\n\t\t\tArray: window.opener.Results.map(function(r) {r.LoggedPlate = 0; return r}), //On init, set the logged plate property to 0 for each result\n\t\t\tFields: [\"Name\", \"Size\", \"Info\"], Headers: [\"Name\", \"Size\", \"Parameters\"],\n\t\t\tonSelect: function(s, os, i, oi) { //What to do on result selection\n\t\t\t\tif(i[0] == oi[0]) {return} //Same result is selected, do nothing\n\t\t\t\tReport.saveState(this, oi[0]); //Save the current tab opened for the old selection (selected result)\n\t\t\t\tthis.setPlates().do();\n\t\t\t\tReport.restoreState(this, i[0]); //Restore the opened tab for the newly opened result\n\t\t\t}.bind(this), FullWidth: true, RowNumbers: true, NoControls: true,\n\t\t});\n\t\tthis.Blocs = []; //Array of bloc objects\n\t\tthis.Output = new TabControl({ //Tab to manipulate the Bloc objects\n\t\t\tID: this.Anchors.Output,\n\t\t\tLayout: \"Horizontal\",\n\t\t\tTabs: [],\n\t\t});\n\t\tthis.Menu = new TabControl({ //Menu for the report page\n\t\t\tID: this.Anchors.Menu,\n\t\t\tMultiple: true,\n\t\t\tLayout: \"Menu\",\n\t\t\tTabs: [\n\t\t\t\t{Label: \"Options\", Active: true, Content: {Type: \"HTML\", Value: \"<div id=\\\"\" + this.Anchors.Options + \"\\\"></div>\"} },\n\t\t\t\t{Label: \"Export\", Active: true, Content: {Type: \"HTML\", Value: \"<div id=\\\"\" + this.Anchors.Export + \"\\\"></div>\"} },\n\t\t\t\t{Label: \"Results\", Active: true, Content: {Type: \"HTML\", Value: \"<div id=\\\"\" + this.Anchors.Results + \"\\\"></div>\"} },\n\t\t\t\t{Label: \"Plates\", Active: true, Content: {Type: \"HTML\", Value:\n\t\t\t\t\t\"<fieldset id=\\\"\" + this.Anchors.PlateSelect + \"\\\">\" +\n\t\t\t\t\t\t\"<legend>Result</legend>\" +\n\t\t\t\t\t\t\"<div id=\\\"\" + this.Anchors.ResultPlate + \"\\\"></div>\" +\n\t\t\t\t\t\t\"<div style=\\\"text-align: center; margin-bottom: 5px;\\\" id=\\\"\" + this.Anchors.PairingTarget + \"\\\"></div>\" +\n\t\t\t\t\t\t\"<div id=\\\"\" + this.Anchors.PlateDoAll + \"\\\" style=\\\"text-align: center;\\\"></div>\" +\n\t\t\t\t\t\"</fieldset>\"}\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t\tthis.Options = {\n\t\t\tCollapse: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Collapse tables\", Default: true, Chain: {Index: 0}, Change: function(v) {\n\t\t\t\tlet r = this.Options.Rows;\n\t\t\t\tif(v) {r.enable()}\n\t\t\t\telse {r.disable()}\n\t\t\t\tthis.refresh(\"Rows\", {Collapse: v, Rows: r.getValue()});\n\t\t\t}.bind(this), Title: \"Tick to limit the number of rows displayed in tables\"}),\n\t\t\tRows: LinkCtrl.new(\"Number\", {ID: this.Anchors.Options, Label: \"Rows\", Default: 10, Min: 2, Step: 1, Chain: {Index: 1, Last: true}, Change: function(v) {\n\t\t\t\tthis.refresh(\"Rows\", {Collapse: true, Rows: v});\n\t\t\t}.bind(this), Title: \"Maximum number of rows to show for each table\"}),\n\t\t\tDecimals: LinkCtrl.new(\"Select\", {ID: this.Anchors.Options, Label: \"Decimals\", Default: 3, List: [0, 1, 2, 3, 4, 5, 6, \"All\"], Chain: {Index: 2, NewLine: true}, Change: function(v) {\n\t\t\t\tthis.refresh(\"Decimals\");\n\t\t\t}.bind(this), Title: \"Number of decimals to show for the computed values. Parsed values from the file are not affected\"}),\n\t\t\tCV: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Show CV\", Default: false, Chain: {Index: 3, Last: true}, Change: function(v) {\n\t\t\t\tthis.refresh(\"CV\", {Show: v});\n\t\t\t}.bind(this), Title: \"Tick to show the coefficient of varation (CV, %) for the data\"}),\n\t\t\tExportFormat: LinkCtrl.new(\"Radio\", {ID: this.Anchors.Export, Default: 0, Label: \"Export values\", List: [\"Raw\", \"Displayed\"], Title: \"Controls whether the exported data should be as they appear in the file or after calculation (Raw), or as they appear in the table with the decimal formatting applied (Displayed)\"}),\n\t\t}\n\t\t//if(I && I.Options == \"full\") {\n\t\t\tthis.Options.LogScale = LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Log Scale\", Default: false, Chain: {Index: 4, NewLine: true}, Change: function(v) {\n\t\t\t\tthis.refresh(\"Log\");\n\t\t\t}.bind(this), Title: \"Tick to show the concentration data in log scale\"});\n\t\t\tthis.Options.Shift = LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Shift unit\", Default: false, Chain: {Index: 5, Last: true}, Change: function(v) {\n\t\t\t\tthis.refresh(\"Log\");\n\t\t\t}.bind(this), Title: \"Tick to shift the concentration data to their closest parent value (i.e. M or g/mL) when using the log scale\"});\n\t\t//}\n\t\tthis.UI = { //Container for specific LinkCtrl elements\n\t\t\tPlate: LinkCtrl.new(\"Select\", {ID: this.Anchors.ResultPlate, Default: 0, List: [], Label: \"Plate\", Change: function(index) {\n\t\t\t\tthis.Result.LoggedPlate = index; //Log the selected plate for this result file\n\t\t\t\tthis.pairStatus(index);\n\t\t\t\tthis.do();\n\t\t\t}.bind(this), Title: \"The result plate for which values will be displayed\"}),\n\t\t}\n\t\tthis.Menu.init();\n\t\tthis.Output.init();\n\t\tthis.Results.init();\n\t\tObject.values(this.Options).forEach(function(o) {o.init()});\n\t\tGetId(this.Anchors.Export).append(LinkCtrl.buttonBar([ //Export functionalities\n\t\t\t{Label: \"Export All\", Title: \"Export all the data generated by the report, as a zip file containing tab-delimited text files\", Click: this.exportAll.bind(this)},\n\t\t]));\n\t\treturn this;\n\t}\n\t//Static methods\n\tstatic new(o) {\n\t\tswitch(o.Method) {\n\t\t\tcase \"zFactor\": return new Report_Controls(o);\n\t\t\t//case \"Aggregate\": return new Report_Aggregate(o);\n\t\t\tcase \"Aggregate\": return new Report_Grouped(o, {Options: \"full\", ColumnOnly: true}); //A blunted version of the more general Grouped report\n\t\t\tcase \"Grouped\": return new Report_Grouped(o, {Options: \"full\"});\n\t\t\tcase \"Hits\": return new Report_Hits(o, {Options: \"minimum\"});\n\t\t\tdefault: return new Report(o);\n\t\t}\n\t}\n\tstatic getBloc(report, name) { //Return the desired bloc object (identified by its name) for the report passed\n\t\tlet found = false;\n\t\tlet i = 0;\n\t\tlet blocs = report.Blocs;\n\t\tlet l = blocs.length;\n\t\twhile(!found && i<l) {\n\t\t\tif(blocs[i].Name == name) {found = true}\n\t\t\telse {i++}\n\t\t}\n\t\tif(found) { //Bloc already exists, call it back\n\t\t\treport.Output.Tabs[i].set(\"Enabled\"); //Blocs that are called can be set back as enabled\n\t\t\treturn report.Blocs[i];\n\t\t}\n\t\telse { //Create the bloc\n\t\t\treport.Result.OpenedTab = i; //Set the default state on bloc opening\n\t\t\treturn report.newBloc(name, i);\n\t\t} \n\t}\n\tstatic *plateIterator(source) { //A generator function that create a generator object for counting plates\n\t\tlet l = source.length;\n\t\tfor(let i=0; i<l; i++) {\n\t\t\tyield source[i];\n\t\t}\n\t}\n\tstatic lock(report, plates) { //Lock the report while parsing data\n\t\tlet id = \"Report_Mask\";\n\t\tForm.open({\n\t\t\tID: id,\n\t\t\tHTML: \"<p><span class=\\\"Warning\\\">Parsing in progress, please wait...<span></p><p>Processing plate <span id=\\\"Mask_PlateNumber\\\">1</span> / \" + plates + \"</p>\",\n\t\t\tTitle: \"Analysis in progress...\",\n\t\t\tButtons: [\n\t\t\t\t{Label: \"Abort\", Click: function() {report.cancel()}}\n\t\t\t],\n\t\t\tonCancel: function() {report.cancel()},\n\t\t});\n\t}\n\tstatic unlock() { //Release the report after parsing\n\t\tForm.close(\"Report_Mask\");\n\t}\n\tstatic plateCount(p) { //Update the count of completed plates while analyzing all of them\n\t\tlet target = GetId(\"Mask_PlateNumber\");\n\t\tif(target) {target.innerHTML = p}\n\t}\n\tstatic cleanName(report) { //Return the cleaned name of the selected result for the report object passed, as a safe(r) string to be used for a file name\n\t\tlet n = report.Result.Name;\n\t\tlet l = n.lastIndexOf(\".\");\n\t\tif(l > -1) {return this.cleanFileName(n.substring(0, l))} //The fileName without the extension and cleaned\n\t\telse {return this.cleanFileName(n)} //In case the file name is already without extension\n\t}\n\tstatic cleanFileName(n) { //Clean the provided name to make it a safe(r) string to be used for a file name\n\t\tif(n == \"\" || n === undefined) {return \"unknown\"} //Let's have a fallback for weird cases\n\t\treturn n.trim() //Starts by removing space characters at both ends\n\t\t\t.replace(/[^a-z0-9_\\-\\[\\]\\(\\)\\.]/gi, \"_\") //Replace all undesirable characters with \"_\"\n\t\t\t.replace(/_{2,}/g, \"_\"); //Collapse consecutive \"_\" into one\n\t}\n\tstatic saveState(r, resultIndex) { //Save the state of the panels opened for the result of index passed, for the report provided\n\t\tr.Results.Array[resultIndex].OpenedTab = r.Output.active(); //Save the active bloc\n\t\tr.Output.disable(); //Disable all the tabs. Tabs that are called by getBloc() later during the do() will be set as active\n\t}\n\tstatic restoreState(r, resultIndex) {\n\t\tlet n = r.Results.Array[resultIndex].OpenedTab;\n\t\tif(n !== undefined) {r.Output.jumpTo(n)} //Need a control for the first opening case\n\t}\n\tstatic blocName(param) { //Build a unique bloc name using the properties of the parameter object provided\n\t\treturn param.ResultIndex + \". \" + param.Name;\n\t}\n\tstatic hasData(report, currentPlate) { //Check if the data for the plate are already available for this report\n\t\tlet n = report.FirstBlocIndex;\n\t\tif(n === undefined) {return false} //No blocs available for this Report\n\t\tlet section = report.Blocs[n].getSection(\"Plate Summary\");\n\t\tswitch(section.Type) {\n\t\t\tcase \"Multiple\": //Control report\n\t\t\t\tlet array = section.Tables[0].Data.Data[0].Groups[0].DataPoints[0]; //All tables share the same contents in th plate column\n\t\t\t\treturn array.includes(currentPlate);\n\t\t\tcase \"StatsTable\":\n\t\t\t\tlet source = section.Tables[0].DataArray[0].Groups[0].DataPoints[0]; //The structure is a bit different\n\t\t\t\treturn source.includes(currentPlate);\n\t\t\tdefault: return false;\n\t\t}\n\t}\n\t//Getter and setter\n\tget Result() { //Get the result file currently selected\n\t\tlet r = this.Results.Selected[0];\n\t\tif(r === undefined) {\n\t\t\tthis.Results.setValue([0]);\n\t\t\treturn this.Results.Selected[0];\n\t\t}\n\t\telse {return r}\n\t}\n\tget SelectedPlate() { //Return the currently selected result plate\n\t\treturn this.UI.Plate.Selected.toString(); //Force string output in case of generic index\n\t}\n\tget FirstBlocIndex() { //For the result file selected, get the index of the first bloc containing its data\n\t\tlet start = (this.Results.SelectedIndices[0] + 1) + \". \"; //The start of the name for all the parameters of the selected result file\n\t\tlet found = false;\n\t\tlet i = 0;\n\t\tlet blocs = this.Blocs;\n\t\tlet l = blocs.length;\n\t\twhile(!found && i<l) {\n\t\t\tif(blocs[i].Name.startsWith(start)) {found = true}\n\t\t\telse {i++}\n\t\t}\n\t\tif(found) {return i}\n\t\telse {return undefined}\n\t}\n\tget Params() {\n\t\treturn this.Result.Parameters;\n\t}\n\t//Methods\n\tinit() { //Init the controls on the page\n\t\tObject.values(this.UI).forEach(function(v) {v.init()});\n\t\tthis.setPlates(); //Update plate list and pairing data\n\t\tthis.do(); //Do the job\n\t\treturn this;\n\t}\n\tdo() { //Do the job. Each child report has its own implementation of what to do\n\t\t\n\t}\n\tprepareDefinition() { //Prepare the controls needed to change the definition plates out of the ranges available\n\t\tGetId(this.Anchors.PlateSelect).insertAdjacentHTML(\"afterend\", \"<fieldset style=\\\"margin-top: 5px;\\\"><legend>Definitions</legend><div id=\\\"Definitions_Select\\\"><i>None available</i></div></fieldset>\"); //Append the html to host the definitions\n\t\tthis.Ranges.forEach(function(r, i) { //For each definition input, prepare a select to change the plate used for resolution of the range item\n\t\t\tlet d = r.Definition;\n\t\t\tif(d !== undefined) {\n\t\t\t\tlet sel = LinkCtrl.new(\"Select\", {ID: \"Definitions_Select\", NewLine: true, Index: i, Default: 0, List: d.PlatesID, Label: d.Area.Name, Title: \"The plate to use for the resolution of the names for this range\", Change: function(v) {\n\t\t\t\t\tthis.resolveNames(d, i).then(function(names) { //Fetch the names for the plate selected for this range\n\t\t\t\t\t\tthis.ResolvedNames[i] = names; //Update the name property for this definition\n\t\t\t\t\t\tthis.updateNames(d.Area, i); //Update the displayed names\n\t\t\t\t\t}.bind(this));\n\t\t\t\t\tif(v !== undefined) { //If the change is triggered by a pair setter, v will be undefined and there is no need to check the status. But if the select is changed manually by the user, need to check\n\t\t\t\t\t\tthis.pairStatus(this.UI.Plate.getValue(), {Check: true}); //Update the pair status\n\t\t\t\t\t}\n\t\t\t\t}.bind(this)});\n\t\t\t\tif(sel.List.length > 1) {sel.NavBar = true; sel.Lookup = {Active: false} }\n\t\t\t\tif(i > 0) {sel.Preserve = true}\n\t\t\t\tthis.UI[\"Definition_\" + i] = sel; //Log the definition in the UI object\n\t\t\t}\n\t\t}, this);\n\t\treturn this;\n\t}\n\tsetPlates() { //Update the plate list to match that of the selected result; this will also trigger a pairStatus to update the pairing info\n\t\tlet ui = this.UI.Plate;\n\t\tlet plates = this.Result.PlatesID;\n\t\tui.List = plates;\n\t\tif(plates.length > 1) { //Update the navigation tools\n\t\t\tui.NavBar = true;\n\t\t\tui.Lookup = {Active: false}\n\t\t}\n\t\telse {\n\t\t\tui.NavBar = false;\n\t\t\tui.Lookup = undefined;\n\t\t}\n\t\tlet v = this.Result.LoggedPlate; //Logged plate for this result file\n\t\tui.setValue(v) //Set the selection to the right plate\n\t\tui.init(); //Initialize to re-build the display\n\t\tthis.pairStatus(v); //Update pairing data for the selected plate\n\t\treturn this;\n\t}\n\tpairStatus(index, I) { //Update the pairing information for the result plate selected\n\t\tlet target = GetId(this.Anchors.PairingTarget);\n\t\tlet P = this.Result.Pairing;\n\t\tif(P === undefined) {target.innerHTML = Pair.unpaired().Html; return} //This plate has no pairing information, escape here\n\t\tlet pair = this.Result.Pairing.Pairs[index];\n\t\tif(pair === undefined) {target.innerHTML = Pair.unpaired().Html; return} //This plate has no pairing information, escape here\n\t\tif(this.Ranges) {\n\t\t\tlet pairInfo = pair.getDefPlate(this.Ranges);\n\t\t\tpairInfo.forEach(function(p, i) { //Loop the pairInfo\n\t\t\t\tlet ui = this.UI[\"Definition_\" + p.RangeIndex];\n\t\t\t\tif(ui !== undefined) {\n\t\t\t\t\tif(I && I.Check) { //Comparison only\n\t\t\t\t\t\tif(p.DefPlateIndex == ui.getValue()) { //OK\n\t\t\t\t\t\t\tpair.Table[i].Broken = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { //Set as broken\n\t\t\t\t\t\t\tpair.Table[i].Broken = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { //Setter for the definition\n\t\t\t\t\t\tui.setValue(p.DefPlateIndex).change(); //Trigger a change to update the displayed names\n\t\t\t\t\t\tpair.Table[i].Broken = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t\tlet O = pair.state();\n\t\ttarget.innerHTML = O.Html; //Output\n\t\treturn this;\n\t}\n\tnewBloc(name, index) {\n\t\tlet id = \"Bloc_\" + index;\n\t\tlet bloc = new Bloc({Name: name, ID: id, File: this.Result.Name});\n\t\tthis.Blocs.push(bloc);\n\t\tthis.Output.addTab({Label: name, SetActive: true, Content: {Type: \"HTML\", Value: \"<p>Data for Result file: \" + this.Result.Name + \"</p><div id=\\\"\" + id + \"\\\"><span class=\\\"Warning\\\">Initializing the report, please wait...</span></div>\"} });\n\t\treturn bloc.init();\n\t}\n\tcancel() {\n\t\tthis.Cancel = true;\n\t\treturn this;\n\t}\n\trefresh(what, I) {\n\t\tif(what == \"Rows\") {this.refreshRows(I)}\n\t\telse {\n\t\t\tthis.Blocs.forEach(function(b) {\n\t\t\t\tb.Sections.forEach(function(s) {\n\t\t\t\t\ts.update();\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis.updateNames();\n\t\t}\n\t}\n\tupdate() { //Update the sections without parsing all the data again\n\t\tthis.Blocs.forEach(function(b) { //Update all blocs\n\t\t\tb.Sections.forEach(function(s) { //Update all sections\n\t\t\t\ts.update();\n\t\t\t});\n\t\t});\n\t\treturn this;\n\t}\n\tupdateNames(range, index) { //Update the names for the rangeIndex provided, or all the ranges if nothing is passed\n\t\tlet source = this.Ranges; //Fallback that will be used if range is undefined\n\t\tif(range !== undefined) { //A specific range is provided\n\t\t\tsource = Array(this.Ranges.length);\n\t\t\tsource[index] = range; //This is to ensure we can use the position in the array to find the correct definitions\n\t\t}\n\t\tlet collection = GetId(\"Output\").getElementsByClassName(\"Value_PlaceHolder Header_Range\");\n\t\tlet l = collection.length;\n\t\tfor(let i=0; i<l; i++) { //Travel the collection and search for matching names\n\t\t\tlet th = collection[i];\n\t\t\tlet string = th.innerHTML;\n\t\t\tif(th.hasAttribute(\"RootName\")) {string = th.getAttribute(\"RootName\")} //In this case, recover the saved generic name\n\t\t\telse {th.setAttribute(\"RootName\", string)} //Save the generic name before making modifications\n\t\t\tsource.forEach(function(r, j) { //For each range\n\t\t\t\tif(r !== undefined && this.ResolvedNames[j] !== undefined) { //When a single range is provided, only one element of the array is defined. And when the range has no definitions, the resolved names are absent\n\t\t\t\t\tlet name = r.Name + \" #\";\n\t\t\t\t\tlet n = name.length;\n\t\t\t\t\tlet pos = string.indexOf(name);\n\t\t\t\t\tif(pos > -1) { //The title includes this name\n\t\t\t\t\t\tpos += n; //Update position to start at the #\n\t\t\t\t\t\tlet end = string.indexOf(\" \", pos); //Find the position of the next space\n\t\t\t\t\t\tlet RangeIndex = Number(string.substring(pos, end)); //Extract the range index value\n\t\t\t\t\t\tif(end == -1) {RangeIndex = Number(string.substring(pos))} //In cases where the name is not succeded by a unit or another area, the rangeIndex is up to the end of the string\n\t\t\t\t\t\tth.innerHTML = string.replace(name + RangeIndex, this.ResolvedNames[j][RangeIndex - 1]); //Replace the generic name with the definition\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\tgetValues(selectedPlate) { //Retrieve all the parameter values for the selected plate, as a 2D array the size of the plate\n\t\tlet o = {Items: 0, Values: [], Params: []} //Output object containing the data for one plate\n\t\tlet resultIndex = this.Results.SelectedIndices[0] + 1; //The index of the result file selected (1-based), unique\n\t\tthis.Params.forEach(function(p, i) { //Initialize empty array to receive the values for each selected parameters that is set as numeric\n\t\t\tif(p.Selected) { //This parameter is selected and numeric type, continue\n\t\t\t\to.Params.push({Index: i, Name: p.Name, ResultIndex: resultIndex, Numeric: p.Numeric});\n\t\t\t\to.Values.push([]); //Create empty arrays to receive the values for each parameter\n\t\t\t}\n\t\t}, this);\n\t\tthis.waitMessage(o.Params); //This displays waiting message\n\t\tlet custom = function(well, plate, row, output, parser) { //The function to run on each line\n\t\t\tif(plate == selectedPlate) { //We are on the right plate\n\t\t\t\tlet wellIndex = well.Index;\n\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\n\t\t\t\t\tif(param.Numeric) {output.Values[i][wellIndex] = Number(row[param.Index])}\n\t\t\t\t\telse {output.Values[i][wellIndex] = row[param.Index]}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: custom}, o).then(function(data) {\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t}.bind(this));\n\t}\n\twaitMessage(params) { //Display a waiting message\n\t\tlet msg = \"<br><span class=\\\"Warning\\\">Parsing values, please wait...</span>\";\n\t\tparams.forEach(function(param, i) { //Process all parameters\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\n\t\t\tbloc.Sections.forEach(function(s) {\n\t\t\t\tif(s.Summary === undefined) {s.replaceContent(msg)}\n\t\t\t});\n\t\t}, this);\n\t}\n\trefreshRows(I) { //Update the number of rows displayed per table\n\t\tlet height = \"unset\";\n\t\tif(I.Collapse) {height = Analyzer.divHeight(I.Rows)}\n\t\tlet HTMLcollection = GetId(\"Output\").getElementsByClassName(\"InnerTable_Wrapper\");\n\t\tlet l = HTMLcollection.length;\n\t\tfor(let i=0; i<l; i++) {\n\t\t\tlet elt = HTMLcollection[i];\n\t\t\tlet items = elt.children[0].rows.length;\n\t\t\telt.style.maxHeight = height;\n\t\t\tif(items <= I.Rows) {elt.style.overflowY = \"unset\"}\n\t\t\telse {elt.style.overflowY = \"scroll\"}\n\t\t}\n\t\treturn this;\n\t}\n\texportAll() { //Export all data for available blocs and sections\n\t\tlet Z = new JSZip();\n\t\tlet id = \"Form_Save\";\n\t\tlet outputID = id + \"_Output\";\n\t\tlet fileName = \"ExportAll.zip\";\n\t\tForm.open({ //Open a form for feedback to the user\n\t\t\tID: id,\n\t\t\tHTML: \"<p id=\\\"\" + outputID + \"\\\"><span class=\\\"Warning\\\">Preparing zip archive, please wait...</span></p>\",\n\t\t\tTitle: \"Export data\",\n\t\t\tButtons: [{Label: \"Close\", Click: function() {Form.close(id)}}],\n\t\t});\n\t\tthis.Blocs.forEach(function(bloc) {\n\t\t\tlet mainDir = Z.folder(bloc.File);\n\t\t\tlet dir = mainDir.folder(Report.cleanFileName(bloc.Name));\n\t\t\tbloc.Sections.forEach(function(section) {\n\t\t\t\tlet blob = section.export({BlobOnly: true});\n\t\t\t\tdir.file(Report.cleanFileName(section.Name + \".txt\"), blob);\n\t\t\t});\n\t\t});\n\t\tZ.generateAsync({type: \"blob\"}).then(function (b) {\n\t\t\tlet target = GetId(outputID); //Access the element only at the end\n\t\t\tif(target) {\n\t\t\t\tlet url = URL.createObjectURL(b);\n\t\t\t\ttarget.innerHTML = \"<p>Click on the link below to download and save your file:</p><p style=\\\"text-align: center;\\\"><a href=\\\"\" + url + \"\\\" download=\\\"\" + fileName + \"\\\">\" + fileName + \"</a></p>\"\n\t\t\t\tForm.replaceButtons(id, [{Label: \"Close\", Click: function() {URL.revokeObjectURL(url); Form.close(id)}}]); //Revoke the URL has it is no longer useful\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}","//*********************************************************************************\n// SECTION object - Second layer used to organize reporting of data in the analyzer\n//*********************************************************************************\nclass Section {\n\tconstructor(I) {\n\t\tthis.ID = I.ID;\n\t\tthis.Bloc = I.Bloc; //Parent bloc object\n\t\tthis.Name = I.Name; //Internal name\n\t\tthis.Data = undefined; //Data stored for this section\n\t\tthis.Type = (I.Type || \"Single\"); //Defines the table types: Single, StatsTable or Multiple\n\t\tif(I.Summary !== undefined) {this.Summary = true}\n\t\tlet json = I.JSON; //Must be supplied for StatsTable and multiple types\n\t\tswitch(this.Type) { //Create tables when appropriate\n\t\t\tcase \"StatsTable\":\n\t\t\t\tthis.Tables = [];\n\t\t\t\tif(json.Wrapping) { //Use the level 2 wrapping to create as many tables as needed\n\t\t\t\t\tjson.Wrapping.Data.Groups.forEach(function(g, j) {\n\t\t\t\t\t\tlet id = this.ID + \"_DT_\" + j;\n\t\t\t\t\t\tthis.Tables.push(new StatsTable(id, g, json));\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\telse { //There will be only one table\n\t\t\t\t\tthis.Tables.push(new StatsTable(this.ID + \"_DT_\" + 0, undefined, json));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Multiple\":\n\t\t\t\tthis.Tables = [];\n\t\t\t\tjson.forEach(function(j, i) {\n\t\t\t\t\tlet id = this.ID + \"_MT_\" + i;\n\t\t\t\t\tthis.Tables.push(new CustomTable(id, j));\n\t\t\t\t}, this);\n\t\t\t\tbreak;\n\t\t\tdefault: break; //Nothing else to do here\n\t\t}\n\t\treturn this;\n\t}\n\t//Static methods\n\tstatic fullName(s) { //Provide a name representing the full data embedded in the section\n\t\tlet names = [s.Bloc.File, s.Bloc.Name, s.Name].map(function(n) {return Report.cleanFileName(n)}); //Clean each name individually\n\t\tlet name = \"(\" + names[0] + \")_\" + names[1] + \"_[\" + names[2] + \"]\"; //Merge the names together into a single string: (fileName)_BlocName_[SectionName]\n\t\treturn name.replace(/_{2,}/g, '_'); //Eliminate consecutive _\n\t}\n\tstatic fileHeader(s) { //Prepare a header for the file to be exported, that summarizes exactly where these data belongs to\n\t\tlet header = \"[File metadata]\\n\";\n\t\theader += \"Result file: \" + s.Bloc.File + \"\\n\";\n\t\theader += \"Parameter: \" + s.Bloc.Name + \"\\n\";\n\t\theader += \"Table: \" + s.Name + \"\\n\";\n\t\theader += \"Plate: \" + Analyzer.Report.UI.Plate.Selected + \"\\n\";\n\t\tlet ranges = Analyzer.Report.Ranges;\n\t\tif(ranges !== undefined && ranges.length > 0) { //If ranges exist, output the metadata for them\n\t\t\tranges.forEach(function(r, i) { //Loop the ranges\n\t\t\t\tlet d = Analyzer.Report.UI[\"Definition_\" + i]; //Corresponding definition\n\t\t\t\tif(d !== undefined) { //If it exists\n\t\t\t\t\theader += \"Definition plate for range '\" + r.Name + \"': \" + d.Selected + \"\\n\";\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tlet agg = Analyzer.Report.UI.DataView.Selected;\n\t\tif(agg !== undefined) {header += \"Aggregation: \" + agg + \"\\n\"} //Aggregation for reports supporting it\n\t\treturn header + \"\\n\" + \"[Data]\\n\";\n\t}\n\t//Getter, Setter\n\tget TablesHtml() {\n\t\tlet html = \"<div>\"; //Wrapping div\n\t\tthis.Tables.forEach(function(t) {html += t.html()});\n\t\thtml += \"</div>\";\n\t\treturn html;\n\t}\n\t//Methods\n\tHTML(title) { //Prepare the inner html for a section\n\t\tlet html = \"\";\n\t\thtml += \"<fieldset><legend>\" + title + \"</legend><div class=\\\"Section_Controls\\\"></div><div id=\\\"\" + this.ID + \"\\\" class=\\\"Section\\\">\";\n\t\tswitch(this.Type) {\n\t\t\tcase \"Multiple\": //FALL THROUGH\n\t\t\tcase \"StatsTable\": html += this.TablesHtml; break;\n\t\t\tdefault: break;\n\t\t}\n\t\thtml += \"</div></fieldset>\";\n\t\treturn html\n\t}\n\tactivateControls() { //Activate control elements within this section\n\t\tlet me = GetId(this.ID);\n\t\tme.previousSibling.append(LinkCtrl.buttonBar([\n\t\t\t{Label: \"Export\", Title: \"Click to export the data for this section\", Click: function() {this.export({FileName: Section.fullName(this)})}.bind(this)},\n\t\t\t{Label: \"Printable version\", Title: \"Click to view the data in a new window, allowing for printing or easy copy-pasting in other applications\", Click: function() {this.printable()}.bind(this)},\n\t\t]));\n\t}\n\treplaceContent(content) {\n\t\tlet me = GetId(this.ID);\n\t\tme.innerHTML = content;\n\t\treturn this;\n\t}\n\tupdate(source) { //Update the content of the section\n\t\tswitch(this.Type) {\n\t\t\tcase \"StatsTable\": //FALL THROUGH\n\t\t\tcase \"Multiple\": //In this case, update the tables\n\t\t\t\tthis.replaceContent(this.TablesHtml);\n\t\t\t\treturn this;\n\t\t\tdefault: //Other cases will use the provided or logged content\n\t\t\t\tlet content = {}; \n\t\t\t\tif(source) { //Use the provided content if any\n\t\t\t\t\tcontent = source;\n\t\t\t\t}\n\t\t\t\telse { //Stored data should be reused\n\t\t\t\t\tcontent = JSON.parse(this.Data); //Using the provided content is faster, so parsing the data should be done only when really necessary\n\t\t\t\t}\n\t\t\t\tthis.replaceContent(Analyzer.exportJSON(content, \"html\"));\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\texport(I) { //Export section data as txt\n\t\tlet save = Section.fileHeader(this);\n\t\tswitch(this.Type) {\n\t\t\tcase \"Multiple\": //FALL THROUGH\n\t\t\tcase \"StatsTable\":\n\t\t\t\tthis.Tables.forEach(function(t, i) {\n\t\t\t\t\tif(i > 0) {save += \"\\n\"}\n\t\t\t\t\tsave += \"\\n\" + t.TitleExport + \"\\n\"; //Spacing and title  between tables\n\t\t\t\t\tsave += Analyzer.exportJSON(t.buildJSON(), \"txt\"); //Export tables one after the other\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlet content = JSON.parse(this.Data);\n\t\t\t\tsave += Analyzer.exportJSON(content, \"txt\");\n\t\t\t\tbreak;\n\t\t}\n\t\tif(I && I.TxtOnly) { //If only the txt is required (chaining with other contents), exit here by returning the txt\n\t\t\treturn save;\n\t\t}\n\t\tif(I && I.BlobOnly) { //If only the blob is required (chaining with other files), exit here by returning the blob\n\t\t\tlet blob = new Blob([save], {type : \"text/plain;charset=utf-8\"});\n\t\t\treturn blob;\n\t\t}\n\t\tlet fileName = \"Results.txt\";\n\t\tif(I && I.FileName) {fileName = I.FileName + \".txt\"}\n\t\tForm.download(save, {FileName: fileName});\n\t\treturn this;\n\t}\n\tprintable() { //Open a new window containing only the table and allowing easy copy-pasting / printing\n\t\tReporter.printable(GetId(this.ID).innerHTML);\n\t\treturn this;\n\t}\n\taddRow(json, plate, I) {\n\t\tif(this.Tables === undefined) { //Only sections with tables support this feature\n\t\t\tconsole.warn(\"This section has no Tables defined to push new row!\", this);\n\t\t\treturn;\n\t\t}\n\t\tthis.Tables.forEach(function(t, i) { //Update the tables\n\t\t\tt.addRow(json.Data[i], plate, I);\n\t\t});\n\t\treturn this;\n\t}\n\t//**********************************************************************************\n\t//This method is called by the Report_Hits, to resolve the hit names after screening\n\t//**********************************************************************************\n\tresolveNames(I) { //For this section, resolve the names for the plate whose values are transferred, by looping the collection of resolvable elements and resolving as needed\n\t\tlet sectionID = GetId(this.ID);\n\t\tlet div = sectionID.parentElement.getElementsByClassName(\"ResolveStatus\")[0]; //The div for the status\n\t\tif(I.Count == 0) { //This is the first pass, use it to spawn the stop button and display spans\n\t\t\tlet b = LinkCtrl.button({Label: \"Cancel\", Click: function() {this.Stop = true}.bind(I.Report), Title: \"Click here to stop the name resolution process\"});\n\t\t\tdiv.innerHTML = \"<span></span><span></span>&nbsp;\"; //Add spans for the text\n\t\t\tdiv.append(b); //Add the cancel button\n\t\t\tdiv.children[0].innerHTML = \"Resolving range names, please wait... \"; //Update the text msg\n\t\t}\n\t\telse { //Update the remaining count\n\t\t\tdiv.children[1].innerHTML = \"( Plate \" + I.Count + \" / \" + I.Total + \")&nbsp;\"; //Update the plate count msg\n\t\t}\n\t\tlet coll = sectionID.getElementsByClassName(\"Resolvable\"); //The HTMLcollection of elements to resolve in this section. Recall it each time, because the number of element remaining will decrease after each turn\n\t\tlet l = coll.length;\n\t\tfor(let i=0;i<l;i++) { //Travel the collection to update the data\n\t\t\tlet c = coll[i];\n\t\t\tlet rangeName = c.getAttribute(\"rangename\");\n\t\t\tif(rangeName == I.Range.Name) { //Matching range\n\t\t\t\tlet rowIndex = c.parentElement.parentElement.rowIndex; //Go back to the tr to get the index of this row\n\t\t\t\tlet source = this.Tables[0].Data.Data[0].Groups; //Source of the data\n\t\t\t\tlet plate = source[1].DataPoints[0][rowIndex];\n\t\t\t\t//let plate = sectionID.getElementsByClassName(\"InnerTable\")[1].rows[rowIndex].innerText; //Recover the plate name\n\t\t\t\tif(plate == I.Plate) { //Matching plate\n\t\t\t\t\tlet well = JSON.parse(c.getAttribute(\"well\")); //Recover a pseudo-well object\n\t\t\t\t\tlet newName = I.Names[well.Index];\n\t\t\t\t\tif(newName !== undefined && newName !== null && newName.length > 0) { //Update the generic name with the resolved one, if it exists\n\t\t\t\t\t\tc.innerHTML = newName;\n\t\t\t\t\t\tsource[3].DataPoints[0][rowIndex] = newName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}","//***************************************************************************************************************\n// STATSTABLE object - Object to represent tables with pre-configured statistical columns [Avg, SD, CV, N, Total]\n//***************************************************************************************************************\nclass StatsTable {\n\tconstructor(id, group, json) {\n\t\tthis.ID = id;\n\t\tthis.Group = group;\n\t\tlet n = json.Data[0].Groups.length; //All incoming Data share the same number of column\n\t\tthis.Length = n //ColCycle of the table, corresponds to lvl2 (Wrapping) Groups array size for the table\n\t\tthis.SubGroups = []; //Represent the level 1 rows. Left empty so that the table is a pure column table (will get statistical rows)\n\t\tthis.DataArray = [//Represent the level 1 data for the table\n\t\t\t{\n\t\t\t\tGroups: [{Name: \"Plate Name\", DataPoints: [ [] ]}],\n\t\t\t\tSubGroups: [],\n\t\t\t}\n\t\t]; \n\t\tfor(let i=0; i<n; i++) { //Loop over the ColCycle to populate the DataArray\n\t\t\tlet g = {Groups: [], SubGroups: []}; //Initialize the object\n\t\t\tCoordinate.statObject(true).forEach(function(s) { //Populate the level 1 using statistical items (always include the CV)\n\t\t\t\tg.Groups.push({\n\t\t\t\t\tName: s.Name,\n\t\t\t\t\tDataPoints: [ [] ], //Initialize empty DataPoints arrays, will be filled out on the fly later\n\t\t\t\t});\n\t\t\t}, this);\n\t\t\tthis.DataArray.push(g);\n\t\t}\n\t\tif(json.Headers !== undefined) { //There are headers for the level 1 incoming data that should be transferred as level 2\n\t\t\tthis.Wrap_Headers = [null].concat(json.Headers.Cols); //Transfer the array; add an empty header for the plate column\n\t\t}\n\t\tthis.Wrap_Groups = [{Name: \"\"}].concat(json.Data[0].Groups); \n\t\treturn this;\n\t}\n\t//Static methods\n\t\n\t//Getter, Setter\n\tget Title() { //Getter for the title of the table\n\t\tif(this.Group !== undefined) {\n\t\t\tlet F = Analyzer.getConfig(\"html\");\n\t\t\tswitch(this.Group.Type) {\n\t\t\t\tcase \"Conc\": //FALL-THROUGH\n\t\t\t\t\tlet name = Analyzer.header(this.Group, F);\n\t\t\t\t\tlet value = Analyzer.valueHeader(this.Group, F).replaceAll(\"th\", \"span\"); //Replace the th to make a span\n\t\t\t\t\tif(this.Group.Unit == \"MOI\") {return name + \" \" + value}\n\t\t\t\t\telse {return value + \" \" + name}\n\t\t\t\tcase \"Range\":\n\t\t\t\t\tlet title = Analyzer.valueHeader(this.Group, F); //This will give a th element\n\t\t\t\t\treturn title.replaceAll(\"th\", \"span\"); //Replace the th to make a span \n\t\t\t\tdefault: return this.Group.Name;\n\t\t\t}\n\t\t}\n\t\treturn \"Plate Summary\"; //Group is undefined (only one table)\n\t}\n\tget TitleExport() { //Return the formatted html title for export as text\n\t\treturn GetId(this.ID).getElementsByClassName(\"DynTable_Title\")[0].innerText;\n\t}\n\t//Methods\n\thtml() { //Return the html to initialize this table\n\t\tlet html = \"\";\n\t\thtml += \"<div id=\\\"\" + this.ID + \"\\\" class=\\\"DynTable_Wrap\\\">\";\n\t\thtml += \"<fieldset class=\\\"DynTable_Container\\\">\";\n\t\thtml += \"<legend class=\\\"DynTable_Title\\\">\" + this.Title + \"</legend>\";\n\t\thtml += Analyzer.exportJSON(this.buildJSON(), \"html\");\n\t\thtml += \"</fieldset>\";\n\t\thtml += \"</div>\";\n\t\treturn html;\n\t}\n\tbuildJSON() { //Produce the JSON for this stats table\n\t\tlet json = {\n\t\t\tData: this.DataArray,\n\t\t\tWrapping: {\n\t\t\t\tData: {\n\t\t\t\t\tGroups: this.Wrap_Groups,\n\t\t\t\t\tSubGroups: []\n\t\t\t\t}\n\t\t\t},\n\t\t\tStatRows: true,\n\t\t\tSyncScrolling: true,\n\t\t\tGenericRangeName: true,\n\t\t}\n\t\tif(this.Wrap_Headers !== undefined) {\n\t\t\tjson.Wrapping.Headers = {Cols: this.Wrap_Headers};\n\t\t}\n\t\treturn json;\n\t}\n\taddRow(data, plate, I) { //Add a row of data for the plate provided\n\t\tif(this.hasData(plate)) {return this} //This row of data already exists, nothing needed here\n\t\tthis.DataArray.forEach(function(d, i) {\n\t\t\tif(i == 0) {d.Groups[0].DataPoints[0].push(plate)} //Plate name\n\t\t\telse { //Values\n\t\t\t\tlet stat = {};\n\t\t\t\tif(I !== undefined && I.Stats !== undefined) {\n\t\t\t\t\tstat = I.Stats[i-1]; //Stats are pre-computed and provided\n\t\t\t\t}\n\t\t\t\telse { //Compute the stats from the incoming data\n\t\t\t\t\tstat = Coordinate.statValue(data.Groups[i-1].DataPoints[0]);\n\t\t\t\t}\n\t\t\t\tlet o = Coordinate.statObject(true); //Stat object as an array, including the CV\n\t\t\t\to.forEach(function(s, j) { //Add the datapoints\n\t\t\t\t\td.Groups[j].DataPoints[0].push(stat[s.Name]);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\thasData(p) { //Check if the data already exist in the table. Use the first column as \n\t\tlet found = false;\n\t\tlet data = this.DataArray[0].Groups[0].DataPoints[0];\n\t\tlet i = 0;\n\t\tlet max = data.length;\n\t\twhile(found === false && i < max) { //A while loop is more efficient because it stops when the match is found\n\t\t\tif(data[i] == p) {found = true}\n\t\t\ti++;\n\t\t}\n\t\treturn found;\n\t}\n}","//***************************************************************************************\n// WRAPTABLE object - Class used for the building of a wrapping table for 2D group tables\n//***************************************************************************************\nclass WrapTable {\n\tconstructor(w) {\n\t\tthis.Headers = w.Headers; //Wrapping headers\n\t\tthis.Data = w.Data; //Wrapping data\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic export_StatRows(json, F) { //Compute and return the Avg, SD, N, CV for each columns of the json. Must be a single Row object!\n\t\tlet out = \"\";\n\t\tlet f = F.Format;\n\t\tlet stats = []; //Array to store the computed stats for each column\n\t\tif(json.Stats !== undefined) {stats = json.Stats}\n\t\telse {\n\t\t\tjson.Data.forEach(function(d) {\n\t\t\t\td.Groups.forEach(function(c, j) { //Loop the cols\n\t\t\t\t\tlet S = Coordinate.statValue(c.DataPoints[0]); //Get the stats for this array. Only Row 0 is used because there should not be others\n\t\t\t\t\tstats.push(S);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tlet array = Coordinate.headerObject(\"Col\", F.CV);\n\t\tarray.forEach(function(s, i) { //Loop the array to make the output, row by row\n\t\t\tout += Analyzer.rowStart(f);\n\t\t\tif(f == \"txt\") {out += s.Name + \"\\t\"}\n\t\t\telse {out += \"<th Class=\\\"TotalRows\\\">\" + s.Name + \"</th>\"}\n\t\t\tstats.forEach(function(stat, j) { //Loop the cols\n\t\t\t\tout += Analyzer.cellForValue(stat[s.Name], F, s); //Values of the stat for each column\n\t\t\t\tif(f == \"txt\") {out += \"\\t\"} //For txt output, add a tab\n\t\t\t});\n\t\t\tout += Analyzer.rowEnd(f);\n\t\t});\n\t\treturn out;\n\t}\n\t//Methods\n\texport(json, F) { //Output the html for the table\n\t\tlet out = Analyzer.tableStart(F.Format);\n\t\tlet cycle = this.Data.SubGroups.length; //How many times the level 1 values should be repeated (in rows)\n\t\tlet values = json.Data[0].SubGroups.length; //Number of level 1 values. All objects in Data share the same SubGroups arrays\n\t\tout += this.colHeaders(json, F); //Prepare the column headers\n\t\tlet constant = {\n\t\t\tRowCycle: (cycle || 1), //Ensure at least one col\n\t\t\tRowValues: (values || 1), //Ensure at least one row \n\t\t\tHeadTrack: {Index: 0, HeaderIndex: 0}, //Keeps track of the header indices during the loop\n\t\t\tWrapTrack: {Index: 0, HeaderIndex: 0},\n\t\t}\n\t\tlet totalRow = constant.RowCycle * constant.RowValues; //At least one per construction\n\t\tF.Gap = this.rowTxtGaps(json); //Number of gaps needed to accomodate the data, for column + txt export\n\t\tfor(let i=0; i<totalRow; i++) { //Go through all the rows\n\t\t\tout += Analyzer.rowStart(F.Format);\n\t\t\tout += this.rowHeaders(json, i, constant, F); //Append the headers for this row\n\t\t\tout += this.rowData(json, i, constant, F); //Loop the cols to add the cell values\n\t\t\tout += Analyzer.rowEnd(F.Format);\n\t\t}\n\t\tif(cycle == 0 && values == 0 && json.StatRows) { //There are no rows, pure column table\n\t\t\tout += WrapTable.export_StatRows(json, F) //Export the statistics when needed\n\t\t}\n\t\tout += Analyzer.tableEnd(F.Format);\n\t\treturn out;\n\t}\n\tcolHeaders(json, F) { //Prepare the headers for the columns of this table\n\t\tlet out = \"\";\n\t\tlet f = F.Format;\n\t\tlet gap = 0; //This gap represents the number of columns that need to stay blank to accomodate the row headers\n\t\tif(this.Data.SubGroups.length > 0) { //There is some level 2 items\n\t\t\tif(this.Headers !== undefined && this.Headers.Rows !== undefined) {gap += 2} //If the wrapping has headers, add 2\n\t\t\telse {gap++} //Otherwise only one gap is needed\n\t\t}\n\t\tif(this.Data.Groups.length == 0) { //Case where there are no level 2 wrapping for the columns\n\t\t\tlet j = json.Data[0];\n\t\t\tF.ColumnsLength = j.Groups.map(function(g) { //Compute the array that tells the max number of subcolumns for each columns\n\t\t\t\treturn g.DataPoints.reduce(function(acc, val) {return Math.max(acc, val.length)}, 0);\n\t\t\t});\n\t\t\treturn GroupTable.export_ColHeaders(j, F, json.Headers, gap);\n\t\t}\n\t\tif(json.Headers !== undefined && json.Headers.Rows !== undefined) {gap += 2} //If the level 1 also has headers, add one more gap\n\t\telse {gap++}\n\t\tlet blank = Analyzer.blankCell(f).repeat(gap); //The blank columns to be added in front of the column headers\n\t\tlet head = Array(4).fill(\"\"); //Initialize empty array for the headers\n\t\tlet colLengths = []; //Array to log the lengths of each level 2 column, to build the level 2 headers\n\t\tthis.Data.Groups.forEach(function(g, i) { //For each level 2 value, append the corresponding level 1 headers\n\t\t\tF.ColumnsLength = json.Data[i].Groups.map(function(g) { //Compute the array that tells the max number of subcolumns for each columns\n\t\t\t\treturn g.DataPoints.reduce(function(acc, val) {return Math.max(acc, val.length)}, 1);\n\t\t\t\t//Using a starting value of 1 here ensures that at least one blank will be counted, even for a single, empty column\n\t\t\t});\n\t\t\thead[3] += Group.colValueHeaders(json.Data[i], F); //******************* LEVEL 1 VALUES **************\n\t\t\tif(json.Headers !== undefined && json.Headers.Cols !== undefined) { \n\t\t\t\thead[2] += Group.colHeaders(json.Headers.Cols, F); //******************* LEVEL 1 HEADERS **************\n\t\t\t}\n\t\t\tlet n = json.Data[i].Groups.length;\n\t\t\tlet columnSize = n;\n\t\t\tif(f == \"txt\") {\n\t\t\t\tswitch(F.Aggregation) { //Two cases requires addition of additional spans\n\t\t\t\t\tcase \"Row\": //Add as many gap as the max number of elements in the dataPoints arrays\n\t\t\t\t\t\tcolumnSize = F.ColumnsLength.reduce(function(acc, val) {return acc + val}, 0); //Sum of all column lengths\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\n\t\t\t\t\tcase \"Avg, SD, N\": columnSize = n * 3; break; //Each column has a length of 3\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolLengths.push(columnSize); //Log the size of this column\n\t\t\thead[1] += Analyzer.valueHeader(g, F, columnSize); //******************* LEVEL 2 VALUE **************\n\t\t});\n\t\tif(this.Headers !== undefined && this.Headers.Cols !== undefined) { //level 2 header, the final line, when needed\n\t\t\tF.ColumnsLength = []; //Reset this array to repurpose it for level 2 headers\n\t\t\tlet track = 0; //Tracker for the colLengths array\n\t\t\tthis.Headers.Cols.forEach(function(h) { //For each header\n\t\t\t\tlet sum = 0;\n\t\t\t\tlet s = 1; //Span of this header, represent the number of groups it is composed of\n\t\t\t\tif(h !== null && h !== undefined) {s = h.Span}\n\t\t\t\tfor(let i=0; i<s; i++) {sum += colLengths[i + track]} //Sum the data\n\t\t\t\tif(h !== null && h !== undefined) {\n\t\t\t\t\tswitch(f) {\n\t\t\t\t\t\tcase \"html\": head[0] += \"<th colspan=\\\"\" + sum + \"\\\">\" + Analyzer.header(h, F) + \"</th>\"; break;\n\t\t\t\t\t\tcase \"txt\": head[0] += Analyzer.header(h, F) + Analyzer.blankCell(\"txt\").repeat(sum); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswitch(f) {\n\t\t\t\t\t\tcase \"html\": head[0] += Analyzer.blankHeader(\"html\", {Dir: \"Col\", Span: sum}); break;\n\t\t\t\t\t\tcase \"txt\": head[0] += Analyzer.blankCell(\"txt\").repeat(sum); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttrack += s;\n\t\t\t});\n\t\t}\n\t\thead.forEach(function(h) {\n\t\t\tif(h.length > 0) {out += Analyzer.rowStart(f) + blank + h + Analyzer.rowEnd(f)}\n\t\t});\n\t\treturn out;\n\t}\n\trowHeaders(json, i, constant, F) {\n\t\tlet out = \"\";\n\t\tlet f = F.Format;\n\t\tif(this.Data.SubGroups.length == 0 && json.Data[0].SubGroups.length == 0) { //There are no rows, pure column table\n\t\t\treturn Analyzer.blankCell(f); //Nothing to output\n\t\t}\n\t\tlet n = constant.RowValues;\n\t\tlet lvl2Index = Math.floor(i / n);\n\t\tlet lvl1Index = i % n;\n\t\tif(this.Headers !== undefined && this.Headers.Rows !== undefined) { //LEVEL 2 HEADER\n\t\t\tif(lvl2Index == constant.WrapTrack.Index) { //This is the right position\n\t\t\t\tlet h = this.Headers.Rows[constant.WrapTrack.HeaderIndex];\n\t\t\t\tif(h !== undefined && h !== null) { //JSON parsing yields empty array elements as null\n\t\t\t\t\tswitch(f) {\n\t\t\t\t\t\tcase \"html\": out += \"<th rowspan=\\\"\" + (h.Span * n) + \"\\\">\" + Analyzer.header(h, F) + \"</th>\"; break;\n\t\t\t\t\t\tcase \"txt\": out += Analyzer.header(h, F) + \"\\t\"; break;\n\t\t\t\t\t}\n\t\t\t\t\tconstant.WrapTrack.Index += h.Span;\n\t\t\t\t}\n\t\t\t\telse { //An empty slot is required to keep the alignment\n\t\t\t\t\tout += Analyzer.blankHeader(f, {Span: n, Dir: \"Row\"});\n\t\t\t\t\tconstant.WrapTrack.Index += 1;\n\t\t\t\t}\n\t\t\t\tconstant.WrapTrack.HeaderIndex++;\n\t\t\t}\n\t\t\telse { //For txt, need to add a blank for alignement because there is no rowspan as in html\n\t\t\t\tif(f == \"txt\") {out += Analyzer.blankCell(\"txt\")}\n\t\t\t}\n\t\t}\n\t\tif(i % n == 0) { //This marks the start of a new level 1 cycle and the next level 2 value\n\t\t\tif(this.Data.SubGroups.length > 0) {out += Analyzer.valueHeader(this.Data.SubGroups[lvl2Index], F, n, \"Row\")} //LEVEL 2 VALUE\n\t\t\tif(i > 0) {constant.HeadTrack = {Index: 0, HeaderIndex: 0}} //Reset the level 1 tracker for a new cycle\n\t\t}\n\t\telse { //For txt, need to add a blank for alignement because there is no rowspan as in html\n\t\t\tif(f == \"txt\") {out += Analyzer.blankCell(\"txt\")}\n\t\t}\n\t\tlet row = json.Data[lvl2Index].SubGroups[lvl1Index]; //Current lvl 1 value\n\t\tout += GroupTable.export_RowHeader(row, lvl1Index, constant.HeadTrack, F, json.Headers); //LEVEL 1 HEADER / VALUE\n\t\treturn out;\n\t}\n\trowTxtGaps(json) { //Compute the number of gaps (Tabs) to add in front of this row, for txt export\n\t\tlet gap = 1;\n\t\tif(json.Headers !== undefined && json.Headers !== null) {\n\t\t\tif(json.Headers.Rows !== undefined) {gap++}\n\t\t}\n\t\tif(this.Headers !== undefined && this.Headers.Rows !== undefined) {gap++}\n\t\tif(this.Data.SubGroups.length > 0) {gap++}\n\t\treturn gap;\n\t}\n\trowData(json, i, constant, F) { //Append the row of data at line i\n\t\tlet out = \"\";\n\t\tlet n = constant.RowValues;\n\t\tlet cycle = constant.RowCycle;\n\t\tlet lvl1Index = i % n; //Index of the data in the DataPoints array for this row\n\t\tlet lvl2Index = Math.floor(i / n); //Index of the first object carrying the data for this row\n\t\tif(this.Data.Groups.length > 0) { //Objects are sorted column-by-column, so need to find the right objects for this row\n\t\t\tlet m = this.Data.Groups.length * cycle; //Total number of objects available\n\t\t\tlet collected = []; //Array of Data objects index to be collected and appended for this row\n\t\t\twhile(lvl2Index < m) { //Process until the end of the col level2 values\n\t\t\t\tcollected.push(lvl2Index);\n\t\t\t\tlvl2Index += cycle; //Increment by the level2 row value number at each loop\n\t\t\t}\n\t\t\tif(F.Format == \"txt\" && F.Aggregation == \"Column\") { //Special case that need to be treated differently\n\t\t\t\tout += this.export_RowData(json, collected, lvl1Index, F); //No need to supply headers\n\t\t\t}\n\t\t\telse { //All other cases\n\t\t\t\tcollected.forEach(function(v, k) { //Append the elements one after the other\n\t\t\t\t\tif(k > 0 && F.Format == \"txt\") {out += Analyzer.blankCell(\"txt\")}\n\t\t\t\t\tlet o = json.Data[v];\n\t\t\t\t\tF.ColumnsLength = o.Groups.map(function(g) { //Compute the array that tells the max number of subcolumns for each columns\n\t\t\t\t\t\treturn g.DataPoints.reduce(function(acc, val) {return Math.max(acc, val.length)}, 0);\n\t\t\t\t\t});\n\t\t\t\t\tout += GroupTable.export_RowData(lvl1Index, o, F); //No need to supply headers\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\telse { //Objects are in order\n\t\t\tlet j = json.Data[lvl2Index];\n\t\t\tF.ColumnsLength = j.Groups.map(function(g) { //Compute the array that tells the max number of subcolumns for each columns\n\t\t\t\treturn g.DataPoints.reduce(function(acc, val) {return Math.max(acc, val.length)}, 0);\n\t\t\t});\n\t\t\treturn GroupTable.export_RowData(lvl1Index, j, F); //No need to supply headers\n\t\t}\n\t}\n\texport_RowData(json, collected, lvl1Index, F) { //Export data for this row in columns, by constructing the column arrays row-by-row\n\t\tlet out = \"\";\n\t\tlet MaxRow = 0;\n\t\tlet gap = Analyzer.blankCell(\"txt\").repeat(F.Gap);\n\t\tcollected.forEach(function(v) { //Loop the columns to find the max nb of rows\n\t\t\tlet max = json.Data[v].Groups.reduce(function(acc, val) {return Math.max(acc, val.DataPoints[lvl1Index].length)}, 0);\n\t\t\tMaxRow = Math.max(MaxRow, max); //Update MaxRow so that it really ends up as the biggest for all collected Groups\n\t\t});\n\t\tif(MaxRow == 0) {return Analyzer.noData(\"txt\")} //Nothing to do anymore\n\t\tfor(let j=0; j<MaxRow; j++) { //Produce the row-per-row output\n\t\t\tif(j > 0) {out += \"\\n\" + gap} //Start of a new line\n\t\t\tcollected.forEach(function(v, k) { //Go through the Column Groups\n\t\t\t\tlet o = json.Data[v];\n\t\t\t\to.Groups.forEach(function(g) { //Loop the columns in this group\n\t\t\t\t\tlet val = g.DataPoints[lvl1Index][j]; //Value at this location\n\t\t\t\t\tif(val !== undefined) {out += Analyzer.cellForValue(val, F)} //Add it if defined\n\t\t\t\t\telse {out += Analyzer.noData(\"txt\")} //No value defined here\n\t\t\t\t\tout += \"\\t\"; //In all cases, insert a gap to keep the alignment\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn out;\n\t}\n}","//*******************************************************************************\n// REPORT_CONTROLS object - A report object to display and navigate controls data\n//*******************************************************************************\nclass Report_Controls extends Report {\n\tconstructor(o) {\n\t\tsuper(o);\n\t\tlet source = window.opener.zFactor;\n\t\t[source.Controls.N, source.Controls.P].forEach(function(control) { //Mark all controls as selected\n\t\t\tcontrol.forEach(function(c) {c.Selected = true});\n\t\t});\n\t\tlet controlHTML = \"\";\n\t\tcontrolHTML += \"<div id=\\\"PleaseWait\\\" style=\\\"display: none\\\"><span class=\\\"Warning\\\">Computing, please wait...</span><p class=\\\"Note\\\">Table interaction is disabled while computing</p></div>\";\n\t\tcontrolHTML += \"<div id=\\\"PairNeeded\\\" style=\\\"display: none\\\"><p class=\\\"Warning\\\">Select at least one Positive and one Negative control to continue!</p></div>\";\n\t\tcontrolHTML += \"<div id=\\\"SelectMenu\\\">\";\n\t\tcontrolHTML += \"<fieldset style=\\\"margin-bottom: 10px\\\"><legend>Positive</legend><div id=\\\"Ctrl_Pos\\\"></div></fieldset>\";\n\t\tcontrolHTML += \"<fieldset style=\\\"margin-bottom: 10px\\\"><legend>Negative</legend><div id=\\\"Ctrl_Neg\\\"></div></fieldset>\";\n\t\tcontrolHTML += \"</div>\";\n\t\tthis.Menu.addTabs([\n\t\t\t{Label: \"Controls\", SetActive: true, Content: {Type: \"HTML\", Value: controlHTML} },\n\t\t]);\n\t\tthis.UI.DataView = {Selected: \"Column\", init: function() {return}}; //Simple mimic to replace the control\n\t\tthis.UI.P = new RespTable({ID: \"Ctrl_Pos\", Fields: [\"Name\"], RowNumbers: true, Multiple: true, NoControls: true, Array: source.Controls.P, onSelect: function() {\n\t\t\tthis.Changed = true;\n\t\t\tthis.compute();\n\t\t}.bind(this)});\n\t\tthis.UI.N = new RespTable({ID: \"Ctrl_Neg\", Fields: [\"Name\"], RowNumbers: true, Multiple: true, NoControls: true, Array: source.Controls.N, onSelect: function() {\n\t\t\tthis.Changed = true;\n\t\t\tthis.compute();\n\t\t}.bind(this)});\n\t\tlet b = LinkCtrl.button({Label: \"Compute all Plates\", Title: \"Click here to compute the Z-factor/Window summaries for all plates\", Click: function() {\n\t\t\tthis.zScoreAllPlates();\n\t\t}.bind(this)});\n\t\tGetId(this.Anchors.PlateDoAll).append(b);\n\t\t//********************\n\t\t//How likely are we to have more than 4~6 controls in total? So this might not be needed...\n\t\t//********************\n\t\t/*let b_pos = LinkCtrl.buttonBar([\n\t\t\t{Label: \"Unselect all\", Title: \"Click here to unselect all positive controls\", Click: function() {this.UI.P.setValue([]); this.computeZFactor()}.bind(this)},\n\t\t\t{Label: \"Select all\", Title: \"Click here to select all positive controls\", Click: function() {this.UI.P.selectAll(); this.computeZFactor()}.bind(this)},\n\t\t]);\n\t\tGetId(\"Ctrl_Pos\").parentElement.prepend(b_pos);\n\t\tlet b_neg = LinkCtrl.buttonBar([\n\t\t\t{Label: \"Unselect all\", Title: \"Click here to unselect all negative controls\", Click: function() {this.UI.N.setValue([]); this.computeZFactor()}.bind(this)},\n\t\t\t{Label: \"Select all\", Title: \"Click here to select all negative controls\", Click: function() {this.UI.N.selectAll(); this.computeZFactor()}.bind(this)},\n\t\t]);\n\t\tGetId(\"Ctrl_Neg\").parentElement.prepend(b_neg);*/\n\t\t//\n\t\t//\n\t\t//\n\t\tthis.ColumnOnly = true;\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic combinationName(n, p) { //For the combination of negative and positive control object given, return the combination name as a string\n\t\treturn \"[\" + p.Name + \"] vs [\" + n.Name + \"]\";\n\t}\n\t//Getter, Setter\n\tget HasChanged() { //This getter check whether the data selected have changed compared to last time it was logged\n\t\treturn this.Changed;\n\t}\n\t//Methods\n\tdo() {\n\t\tthis.compute();\n\t\treturn this;\n\t}\n\tlockMenu() { //Lock the menu tables\n\t\tthis.UI.N.lock(); //Lock the tables to prevent spamming\n\t\tthis.UI.P.lock();\n\t\tGetId(\"PleaseWait\").style.display = \"block\";\n\t\tGetId(\"PairNeeded\").style.display = \"none\";\n\t\tGetId(\"SelectMenu\").style.display = \"none\"; //Also hide the menu. Never too safe...\n\t\treturn this;\n\t}\n\tunlockMenu() { //Unlock the menu tables\n\t\tthis.UI.N.unlock();\n\t\tthis.UI.P.unlock();\n\t\tthis.Changed = false; //Reset this state for next run of compute\n\t\tGetId(\"PleaseWait\").style.display = \"none\";\n\t\tGetId(\"SelectMenu\").style.display = \"block\";\n\t\treturn this;\n\t}\n\tpairNeeded() { //Indicates that at least a pair of Neg/Pos control is needed to continue\n\t\tGetId(\"PairNeeded\").style.display = \"block\";\n\t\tthis.unlockMenu();\n\t\treturn this;\n\t}\n\tgetControlValues(selectedPlate) { //Retrieve the values for all controls and parameters, for the selected plate\n\t\t[this.UI.N.Selected, this.UI.P.Selected].forEach(function(control) { //For each of the selected negative and positive control\n\t\t\tcontrol.forEach(function(c) { //For each control\n\t\t\t\tc.Values = []; //Reset value arrays to accept new values\n\t\t\t});\n\t\t});\n\t\tlet resultIndex = this.Results.SelectedIndices[0] + 1; //The index of the result file selected (1-based), unique\n\t\tlet o = {Items: 0, Neg: this.UI.N.Selected, Pos: this.UI.P.Selected, Params: []} //Output object containing the data for one plate\n\t\tthis.Params.forEach(function(p, i) { //Initialize empty array to receive the values for each selected parameters that is set as numeric\n\t\t\tif(p.Selected && p.Numeric) { //This parameter is selected and numeric type, continue\n\t\t\t\to.Params.push({Index: i, Name: p.Name, ResultIndex: resultIndex}); //Ensure unicity of parameter names, even accross multiple results\n\t\t\t\t[o.Neg, o.Pos].forEach(function(control) { //For each of the negative and positive control arrays\n\t\t\t\t\tcontrol.forEach(function(c) { //For each control\n\t\t\t\t\t\tc.Values.push([]); //Create empty arrays to receive the values\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\t\tthis.waitMessage(o.Params); //This displays waiting message\n\t\tlet custom = function(well, plate, row, output, parser) { //The function to run on each line\n\t\t\tif(plate == selectedPlate) { //We are on the right plate\n\t\t\t\tlet wellIndex = well.Index;\n\t\t\t\t[output.Neg, output.Pos].forEach(function(control) { //For each of the negative and positive controls\n\t\t\t\t\tcontrol.forEach(function(c) { //Check for each control\n\t\t\t\t\t\tif(c.Tags.includes(wellIndex)) { //This control is tagged on this well\n\t\t\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\n\t\t\t\t\t\t\t\tlet v = row[param.Index];\n\t\t\t\t\t\t\t\tif(v == \"\") {c.Values[i].push(\"\")} //Number(\"\") returns 0\n\t\t\t\t\t\t\t\telse {c.Values[i].push(Number(v))}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: custom}, o).then(function(data) {\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t}.bind(this));\n\t}\n\tcompute() { //Compute the z-factor for selected items\n\t\tthis.lockMenu(); //Block interaction with the menu tables\n\t\tlet neg = this.UI.N.Selected[0];\n\t\tlet pos = this.UI.P.Selected[0];\n\t\tif(neg === undefined || pos === undefined) {return this.pairNeeded()} //Need at least one pair of control to do something\n\t\tlet plate = this.SelectedPlate;\n\t\tthis.getControlValues(plate).then(function(data) { //Collect values for this plate\n\t\t\tdata.Params.forEach(function(param, i) { //Process all parameters\n\t\t\t\tthis.valueTable(data, i, param);\n\t\t\t\tlet JSONarray = this.processZscore(data, i, param);\n\t\t\t\tif(this.Result.PlatesID.length > 1) { //If there are more than one plate attached to this result, then also create/update the Plate summary table\n\t\t\t\t\tthis.plateSummary(data, i, param, plate, JSONarray);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tthis.update(); //Update the sections\n\t\t\tthis.unlockMenu();\n\t\t}.bind(this));\n\t}\n\tvalueTable(data, valueIndex, param) { //Create the table holding values for all controls, using values for the parameter at the index given\n\t\tlet groups = [];\n\t\t[data.Neg, data.Pos].forEach(function(controls) { //Process all the controls\n\t\t\tcontrols.forEach(function(c) {\n\t\t\t\tgroups.push({Name: c.Name, DataPoints: [c.Values[valueIndex]]});\n\t\t\t});\n\t\t});\n\t\tlet json = { //Build the json for this section\n\t\t\tData: [{ //Only one object in this array\n\t\t\t\tGroups:\tgroups,\n\t\t\t\tSubGroups: [],\n\t\t\t}],\n\t\t\tHeaders: {\n\t\t\t\tCols: [\n\t\t\t\t\t{Name: \"Negative Controls\", Span: data.Neg.length},\n\t\t\t\t\t{Name: \"Positive Controls\", Span: data.Pos.length},\n\t\t\t\t]\n\t\t\t},\n\t\t\tStatRows: true,\n\t\t}\n\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Values\", {Type: \"Single\"});\n\t\tsection.Data = JSON.stringify(json);\n\t\treturn this;\n\t}\n\tprocessZscore(data, valueIndex, param) { //Process the stats for each controls in order to compute the z-factors\n\t\tlet subgroups = [];\n\t\tlet groupsZ = [];\n\t\tlet groupsW = [];\n\t\tdata.Neg.forEach(function(n, i) { //Process all the Negative controls as rows\n\t\t\tdata.Pos.forEach(function(p, j) { //Process all the positive controls as cols\n\t\t\t\tlet N = Coordinate.statValue(n.Values[valueIndex]); //Compute the stats\n\t\t\t\tlet P = Coordinate.statValue(p.Values[valueIndex]);\n\t\t\t\tlet Z = this.zScoreFromStats(N, P);\n\t\t\t\tlet W = this.windowFromStats(N, P);\n\t\t\t\tif(i == 0) { //This is the first row, create the object\n\t\t\t\t\tgroupsZ.push({Name: p.Name, DataPoints: [ [Z] ]}); //Add the calculated stats\n\t\t\t\t\tgroupsW.push({Name: p.Name, DataPoints: [ [W] ]});\n\t\t\t\t}\n\t\t\t\telse { //For following rows, push into the Datapoints array\n\t\t\t\t\tgroupsZ[j].DataPoints.push([Z]);\n\t\t\t\t\tgroupsW[j].DataPoints.push([W]);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tsubgroups.push({Name: n.Name, DataPoints: []}); //Rows will not need datapoints as their are all in the column\n\t\t}, this);\n\t\tlet jsonZ = { //Build the json for this stat\n\t\t\tData: [{\n\t\t\t\tGroups: groupsZ,\n\t\t\t\tSubGroups: subgroups,\n\t\t\t}],\n\t\t\tTitle: \"Z'\"\n\t\t};\n\t\tlet jsonW = { //Build the json for this stat\n\t\t\tData: [{\n\t\t\t\tGroups: groupsW,\n\t\t\t\tSubGroups: subgroups,\n\t\t\t}],\n\t\t\tTitle: \"Window\"\n\t\t};\n\t\t[jsonZ, jsonW].forEach(function (j) {\n\t\t\tj.Headers = {\n\t\t\t\tCols: [{Name: \"Positive Controls\", Span: data.Pos.length}],\n\t\t\t\tRows: [{Name: \"Negative Controls\", Span: data.Neg.length}],\n\t\t\t};\n\t\t});\n\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Performance indicators\", {Type: \"Multiple\", JSON: [jsonZ, jsonW]});\n\t\treturn [jsonZ, jsonW];\n\t}\n\tzScoreFromStats(neg, pos) { //Compute the z score from the stats calculated from the +/- controls\n\t\tlet z = 1 - 3 * ((pos.SD + neg.SD) / Math.abs(pos.Average - neg.Average));\n\t\treturn {Class: this.classForZ(z), Value: z};\n\t}\n\twindowFromStats(neg, pos) { //Compute the window from the stats calculated from the +/- controls\n\t\tlet n = neg.Average;\n\t\tlet p = pos.Average;\n\t\tlet w = Math.max(n, p) / Math.min(n, p); //Window\n\t\treturn {Class: this.classForW(w), Value: w}\n\t}\n\tclassForW(w) { //Return the appropriate class for the window value\n\t\tif(w > 2) {return \"good\"}\n\t\tif(w > 1) {return \"neutral\"}\n\t\treturn \"bad\";\n\t}\n\tclassForZ(z) { //Return the appropriate class for the z value\n\t\tif(z > 0.4) {return \"good\"}\n\t\tif(z > 0.2) {return \"neutral\"}\n\t\treturn \"bad\";\n\t}\n\tplateSummary(data, valueIndex, param, plate, scores) { //Update the plate summary by adding a row for the plate in each relevant table\n\t\tlet jsonArray = []; //Each table will be represented by a distinct JSON\n\t\tdata.Neg.forEach(function(p, i) {\n\t\t\tdata.Pos.forEach(function(n, j) {\n\t\t\t\tlet comb = Report_Controls.combinationName(n, p); //Name for the combination\n\t\t\t\tlet Z = scores[0].Data[0].Groups[j].DataPoints[i]; //Retrieve the stats\n\t\t\t\tlet W = scores[1].Data[0].Groups[j].DataPoints[i];\n\t\t\t\tlet json = {\n\t\t\t\t\tData: [{\n\t\t\t\t\t\tGroups: [\n\t\t\t\t\t\t\t{Name: \"Plate\", DataPoints: [ [plate] ]},\n\t\t\t\t\t\t\t{Name: \"Z'\", DataPoints: [Z]}, //Z and W are already arrays\n\t\t\t\t\t\t\t{Name: \"W\", DataPoints: [W]},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tSubGroups: [] //This array must be present, but remains empty (pure column table)\n\t\t\t\t\t}],\n\t\t\t\t\tTitle: comb,\n\t\t\t\t\tSyncScrolling: true,\n\t\t\t\t\tStatRows: true\n\t\t\t\t};\n\t\t\t\tjsonArray.push(json); //Push the newly build json\n\t\t\t}, this);\n\t\t}, this);\n\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Plate Summary\", {Type: \"Multiple\", JSON: jsonArray, Summary: true, Changed: this.HasChanged});\n\t\tsection.addRow({Data: jsonArray}, plate);\n\t}\n\tasync zScoreAllPlates() { //Compute zScore for all available plates. Use a counter and a yielding loop to process the plates sequentially and prevent memory overflow\n\t\tthis.Cancel = false;\n\t\tthis.lockMenu(); //Block interaction with the menu tables\n\t\tlet neg = this.UI.N.Selected[0];\n\t\tlet pos = this.UI.P.Selected[0];\n\t\tif(neg === undefined || pos === undefined) {return this.pairNeeded()} //Need at least one pair of control to do something\n\t\tlet plates = this.Result.PlatesID;\n\t\tReport.lock(this, plates.length); //Lock the report and start\n\t\tlet plateCounter = Report.plateIterator(plates); //A generator to loop over the plates\n\t\tlet current = plateCounter.next();\n\t\tlet running = 0;\n\t\twhile(current.done == false && this.Cancel == false) { //Do this until the plate counter is exhausted or the user cancel the action\n\t\t\tlet currentPlate = current.value.toString(); //Current plate to analyze. Should always be used as a text, force it here for generic index\n\t\t\tif(Report.hasData(this, currentPlate) == false) { //There is no need to parse if the plate has already been computed\n\t\t\t\tlet data = await this.getControlValues(currentPlate); //Parse data\n\t\t\t\tdata.Params.forEach(function(param, i) {\n\t\t\t\t\tthis.valueTable(data, i, param);\n\t\t\t\t\tlet JSONarray = this.processZscore(data, i, param);\n\t\t\t\t\tthis.plateSummary(data, i, param, currentPlate, JSONarray);\n\t\t\t\t}, this);\n\t\t\t\tthis.update(); //Update the sections\n\t\t\t}\n\t\t\tthis.UI.Plate.setValue(running); //Ensures that the control is set at the same value as the last computed plate\n\t\t\tthis.pairStatus(running); //Also adjust the pairing info\n\t\t\tcurrent = plateCounter.next();\n\t\t\trunning++;\n\t\t\tReport.plateCount(running + 1);\n\t\t}\n\t\tthis.unlockMenu();\n\t\tReport.unlock();\n\t\treturn this;\n\t}\n}","//************************************************************************************************************************************\n// REPORT_GROUPED object - A report object to display and navigate results from aggregated areas and concentrations, as 2-entry tables\n//************************************************************************************************************************************\nclass Report_Grouped extends Report {\n\tconstructor(o, I) {\n\t\tsuper(o, I);\n\t\tlet source = window.opener.Grouped;\n\t\tthis.RootID = \"Form_AddData\";\n\t\tthis.AvailableID = this.RootID + \"_Available\";\n\t\tthis.SelectedID = this.RootID + \"_Selected\";\n\t\tthis.ColumnOnly = I.ColumnOnly;\n\t\tthis.Areas = source.Areas.map(function(a, i) { //Slightly update the incoming objects with additional properties\n\t\t\ta.Available = true; //Mark all items as available\n\t\t\ta.Category = \"Areas\"; //Add some properties to facilitate interaction during the drag-and-drop operations\n\t\t\ta.OriginID = this.AvailableID + \"_Areas\";\n\t\t\ta.OriginIndex = i;\n\t\t\ta.Values = [{Name: a.Name, Value: a.Name, Tags: a.Tags}];\n\t\t\treturn a;\n\t\t}, this); \n\t\tthis.Ranges = source.Ranges.map(function(r, i) {\n\t\t\tr.Available = true;\n\t\t\tr.Category = \"Ranges\";\n\t\t\tr.OriginID = this.AvailableID + \"_Ranges\";\n\t\t\tr.OriginIndex = i;\n\t\t\treturn r;\n\t\t}, this);\n\t\tthis.Concentrations = source.Conc.map(function(c, i) {\n\t\t\tc.Available = true;\n\t\t\tc.Category = \"Concentrations\";\n\t\t\tc.OriginID = this.AvailableID + \"_Concentrations\";\n\t\t\tc.OriginIndex = i;\n\t\t\treturn c;\n\t\t}, this);\n\t\tthis.Menu.addTabs([ //Prepare the menu\n\t\t\t{Label: \"Data\", SetActive: true,\n\t\t\t\tContent: {\n\t\t\t\t\tType: \"HTML\",\n\t\t\t\t\tValue: \"<div id=\\\"Report_Ready\\\"><span class=\\\"Warning\\\">Resolving definitions, please wait...</span></div>\" +\n\t\t\t\t\t\t\"<div id=\\\"Report_Alert\\\" class=\\\"Warning\\\"></div>\" +\n\t\t\t\t\t\t\"<fieldset id=\\\"AddRowCol\\\"><div id=\\\"Data_Options\\\"></div></fieldset>\",\n\t\t\t\t}\n\t\t\t},\n\t\t]);\n\t\tthis.UI.Selected = { //Object to hold the selected data\n\t\t\tinit: function() {}, //dummy function to allow this object to pass the initialization step without error\n\t\t\tRows: [[], []],\n\t\t\tCols: [[], []],\n\t\t};\n\t\tif(this.ColumnOnly) { //Column Mode: use only the column aggregation\n\t\t\tthis.UI.DataView = LinkCtrl.new(\"Select\", {ID: \"Data_Options\", Default: 0, Label: \"Aggregation\", List: [\"Column\"], Preserve: true,\n\t\t\t\tTitle: \"Multiple values will be displayed arrayed in a single column\"\n\t\t\t});\n\t\t\tlet b = LinkCtrl.button({Label: \"Compute all Plates\", Title: \"Click here to compute the statistical summaries for all plates\", Click: function() {this.statsAllPlates()}.bind(this)});\n\t\t\tGetId(this.Anchors.PlateDoAll).append(b);\n\t\t}\n\t\telse { //Grouped cases, more flexible\n\t\t\tthis.UI.DataView = LinkCtrl.new(\"Select\", {ID: \"Data_Options\", Default: 0, Label: \"Aggregation\", List: [\"Avg, SD, N\", \"Average\", \"Column\", \"Row\"], Preserve: true, Change: this.update.bind(this),\n\t\t\t\tTitle: \"Indicates how multiple values are displayed in the grouped table: arrayed in a single column or in consecutive rows; show only the average; show the average, standard deviation and number of samples\"\n\t\t\t});\n\t\t}\n\t\tlet buttons = LinkCtrl.buttonBar([\n\t\t\t{Label: \"Select Data\", Title: \"Click here to add rows and columns of data to the summary table\", Click: function() {this.addData()}.bind(this)},\n\t\t]);\n\t\tGetId(\"AddRowCol\").prepend(buttons);\n\t\tthis.prepareDefinition();\n\t\tReport_Grouped.msg_welcome(); //Welcome message\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic info() {\n\t\treturn \"<p class=\\\"Note\\\">Click on the 'Select Data' button located in the 'Data' panel (left menu) to add rows and columns of data</p>\";\n\t}\n\tstatic msg_welcome() { //Display the welcome message in the output\n\t\tGetId(\"Output\").innerHTML = this.info();\n\t}\n\tstatic msg_pleaseWait() {\n\t\tGetId(\"Report_Alert\").innerHTML = \"<p class=\\\"Error\\\">Please Wait until the Range data are fully resolved!<p>\";\n\t}\n\tstatic msg_noCol() {\n\t\tGetId(\"Report_Alert\").innerHTML = \"<p class=\\\"Error\\\">Please Select at least one column of data!<p>\";\n\t}\n\tstatic msg_clear() {\n\t\tGetId(\"Report_Alert\").innerHTML = \"\";\n\t}\n\tstatic dragStart(e, I) { //Start dragging the data\n\t\te.dataTransfer.setData(\"text/plain\", e.target.id);\n\t\tthis.Moving = {Item: Analyzer.Report[I.Category][I.OriginIndex], Origin: I.OriginID} //Log the object corresponding to the item moved;\n\t}\n\tstatic dragOver(e) { //Drag over the dropZone\n\t\te.preventDefault();\n\t}\n\tstatic dragEnter(e) { //Entering the drop zone\n\t\te.preventDefault();\n\t\tlet t = e.target;\n\t\tif(t.classList.contains(\"Droppable\") == false) {t = t.parentElement} //If the drop targets an element within the dropzone, go back one level\n\t\tlet active = document.getElementsByClassName(\"Droppable Droppable_Hover\"); //When the drag is done too rapidly, the dragenter event may fire twice, and the leave fires later for the 1st element\n\t\tlet l = active.length; //Here we check for elements already having the class\n\t\tif(l>0) { //If some elements already have the class, stripped them from it\n\t\t\tfor(let i=0;i<l;i++) {active[i].className = \"Droppable\"}\n\t\t}\n\t\tt.className = \"Droppable Droppable_Hover\"; //Change the class\n\t}\n\tstatic dragLeave(e) { //Leaving the drop zone\n\t\te.preventDefault();\n\t\tlet t = e.target; //The element that we are leaving\n\t\tif(t.classList.contains(\"Droppable\") == false) {t = t.parentElement} //If the leave targets an element within the dropzone, go back one level\n\t\tlet r = e.relatedTarget; //For a dragleave event, this points to the element the pointing device entered to\n\t\tif(t.classList.contains(\"Droppable_Hover\") == true && r.classList.contains(\"SmallTitle\") == false && r.classList.contains(\"Selectable_Row\") == false && r.classList.contains(\"Droppable_Hover\") == false) { //Should trigger when leaving an active dropzone, without entering an element within a dropzone, or the same active dropzone itself\n\t\t\tt.className = \"Droppable\"; //Remove the class\n\t\t}\n\t}\n\tstatic drop(e, I) { //Drop on the dropZone\n\t\te.preventDefault();\n\t\tif(this.Moving === undefined) {return} //Something wrong\n\t\tlet source = GetId(e.dataTransfer.getData(\"text/plain\"));\n\t\tsource.remove(); //Remove the element from the menu\n\t\tthis.Moving.Item.Available = false; //Log the object as unavailable\n\t\tthis.Moving.Item.NewDrop = I; //Log the dropzone of this element\n\t\tthis.Moving = undefined; //Release the log\n\t\tAnalyzer.Report.updateSelectedData({Action: \"Drop\"}); //This will redraw the drop table based on the action performed\n\t}\n\tstatic dropDelete(e) { //Drop on the delete dropZone\n\t\te.preventDefault();\n\t\tif(this.Moving === undefined) {return} //Something wrong\n\t\tthis.Moving.Item.Available = true; //Make it available again\n\t\tthis.Moving.Item.NewDrop = {Type: \"Removed\"}; //Release the drop location\n\t\tlet source = GetId(e.dataTransfer.getData(\"text/plain\"));\n\t\tGetId(this.Moving.Origin).appendChild(source); //Move source back to the main menu\n\t\tthis.Moving = undefined; //Release the log\n\t\tAnalyzer.Report.updateSelectedData({Action: \"Drop\"}); //This will redraw the drop table based on the action performed\n\t}\n\t//Getter, Setter\n\tget HasChanged() { //This getter check whether the data selected have changed compared to last time it was logged\n\t\tlet change = true;\n\t\tlet string = JSON.stringify(this.UI.Selected, [\"Rows\", \"Cols\", \"Name\"]); //Compare the object equality as a string. Keep only essential properties to make it easier\n\t\tif(this.Selection == string) {change = false} //Has not changed\n\t\tthis.Selection = string;\n\t\treturn change;\n\t}\n\t//Methods\n\tdo() {\n\t\tif(this.Ready) { //Names were already resolved, proceed\n\t\t\tthis.compute();\n\t\t}\n\t\telse { //First resolve the names\n\t\t\tthis.resolveAllNames().then(function() { //Start by recovering all definitions names\n\t\t\t\tthis.Ready = true;\n\t\t\t\tGetId(\"Report_Ready\").remove();\n\t\t\t}.bind(this));\n\t\t}\n\t\treturn this;\n\t}\n\taddData() { //Addition of rows/cols into the data tables\n\t\tlet id = this.RootID;\n\t\tlet selected = this.SelectedID;\n\t\tlet available = this.AvailableID;\n\t\tlet availableMenu = new TabControl({\n\t\t\tID: this.AvailableID,\n\t\t\tLayout: \"Menu\",\n\t\t\tTabs: [\n\t\t\t\t{Label: \"Areas\", Active: true, Content: {Type: \"HTML\", Value: this.available(\"Areas\", available)} },\n\t\t\t\t{Label: \"Ranges\", Content: {Type: \"HTML\", Value: this.available(\"Ranges\", available)} },\n\t\t\t\t{Label: \"Concentrations\", Content: {Type: \"HTML\", Value: this.available(\"Concentrations\", available)} },\n\t\t\t]\n\t\t});\n\t\tlet html = \"\";\n\t\thtml += \"<fieldset style=\\\"width:350px; overflow: auto; float: left\\\"><legend>Data available</legend><p class=\\\"Note\\\">Drag and drop the data from here to the table on the right panel</p><div id=\\\"\" + available + \"\\\"></div></fieldset>\";\n\t\thtml += \"<fieldset style=\\\"margin-left: 400px;\\\"><legend>Selected</legend><div id=\\\"\" + selected + \"\\\"></div></fieldset>\";\n\t\tForm.open({\n\t\t\tID: this.RootID,\n\t\t\tSize: 900,\n\t\t\tTitle: \"Add Data\",\n\t\t\tHTML: html,\n\t\t\tButtons: [\n\t\t\t\t{Label: \"Ok\", Click: function() {\n\t\t\t\t\tthis.updateSelectedData({Action: \"Ok\"});\n\t\t\t\t\tForm.close(id);\n\t\t\t\t}.bind(this)},\n\t\t\t\t{Label: \"Cancel\", Click: function() {\n\t\t\t\t\tthis.updateSelectedData({Action: \"Cancel\"}); //Cancel flag\n\t\t\t\t\tForm.close(id);\n\t\t\t\t}.bind(this)}\n\t\t\t],\n\t\t\tonInit: function() {\n\t\t\t\tavailableMenu.init();\n\t\t\t\tGetId(selected).innerHTML = this.selected();\n\t\t\t}.bind(this),\n\t\t\tonCancel: function() {\n\t\t\t\tthis.updateSelectedData({Action: \"Cancel\"}); //Cancel flag\n\t\t\t}.bind(this),\n\t\t});\n\t}\n\thtmlForItem(item) { //Prepare an html string to represent the item passed, as a draggable element\n\t\tlet html = \"\";\n\t\tlet toDisplay = item.Name;\n\t\tif(item.Unit) {toDisplay = item.Unit + \" (\" + item.Values.length + \" values)\"}\n\t\tif(item.Type == \"Range\") {toDisplay += \" (\" + item.Values.length + \" items)\"}\n\t\thtml += \"<div id=\\\"\" + item.OriginID + \"_\" + item.OriginIndex + \"\\\" draggable=\\\"true\\\" ondragstart=\\\"Report_Grouped.dragStart(event, {Category: '\" + item.Category + \"', OriginID: '\" + item.OriginID + \"', OriginIndex: '\" + item.OriginIndex + \"'})\\\" class=\\\"Selectable_Row\\\"\";\n\t\thtml += \">\" + toDisplay + \"</div>\";\n\t\treturn html;\n\t}\n\tavailable(category, sourceID) { //Create an html list of the items available for the desired category\n\t\tlet id = sourceID + \"_\" + category;\n\t\tlet html = \"<div id=\\\"\" + id + \"\\\" style=\\\"border-top: 1px solid silver\\\">\";\n\t\tlet source = this[category];\n\t\tsource.forEach(function(s) {\n\t\t\tif(s.Available) {html += this.htmlForItem(s)}\n\t\t}, this);\n\t\thtml += \"</div>\";\n\t\treturn html;\n\t}\n\tselected(I) { //Create the html of the drop zone for draggable items populated with the previously logged selection (UI.Selected) or from the selection object passed\n\t\tlet log = I; //Use the incoming object...\n\t\tif(I === undefined) {log = this.UI.Selected} //... Or the logged selection if not available\n\t\tlet html = \"<table>\";\n\t\thtml += \"<tr> <td style=\\\"width: 1.1em\\\"></td> <td></td> <td style=\\\"text-align: center\\\"><div style=\\width: 194px;\\\"><b>Columns</b></div>\"; //First row start\n\t\thtml += \"<div class=\\\"Droppable\\\" ondrop=\\\"Report_Grouped.drop(event, {Type: 'Cols', Level: 2})\\\" ondragover=\\\"Report_Grouped.dragOver(event)\\\" ondragenter=\\\"Report_Grouped.dragEnter(event)\\\" ondragleave=\\\"Report_Grouped.dragLeave(event)\\\" style=\\\" \"; //Level 2 Col drop\n\t\tif(log.Cols[0].length == 0) {html += \" display: none;\"} //Hide the level 2 if nothing present in level 1\n\t\tif(this.ColumnOnly) {html += \" float: none;\"} //Remove the float to keep the two levels on top of each others\n\t\thtml += \"\\\"><p class=\\\"SmallTitle\\\" style=\\\"color: darkred\\\">Level 2</p>\"; \n\t\tlog.Cols[1].forEach(function(item) {html += this.htmlForItem(item)}, this); //Add the items that were logged at this location\n\t\thtml += \"</div>\";\n\t\thtml += \"<div class=\\\"Droppable\\\" ondrop=\\\"Report_Grouped.drop(event, {Type: 'Cols', Level: 1})\\\" ondragover=\\\"Report_Grouped.dragOver(event)\\\" ondragenter=\\\"Report_Grouped.dragEnter(event)\\\" ondragleave=\\\"Report_Grouped.dragLeave(event)\\\"\"; //Level 1 Col drop\n\t\thtml+= \"style=\\\" \\\"><p class=\\\"SmallTitle\\\" style=\\\"color: blue\\\">Level 1</p>\"; \n\t\tlog.Cols[0].forEach(function(item) {html += this.htmlForItem(item)}, this); //Add the items that were logged at this location\n\t\thtml += \"</div>\";\n\t\thtml += \"</td> </tr>\"; //End Second Row\n\t\thtml += \"<tr>\"; //Start Second Row\n\t\tif(this.ColumnOnly) {html += \"<td></td> <td>\"} //Leave two blocks empty for column-only mode\n\t\telse {\n\t\t\thtml += \"<td style=\\\"writing-mode: sideways-lr; width: 1.1em;\\\"><b>Rows</b></div></td><td>\"; //Row legend\n\t\t\thtml += \"<div class=\\\"Droppable\\\" ondrop=\\\"Report_Grouped.drop(event, {Type: 'Rows', Level: 2})\\\" ondragover=\\\"Report_Grouped.dragOver(event)\\\" ondragenter=\\\"Report_Grouped.dragEnter(event)\\\" ondragleave=\\\"Report_Grouped.dragLeave(event)\\\" style=\\\" \"; //Level 2 Row drop\n\t\t\tif(log.Rows[0].length == 0) {html += \" display: none\"} //Hide the level 2 if nothing present in level 1\n\t\t\thtml += \"\\\"><p class=\\\"SmallTitle\\\" style=\\\"color: darkred\\\">Level 2</p>\";\n\t\t\tlog.Rows[1].forEach(function(item) {html += this.htmlForItem(item)}, this); //Add the items that were logged at this location\n\t\t\thtml += \"</div>\";\n\t\t\thtml += \"<div class=\\\"Droppable\\\" ondrop=\\\"Report_Grouped.drop(event, {Type: 'Rows', Level: 1})\\\" ondragover=\\\"Report_Grouped.dragOver(event)\\\" ondragenter=\\\"Report_Grouped.dragEnter(event)\\\" ondragleave=\\\"Report_Grouped.dragLeave(event)\\\"\"; //Level 1 Row drop\n\t\t\thtml += \"style=\\\" \\\"><p class=\\\"SmallTitle\\\" style=\\\"color: blue\\\">Level 1</p>\"; \n\t\t\tlog.Rows[0].forEach(function(item) {html += this.htmlForItem(item)}, this); //Add the items that were logged at this location\n\t\t\thtml += \"</div>\";\n\t\t}\n\t\thtml += \"</td><td ondrop=\\\"Report_Grouped.dropDelete(event)\\\" ondragover=\\\"Report_Grouped.dragOver(event)\\\" style=\\\"text-align: center\\\">\";\n\t\thtml += \"<div class=\\\"LinkCtrl_Icon LinkCtrl_IconBig\\\" style=\\\"background-position: -200px 0px; opacity: 20%\\\"></div>\"; //Trash bin icon\n\t\thtml += \"<p class=\\\"Note\\\" >Drop here to remove</p></td> </tr>\"; //Last cell //style=\\\"text-align: center\\\"\n\t\thtml += \"</table>\";\n\t\treturn html;\n\t}\n\tupdateSelectedData(I) { //Update the UI.Selected object based on the Drop property of the Areas/Ranges/Concentrations object\n\t\tif(I === undefined) {return}\n\t\tlet source = [this.Areas, this.Ranges, this.Concentrations]; //Need to process all three\n\t\tlet selected = {Rows: [[], []], Cols: [[], []]}; //Initialize empty object for logging\n\t\tif(I.Action == \"Cancel\") { //In this case, ignore the changes: NewDrop properties are deleted and previous Drop don't change\n\t\t\tsource.forEach(function(cat) { //For each category\n\t\t\t\tcat.forEach(function(item) { //For each item in a category\n\t\t\t\t\titem.NewDrop = undefined; //Ignore modifications made\n\t\t\t\t\tif(item.Drop !== undefined) {item.Available = false} //Update the status, should remain available only if it has no drop defined\n\t\t\t\t\telse {item.Available = true}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif(I.Action == \"Ok\") { //Ok scenario, valid the changes by switching the NewDrop as Drop and rebuild the UI.Selected object\n\t\t\tsource.forEach(function(cat) { //For each category\n\t\t\t\tcat.forEach(function(item) { //For each item in a category\n\t\t\t\t\tif(item.NewDrop !== undefined) { //Items that were moved need update\n\t\t\t\t\t\tif(item.NewDrop.Type == \"Removed\") { //In this case, the drop should be destroyed\n\t\t\t\t\t\t\titem.Drop = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { //Otherwise proceed normally\n\t\t\t\t\t\t\titem.Drop = item.NewDrop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.NewDrop = undefined; //Reset the change\n\t\t\t\t\t}\n\t\t\t\t\tif(item.Drop !== undefined) { //If a Drop location remains here, log it at the rignt location\n\t\t\t\t\t\tselected[item.Drop.Type][(item.Drop.Level-1)].push(item);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis.UI.Selected = selected; //Update the Selected object\n\t\t\tthis.compute(); //Compute the tables\n\t\t}\n\t\tif(I.Action == \"Drop\") { //A new drop occured: prepare an updated selected object, clean it and use it to prepare the updated drop table\n\t\t\tsource.forEach(function(cat) { //For each category\n\t\t\t\tcat.forEach(function(item) { //For each item in a category\n\t\t\t\t\tif(item.NewDrop !== undefined && item.NewDrop.Type != \"Removed\") { //Item was moved, but not to the trashbin, log it at its new location\n\t\t\t\t\t\tselected[item.NewDrop.Type][(item.NewDrop.Level-1)].push(item);\n\t\t\t\t\t}\n\t\t\t\t\telse { //For other items, use their Drop location if they are not labelled as removed\n\t\t\t\t\t\tif(item.Drop !== undefined && (item.NewDrop === undefined || item.NewDrop.Type != \"Removed\")) { //If a Drop location remains here, log it at the rignt location\n\t\t\t\t\t\t\tselected[item.Drop.Type][(item.Drop.Level-1)].push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tselected = this.cleanSelected(selected); //Clean the selected object\n\t\t\tGetId(this.SelectedID).innerHTML = this.selected(selected); //Redraw the droptable\n\t\t}\n\t\treturn this;\n\t}\n\tcleanSelected(I) { //Clean the selected object provided by removing any useless level 2\n\t\t[I.Rows, I.Cols].forEach(function(l) { //Process both the array of Rows and Cols\n\t\t\tif(l[0].length == 0) { //If the first level is empty, check that the second level is empty too, or move its content back to the first level\n\t\t\t\tif(l[1].length > 0) { //There are stuff here that need to be moved\n\t\t\t\t\tl[0] = l[1]; //Move them to level 1\n\t\t\t\t\tl[0].forEach(function(item) { //Update the Drop/NewDrop location to match\n\t\t\t\t\t\tif(item.NewDrop !== undefined) {item.NewDrop.Level = 1}\n\t\t\t\t\t\tif(item.Drop !== undefined) {item.Drop.Level = 1}\n\t\t\t\t\t}); \n\t\t\t\t\tl[1] = []; //Free level 2\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn I;\n\t}\t\n\tresolveAllNames() { //Resolve the names for all the definitions available\n\t\tlet promises = [];\n\t\treturn new Promise(function(resolve) { //Return a promise that will resolve when the parsing is completed\n\t\t\tthis.Ranges.forEach(function(r, i) { //For each definition, start the fetching process\n\t\t\t\tlet d = r.Definition;\n\t\t\t\tif(d !== undefined) {\n\t\t\t\t\tpromises.push(this.resolveNames(d, i));\n\t\t\t\t}\n\t\t\t\telse {promises.push(undefined)} //Push something to maintain index synchronization with Ranges and Definitions arrays\n\t\t\t}, this);\n\t\t\tPromise.all(promises).then(function(names) { //When all the fetching is done, update the object property with the resolved names\n\t\t\t\tthis.ResolvedNames = names;\n\t\t\t\tresolve();\n\t\t\t}.bind(this));\n\t\t}.bind(this));\n\t}\n\tresolveNames(d, defIndex) { //Resolve the names for the definition passed\n\t\tlet a = d.Area;\n\t\tlet factor = a.MaxRange;\n\t\tlet args = {\n\t\t\tPlate: this.UI[\"Definition_\" + defIndex].Selected, //Name of the plate where to look the data\n\t\t\tFactor: factor, //This factor is necessary to find the data in case no well/plate mapping are available\n\t\t\tDefault: \"\", //Default fallback if the element needed is outside the list\n\t\t\tAreaName: a.Name, //To complete generic items\n\t\t\tColumn: d.Mapping[Mapper.definition().Name], //Index of the column containing the data to extract\n\t\t\tRangeIndexBase0: a.MaxRange, //Providing the maxRange ensures that the array is filled with generic items if there is not enough definitions available in the file\n\t\t\tFindAll: true,\n\t\t}\n\t\treturn new Promise(function(resolve) {\n\t\t\td.Mapper.find(d, args).then(function(array) {\n\t\t\t\tlet mode = Mapper.modeWellPlate(d.Mapping);\n\t\t\t\tswitch(mode) { //For mapping without well location, the array returned is the list of object available, can be returned as is. Otherwise, should convert the plate array to a flat array of item\n\t\t\t\t\tcase \"Plate\": //FALL-THROUGH\n\t\t\t\t\tcase \"Direct\": resolve(array); break;\n\t\t\t\t\tcase \"Well\": //FALL-THROUGH\n\t\t\t\t\tcase \"PlateWell\": \n\t\t\t\t\t\tlet items = [];\n\t\t\t\t\t\tthis.Ranges[defIndex].Values.forEach(function(v) { //Look at the individual items for this range\n\t\t\t\t\t\t\titems.push(array[v.Tags[0]]); //Get the index of the first well tagged for this rangeItem, and log its definition. We enforce here that other wells for this RangeItem share the same definition, even if this is wrong\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresolve(items);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t}.bind(this));\n\t}\n\tisReady(rows, cols) {\n\t\tif(cols[0].length == 0) {Report_Grouped.msg_noCol(); return false} //Missing column\n\t\tif(this.Ready != true) {Report_Grouped.msg_pleaseWait(); return false} //No ready\n\t\tReport_Grouped.msg_clear(); //No more message needed\n\t\treturn true;\n\t}\n\tcompute() { //Do the job\n\t\tlet rows = this.UI.Selected.Rows;\n\t\tlet cols = this.UI.Selected.Cols;\n\t\tif(this.isReady(rows, cols) == false) {return this};\n\t\tlet plate = this.SelectedPlate;\n\t\tthis.getValues(plate).then(function(data) {\n\t\t\tdata.Params.forEach(function(p, i) {\n\t\t\t\tlet section = Report.getBloc(this, Report.blocName(p)).getSection(\"Values\", {Type: \"Single\"});\n\t\t\t\tlet json = Analyzer.encodeJSON(rows, cols, data.Values[i]); //Get a JSON object as data\n\t\t\t\tsection.Data = JSON.stringify(json); //Store it as a string\n\t\t\t\tif(this.ColumnOnly && this.Result.PlatesID.length > 1) { //If there are more than one plate in the result file, also create/update the Plate summary table (only for column reports)\n\t\t\t\t//json.StatRows = true; //Activate the statistical rows at the end of the table\t\n\t\t\t\tlet summary = Report.getBloc(this, Report.blocName(p)).getSection(\"Plate Summary\", {Type: \"StatsTable\", Summary: true, JSON: json, Changed: this.HasChanged});\n\t\t\t\t\tsummary.addRow(json, plate);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tthis.update(); //Update the sections\n\t\t}.bind(this));\n\t\treturn this;\n\t}\n\tasync statsAllPlates() { //Compute data for all plates, one after the other\n\t\tlet rows = this.UI.Selected.Rows;\n\t\tlet cols = this.UI.Selected.Cols;\n\t\tif(this.isReady(rows, cols) == false) {return this};\n\t\tthis.Cancel = false;\n\t\tlet plates = this.Result.PlatesID;\n\t\tReport.lock(this, plates.length); //Lock the report and start\n\t\tlet plateCounter = Report.plateIterator(plates); //A generator to loop over the plates\n\t\tlet current = plateCounter.next();\n\t\tlet running = 0;\n\t\twhile(current.done == false && this.Cancel == false) { //Do this until the plate counter is exhausted or the user cancel the action\n\t\t\tlet currentPlate = current.value; //Current plate to analyze\n\t\t\tif(Report.hasData(this, currentPlate) == false) { //There is no need to parse if the plate has already been computed\n\t\t\t\tlet data = await this.getValues(currentPlate);\n\t\t\t\tdata.Params.forEach(function(p, i) {\n\t\t\t\t\tlet section = Report.getBloc(this, Report.blocName(p)).getSection(\"Values\", {Type: \"Single\"});\n\t\t\t\t\tlet json = Analyzer.encodeJSON(rows, cols, data.Values[i]); //Get a JSON object as data\n\t\t\t\t\tsection.Data = JSON.stringify(json); //Store it as a string\n\t\t\t\t\tlet summary = Report.getBloc(this, Report.blocName(p)).getSection(\"Plate Summary\", {Type: \"StatsTable\", Summary: true, JSON: json, Changed: false});\n\t\t\t\t\tsummary.addRow(json, currentPlate);\n\t\t\t\t}, this);\n\t\t\t\tthis.update(); //Update the sections\n\t\t\t}\n\t\t\tthis.UI.Plate.setValue(running); //Ensures that the control is set at the same value as the last computed plate\n\t\t\tthis.pairStatus(running); //Also adjust the pairing info\n\t\t\tcurrent = plateCounter.next();\n\t\t\trunning++;\n\t\t\tReport.plateCount(running + 1);\n\t\t}\n\t\tReport.unlock();\n\t\treturn this;\n\t}\n}","//*****************************************************************************************************************************************\n// REPORT_HITS object - A report object to display and navigate hits gather from all plates, given configured thresholds for the parameters\n//*****************************************************************************************************************************************\nclass Report_Hits extends Report {\n\tconstructor(o) {\n\t\tsuper(o);\n\t\tlet source = window.opener.Hits;\n\t\tthis.Layout = source.Layout;\n\t\tthis.Ranges = source.Ranges; //Array of incoming range\n\t\tthis.Controls = source.Controls.N.concat(source.Controls.P);\n\t\tthis.Controls.forEach(function(c) {c.Stats = []}); //Empty arrays to hold the value of the global average when calculated\n\t\tthis.UI.DataView = {Selected: \"Column\", init: function() {return}}; //Simple mimic to replace the control\n\t\tGetId(this.Anchors.Output).insertAdjacentHTML(\"beforebegin\", \"<fieldset><legend>Options</legend><div id=\\\"Config\\\"></div></fieldset><div id=\\\"Start\\\" style=\\\"margin: 10px\\\"></div>\");\n\t\tlet opt = { //Additional UI options\n\t\t\tThreshold: LinkCtrl.new(\"Number\", {ID: \"Start\", Default: 50, Label: \"Threshold (%)\", Chain: {Index: 0},\n\t\t\t\tTitle: \"Indicate here the threshold to use for hit selection, as a percentage. All values above the threshold will be selected\"\n\t\t\t}),\n\t\t\tLimit: LinkCtrl.new(\"Select\", {ID: \"Start\", Default: 3, Label: \"Hit limit\", Chain: {Index: 1, Last: true}, List: [100, 500, 1000, 5000, 10000, 50000],\n\t\t\t\tTitle: \"Limit for the number of hits that can be collected by a single parameter. The hit search will stop when any given parameter reaches this limit\"\n\t\t\t}),\n\t\t\tMode: LinkCtrl.new(\"Radio\", {ID: \"Config\", Default: 0, Label: \"Mode\", List: [\"Global\", \"Plate\", \"Custom\"],\n\t\t\t\tChange: function(v) {\n\t\t\t\t\tif(v == 2) {\n\t\t\t\t\t\tGetId(\"Custom\").style.display = \"block\";\n\t\t\t\t\t\tGetId(\"Control\").style.display = \"none\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tGetId(\"Custom\").style.display = \"none\";\n\t\t\t\t\t\tGetId(\"Control\").style.display = \"block\";\n\t\t\t\t\t}\n\t\t\t\t}, Title: \"Whether the normalization should be done using the aggregated control values from the entire set of plates (Global), on a plate-by-plate basis (Plate), or a set of values manually provided (Custom)\",\n\t\t\t}),\n\t\t\tControlHigh: LinkCtrl.new(\"Select\", {ID: \"Control\", Default: 0, Label: \"Control High (100%)\", List: this.Controls.map(function(c) {return c.Name}), Chain: {Index: 0},\n\t\t\t\tTitle: \"Select the control to use as reference for the high percentage. The average of all its values will be used as the 100% reference\"\n\t\t\t}),\n\t\t\tControlLow: LinkCtrl.new(\"Select\", {ID: \"Control\", Default: 0, Label: \"Control Low (0%)\", List: this.Controls.map(function(c) {return c.Name}), Chain: {Index: 1, Last: true},\n\t\t\t\tTitle: \"Select the control to use as reference for the low percentage. The average of all its values will be used as the 0% reference\"\n\t\t\t}),\n\t\t\tCustomHigh: LinkCtrl.new(\"Number\", {ID: \"Custom\", Default: 0, Label: \"High (100%)\", Chain: {Index: 0}, Title: \"The value to use as reference for the high percentage. Will be used as the 100% reference\"}),\n\t\t\tCustomLow: LinkCtrl.new(\"Number\", {ID: \"Custom\", Default: 0, Label: \"Low (0%)\", Chain: {Index: 1, Last: true}, Title: \"The value to use as reference for the low percentage. Will be used as the 0% reference\"}),\n\t\t}\n\t\tObject.assign(this.UI, opt);\n\t\tGetId(\"Config\").insertAdjacentHTML(\"afterend\", \"<div id=\\\"Control\\\"></div><div id=\\\"Custom\\\" style=\\\"display: none\\\"></div>\");\n\t\tthis.prepareDefinition();\n\t\treturn this;\n\t}\n\t//Static methods\n\tstatic waitMsg(count, itemName) {\n\t\tlet msg = \"<div class=\\\"HitStatus\\\">\";\n\t\tmsg += \"<span class=\\\"Warning\\\">Scanning for hit values, please wait...</span>\";\n\t\tmsg += \"Parsed <span class=\\\"LineStatus\\\">1</span>\";\n\t\tmsg += \" / \" + count + \" \" + itemName;\n\t\tmsg += \"</div><div class=\\\"ResolveStatus\\\"></div>\";\n\t\treturn msg;\n\t}\n\tstatic logRange(content, plate, toResolve) { //Log the ranges and plates associated to this well content in the toResolve array, so that it can be resolved later\n\t\tif(content.Ranges.length > 0) { //At least one range is there\n\t\t\tcontent.Ranges.forEach(function(r) { //Loop the ranges\n\t\t\t\tif(r.Range.Definition !== undefined) { //Ignore ranges without definitions (not resolvable)\n\t\t\t\t\tlet found = toResolve.find(function(a) {return a.Range.Name == r.Range.Name});\n\t\t\t\t\tif(found === undefined) { //Init a new entry for this range\n\t\t\t\t\t\ttoResolve.push({Range: r.Range, Plate: [plate]});\n\t\t\t\t\t}\n\t\t\t\t\telse { //Range already exist, update the plate list...\n\t\t\t\t\t\tif(found.Plate.includes(plate) == false) {found.Plate.push(plate)} //...When necessary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tstatic compareCtrl(High, Low, ui) { //Compare the controls and return false if same are selected\n\t\tif(ui.Mode.Selected == \"Custom\") {\n\t\t\tif(ui.CustomHigh.getValue() == ui.CustomLow.getValue()) {return false}\n\t\t}\n\t\telse {\n\t\t\tif(High.Name == Low.Name) {return false}\n\t\t}\n\t\treturn true;\n\t}\n\t//Methods\n\tdo() { //This should do nothing here\n\t\tif(this.Ready === undefined) { //First activation of the report\n\t\t\tlet start = GetId(\"Start\");\n\t\t\tlet b = LinkCtrl.button({Label: \"Start\", Title: \"Click here to start computing the hits for all plates of the selected result file\", Click: function() {this.compute()}.bind(this)});\n\t\t\tstart.insertAdjacentHTML(\"beforeend\", \"&nbsp;\");\n\t\t\tstart.append(b); //Place the button\n\t\t\tstart.insertAdjacentHTML(\"beforeend\", \"&nbsp;<span id=\\\"ErrorMsg\\\" class=\\\"Warning\\\"></span>\");\n\t\t\tthis.Ready = true;\n\t\t}\n\t\treturn this;\n\t}\n\tresolveNames() { //Function should be available to allow correct functioning of the pairing display\n\t\treturn Promise.resolve(undefined);\n\t}\n\tupdateNames() { //Function should be available to allow correct functioning of the pairing display\n\t\treturn this;\n\t}\n\tasync compute() { //Do the job\n\t\tthis.Cancel = false; //Reset to prepare a new run\n\t\tthis.Stop = false;\n\t\tlet resultIndex = this.Results.SelectedIndices[0]; //The index of the result file selected (0-based), unique\n\t\tlet o = {Items: 0, Params: [], Values: []} //Output object containing the data\n\t\to.HitLimit = this.UI.Limit.Selected; //Hit limit\n\t\tthis.Params.forEach(function(p, i) { //Initialize empty array to receive the values for each selected parameters that is set as numeric\n\t\t\tif(p.Selected && p.Numeric) { //This parameter is selected and numeric type, continue\n\t\t\t\tlet param = {Index: i, Name: p.Name, ResultIndex: resultIndex + 1}\n\t\t\t\to.Params.push(param);\n\t\t\t\to.Values.push({H: [], L: []}); //Create empty arrays to receive the values for each parameter\n\t\t\t}\n\t\t}, this);\n\t\tlet High = this.getControlHigh(resultIndex, o.Params);\n\t\tlet Low = this.getControlLow(resultIndex, o.Params);\n\t\tif(Report_Hits.compareCtrl(High, Low, this.UI) == false) {\n\t\t\tGetId(\"ErrorMsg\").innerHTML = \"High and Low controls should not be the same! Check your inputs before continuing\";\n\t\t\treturn;\n\t\t}\n\t\telse {GetId(\"ErrorMsg\").innerHTML = \"\"}\n\t\tswitch(this.UI.Mode.Selected) { //Each mode is treated differently\n\t\t\tcase \"Global\": //FALL-THROUGH\n\t\t\tcase \"Custom\": //Global search, first get the aggregated control values, then get the hits\n\t\t\t\tthis.waitMessage(o.Params); //Displays waiting message\n\t\t\t\tawait this.aggregateCtrl(High, Low, resultIndex, o); //Aggregate the control values for the entire result file, then re-compute the entire file to normalize the data and extract the \"hits\"\n\t\t\t\tthis.reportControl(High, Low, resultIndex, o);\n\t\t\t\tlet data = await this.findHitsGlobal(High, Low, resultIndex, o); //Wait for the hit list to come back then report it\n\t\t\t\tthis.update(); //Update sections with the final hit list\n\t\t\t\tthis.reportHits(data, o.Params, resultIndex); //Report the hits\n\t\t\t\tawait this.resolveHitNames(data, o.Params, resultIndex); //Start the resolution process\n\t\t\t\tthis.done(data, o.Params); //Finalize\n\t\t\t\tbreak;\n\t\t\tcase \"Plate\": //In this mode, plates are treated sequentially\n\t\t\t\tlet end = await this.findHitsLocal(High, Low, resultIndex, o); //Wait for the hit selection process to finish for all plates\n\t\t\t\tthis.reportHits(end, o.Params, resultIndex); //Report the hits\n\t\t\t\tawait this.resolveHitNames(end, o.Params, resultIndex); //Start the name resolution process\n\t\t\t\tthis.done(end, o.Params); //Finalize\n\t\t\t\tbreak;\n\t\t\tdefault: break;\n\t\t}\n\t\treturn this;\n\t}\n\taggregateCtrl(High, Low, resultIndex, o) { //Aggregate the values for the high and low controls provided by their name\n\t\treturn new Promise(function(resolve) {\n\t\t\tif(High.Stats[resultIndex] !== undefined && Low.Stats[resultIndex] !== undefined) { //Values already exist, resolve\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\telse { //Scan the result file to get the values\n\t\t\t\tHigh.Stats[resultIndex] = []; //Initialize the array to recover the data\n\t\t\t\tLow.Stats[resultIndex] = [];\n\t\t\t\tlet f = function(well, plate, row, output, parser) { //The function to run on each line\n\t\t\t\t\tlet wellIndex = well.Index;\n\t\t\t\t\tif(High.Tags.includes(wellIndex)) { //This well belongs to the control high\n\t\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\n\t\t\t\t\t\t\toutput.Values[i].H.push(Number(row[param.Index]));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(Low.Tags.includes(wellIndex)) { //Belongs to control low\n\t\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\n\t\t\t\t\t\t\toutput.Values[i].L.push(Number(row[param.Index]));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: f}, o).then(function(data) { //Execute the scan\n\t\t\t\t\tdata.Params.forEach(function(param, i) { //Log the average values for all parameters\n\t\t\t\t\t\tHigh.Stats[resultIndex][i] = Coordinate.statValue(data.Values[i].H);\n\t\t\t\t\t\tLow.Stats[resultIndex][i] = Coordinate.statValue(data.Values[i].L);\n\t\t\t\t\t\tdata.Values[i].H = []; //Free memory space by releasing the list of values\n\t\t\t\t\t\tdata.Values[i].L = [];\n\t\t\t\t\t});\n\t\t\t\t\tresolve();\n\t\t\t\t});\n\t\t\t}\n\t\t}.bind(this));\n\t}\n\tgetControlHigh(resultIndex, params) { //Return the high Control\n\t\tif(this.UI.Mode.Selected == \"Custom\") { //Create a pseudo-object that matches with the global method\n\t\t\tlet stats = [];\n\t\t\tstats[resultIndex] = []; //Initialize array\n\t\t\tlet high = this.UI.CustomHigh.getValue();\n\t\t\tparams.forEach(function(p) {\n\t\t\t\tstats[resultIndex].push({Average: high, SD: \"\", N: \"\"}); //Only the user-provided value can be added here\n\t\t\t});\n\t\t\treturn {Name: \"High\", Tags: [], Stats: stats}\n\t\t}\n\t\telse { //Global method\n\t\t\tlet name = this.UI.ControlHigh.Selected;\n\t\t\treturn this.Controls.find(function(c) {return c.Name == name})\n\t\t}\n\t}\n\tgetControlLow(resultIndex, params) { //Return the Low Control\n\t\tif(this.UI.Mode.Selected == \"Custom\") { //Create a pseudo-object that matches with the global method\n\t\t\tlet stats = [];\n\t\t\tstats[resultIndex] = [];\n\t\t\tlet low = this.UI.CustomLow.getValue();\n\t\t\tparams.forEach(function(p) {\n\t\t\t\tstats[resultIndex].push({Average: low, SD: \"\", N: \"\"});\n\t\t\t});\n\t\t\treturn {Name: \"Low\", Tags: [], Stats: stats}\n\t\t}\n\t\telse {\n\t\t\tlet name = this.UI.ControlLow.Selected;\n\t\t\treturn this.Controls.find(function(c) {return c.Name == name})\n\t\t}\n\t}\n\treportControl(High, Low, resultIndex, o) { //Write a report for the summary of the control values\n\t\tlet CV = this.Options.CV.getValue();\n\t\to.Params.forEach(function(param, i) { //Process all parameters\n\t\t\tlet h = High.Stats[resultIndex][i];\n\t\t\tlet l = Low.Stats[resultIndex][i];\n\t\t\tlet json = { //JSON to create the section\n\t\t\t\tData: [{\n\t\t\t\t\tGroups: [\n\t\t\t\t\t\t{Name: High.Name + \" (100%)\", DataPoints: [ [h.N + \" values\"] ]},\n\t\t\t\t\t\t{Name: Low.Name + \" (0%)\", DataPoints: [ [l.N + \" values\"] ]}\n\t\t\t\t\t],\n\t\t\t\t\tSubGroups: [], //Array must be present, even if empty\n\t\t\t\t}],\n\t\t\t\tStatRows: true,\n\t\t\t\tStats: [h, l] //Stats are directly provided\n\t\t\t};\n\t\t\tif(h.N === \"\") {json.Data[0].Groups[0].DataPoints[0][0] = \"Custom value\"} //Make it pretty for the Custom Mode\n\t\t\tif(l.N === \"\") {json.Data[0].Groups[1].DataPoints[0][0] = \"Custom value\"}\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Control summary\");\n\t\t\tsection.Data = JSON.stringify(json); //Save the data as string in the section\n\t\t}, this);\n\t\tthis.update(); //Update the sections\n\t\treturn this;\n\t}\n\tfindHitsGlobal(High, Low, resultIndex, o) { //Extract hits from the result file, using global average calculated earlier\n\t\tlet percent = this.UI.Threshold.getValue();\n\t\tlet t = percent / 100;\n\t\tlet title = \"Global Hits (\" + percent + \"%)\";\n\t\tif(this.UI.Mode.Selected == \"Custom\") {title = \"Custom Hits (\" + percent + \"%)\"}\n\t\tlet diff = []; //Array to hold the diffs for each parameter\n\t\tlet counts = []; //How many hits for each parameter\n\t\tlet toResolve = []; //Array that will hold the plate name for each range that need to be resolved\n\t\to.Params.forEach(function(param, i) { //Prepare arrays for each parameters\n\t\t\tlet json = this.emptyJSON(); //Empty JSON architecture to represent the hit table\n\t\t\tjson.SyncScrolling = true;\n\t\t\tdiff[i] = High.Stats[resultIndex][i].Average - Low.Stats[resultIndex][i].Average;\n\t\t\tcounts[i] = 0; //Count of hits for each parameter\n\t\t\tlet s = Report.getBloc(this, Report.blocName(param)).getSection(title, {\n\t\t\t\tType: \"Multiple\",\n\t\t\t\tJSON: [json],\n\t\t\t\tChanged: true //Reset previous table\n\t\t\t}); \n\t\t\tGetId(s.ID).insertAdjacentHTML(\"beforebegin\", Report_Hits.waitMsg(this.Result.Parser.SelectedRows, \"lines\"));\n\t\t}, this);\n\t\tif(diff.reduce(function(acc, val) {return (acc && (val == 0))}, true)) { //If all diffs are zero, its a Fail...\n\t\t\treturn Promise.resolve({\n\t\t\t\tStatus: \"Fail\",\n\t\t\t\tSection: title,\n\t\t\t\tResolvable: [],\n\t\t\t\tHits: counts,\n\t\t\t\tMsg: \"The average for the High and Low controls are the same! Check the selected controls and try again\"\n\t\t\t});\n\t\t}\n\t\to.Items = 0; //Reset the item count before starting new parsing with the same object\n\t\tlet f = function(well, plate, row, output, parser) { //The function to run on each line\n\t\t\tlet wellIndex = well.Index;\n\t\t\tlet content = this.Layout[wellIndex];\n\t\t\toutput.Params.forEach(function(param, i) { //Check values for all parameters\n\t\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(title, {Changed: false}); //Get the section that was initialized before\n\t\t\t\tif(output.Items % 2000 == 0) { //Every 1000 lines, report the progress\n\t\t\t\t\tlet p = GetId(section.ID).parentElement.getElementsByClassName(\"LineStatus\")[0];\n\t\t\t\t\tp.innerHTML = output.Items; //Update with the current line number\n\t\t\t\t\tsection.update(); //Update the section with hits found so far\n\t\t\t\t}\n\t\t\t\tif(content.Type == 0 || content.Type == 1) {return} //Exclude any well that has been tagged as pure control type\n\t\t\t\tif(diff[i] == 0) {return} //Do something only if the diff is not zero\n\t\t\t\tlet val = Number(row[param.Index]);\n\t\t\t\tlet norm = 0;\n\t\t\t\tif(diff[i] < 0) {norm = 1 - (High.Stats[resultIndex][i].Average - val) / diff[i]}\n\t\t\t\telse {norm = (val - Low.Stats[resultIndex][i].Average) / diff[i]}\n\t\t\t\tif(norm >= t) { //Found a hit\n\t\t\t\t\tcounts[i]++; //Increment the hit count for this parameter\n\t\t\t\t\tlet results = [{Type: \"text\", Value: counts[i]}, plate, well.Name, content.HTML, val, norm * 100];\n\t\t\t\t\tlet json = this.emptyJSON(); //empty json object structure\n\t\t\t\t\tjson.Data[0].Groups.forEach(function(g, j) { //Populate the empty json with the data\n\t\t\t\t\t\tg.DataPoints[0] = [ results[j] ];\n\t\t\t\t\t});\n\t\t\t\t\tsection.addRow({Data: [json]}, counts[i]); //Use the counts as comparator to ensure all hits are added, as counts are all unique\n\t\t\t\t\tReport_Hits.logRange(content, plate, toResolve); //Log the range/plate if needed\n\t\t\t\t\tif(counts[i] >= output.HitLimit) { //Stop the search when too many hits are found for a single parameter\n\t\t\t\t\t\toutput.Overflow = {Param: param.Name}; //Log the parameter that overflowed\n\t\t\t\t\t\tparser.abort(); //Abort the search\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}.bind(this);\n\t\treturn new Promise(function(resolve) { //Run the scan\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: f}, o).then(function(data) { //After Scan is complete\n\t\t\t\tlet out = {Status: \"Done\", Msg: \"Done\", Hits: counts, Section: title, Resolvable: toResolve};\n\t\t\t\tif(data.Overflow !== undefined) { //Hit limit was reached\n\t\t\t\t\tout.Status = \"Overflow\";\n\t\t\t\t\tout.Msg = \"Hit limit (\" + o.HitLimit + \") reached for parameter: \" + data.Overflow.Param + \"; search aborted\";\n\t\t\t\t}\n\t\t\t\tresolve(out);\n\t\t\t});\n\t\t}.bind(this));\n\t}\n\treportHits(data, params, resultIndex) { //Screening done, report hits and update the waiting messages\n\t\tparams.forEach(function(param, i) { //Process all parameters\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\n\t\t\tlet section = bloc.getSection(data.Section);\n\t\t\tlet S = GetId(section.ID).parentElement; //Root for the feedback messages\n\t\t\tlet p = S.getElementsByClassName(\"HitStatus\")[0]; //The paragraph with the status\n\t\t\tlet msg = \"\";\n\t\t\tif(data.Status == \"Fail\" || data.Status == \"Overflow\" || data.Status == \"Aborted\") { //Error during screening\n\t\t\t\tmsg = \"<span class=\\\"Warning\\\">\" + data.Msg + \"</span>\";\n\t\t\t\tsection.Tables[0].Title = data.Msg; //Internally update the title with the text, for export\n\t\t\t}\n\t\t\telse { //Completed normally\n\t\t\t\tlet out = \"Found \" + data.Hits[i] + \" Hits\";\n\t\t\t\tmsg = \"<span class=\\\"Success\\\">\" + out + \"</span>\";\n\t\t\t\tsection.Tables[0].Title = out; //Internally update the title with the text, for export\n\t\t\t}\n\t\t\tp.innerHTML = msg; //Update the html\n\t\t}, this);\n\t\treturn this;\n\t}\n\tasync resolveHitNames(data, params, resultIndex) { //Resolve all names by parsing the data plate by plate and resolving through all sections\n\t\tlet totalPlate = data.Resolvable.reduce(function(acc, val) { //Check the total number of plates to compute\n\t\t\treturn acc += val.Plate.length;\n\t\t}, 0);\n\t\tlet count = 0; //Current count of plate\n\t\tlet pairing = this.Results.Array[resultIndex].Pairing;\n\t\tif(pairing === undefined) { //No resolution needed in this case\n\t\t\tthis.convertRangeNames(data, params); //Convert the tags into simple names\n\t\t\treturn this;\n\t\t}\n\t\tlet l = data.Resolvable.length; //Number of range to process\n\t\tfor(let i=0; i<l; i++) { //Loop the ranges\n\t\t\tlet r = data.Resolvable[i];\n\t\t\tlet def = r.Range.Definition; //The definition for this range\n\t\t\tlet plateCounter = Report.plateIterator(r.Plate); //A generator to loop over the result plates\n\t\t\tlet current = plateCounter.next();\n\t\t\twhile(current.done == false && this.Stop == false) { //Loop all the result plates and stops if a signal is triggered\n\t\t\t\tlet p = current.value.toString(); //Name of the current result plate to analyze. Should always be used as a text, force it here for generic index\n\t\t\t\tlet plateIndex = this.UI.Plate.List.findIndex(function(n) {return n == p}); //Index of the result plate\n\t\t\t\tlet pair = pairing.Pairs[plateIndex]; //The pair object defined for this result plate\n\t\t\t\tlet defPlate = def.PlatesID[0]; //Use this as a fallback value in case no pairing is available\n\t\t\t\tif(pair !== undefined) { //Only paired plates needs resolution\n\t\t\t\t\tdefPlate = pair.getPair(r.Range.Name); //Use the paired definition plate when available\n\t\t\t\t\tlet resolved = await def.getPlate(defPlate.Name); //Fetch all the names for this definition plate\n\t\t\t\t\tparams.forEach(function(param) { //Process all parameters\n\t\t\t\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\n\t\t\t\t\t\tlet section = bloc.getSection(data.Section);\n\t\t\t\t\t\tif(count == 0) { //On the first pass, clean up the hitStatus that is now indicated as the table title\n\t\t\t\t\t\t\tGetId(section.ID).parentElement.getElementsByClassName(\"HitStatus\")[0].remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsection.resolveNames({ //Resolve the names for this section\n\t\t\t\t\t\t\tRange: r.Range,\n\t\t\t\t\t\t\tPlate: p,\n\t\t\t\t\t\t\tNames: resolved,\n\t\t\t\t\t\t\tTotal: totalPlate,\n\t\t\t\t\t\t\tCount: count,\n\t\t\t\t\t\t\tReport: this\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsection.update(); //Update the section with the new names\n\t\t\t\t\t}, this);\n\t\t\t\t}\n\t\t\t\tcurrent = plateCounter.next(); //Go to the next plate\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(this.Stop) { //Termination signal has been received\n\t\t\t\tthis.convertRangeNames(data, params); //Convert the remaining tags into simple names\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t}\n\tasync findHitsLocal(High, Low, resultIndex, o) { //Find hits using the aggregated control values at the plate level\n\t\tlet percent = this.UI.Threshold.getValue();\n\t\tlet toResolve = [];\n\t\tlet plates = this.Result.PlatesID;\n\t\tlet l = plates.length;\n\t\to.Threshold = percent / 100;\n\t\to.Title = \"Plate Hits (\" + percent + \"%)\";\n\t\to.Counts = []; //How many hits for each parameter\n\t\to.Params.forEach(function(param, i) { //Prepare arrays for each parameters\n\t\t\to.Counts[i] = 0;\n\t\t\tlet json = this.emptyJSON();\n\t\t\tjson.SyncScrolling = true; //Allow sync scrolling of the report table\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(o.Title, {\n\t\t\t\tType: \"Multiple\",\n\t\t\t\tJSON: [json],\n\t\t\t\tChanged: true //Reset previous table\n\t\t\t});\n\t\t\tGetId(section.ID).insertAdjacentHTML(\"beforebegin\", Report_Hits.waitMsg(l, \"plates\")); //Feedback message\n\t\t}, this);\n\t\tReport.lock(this, l); //Lock the report and start\n\t\tlet plateCounter = Report.plateIterator(plates); //A generator to loop over the plates\n\t\tlet current = plateCounter.next();\n\t\tlet running = 0; //Counter for the index of the running plate\n\t\twhile(current.done == false && this.Cancel == false && o.Overflow === undefined) { //Do this until the plate counter is exhausted or the user cancel the action\n\t\t\tlet currentPlate = current.value.toString(); //Current plate to analyze. Should always be used as a text, force it here for generic index\n\t\t\tHigh.Stats[resultIndex] = []; //Remove previous data to ensure new ones are retrieved\n\t\t\tLow.Stats[resultIndex] = [];\n\t\t\tawait this.getValuesLocal(High, Low, resultIndex, o, currentPlate, toResolve); //Collect values to extract hits\n\t\t\tthis.plateSummary(High, Low, resultIndex, o, currentPlate, running); //Store control data\n\t\t\tthis.getHits(High, Low, resultIndex, o, currentPlate, toResolve, running); //Collect hits\n\t\t\tthis.update(); //Update the section after the hit search is completed\n\t\t\tcurrent = plateCounter.next();\n\t\t\tthis.UI.Plate.setValue(running); //Ensures that the control is set at the same value as the last computed plate\n\t\t\tthis.pairStatus(running); //Also adjust the pairing info\n\t\t\trunning++; //Next plate index\n\t\t\tReport.plateCount(running + 1); //Next plate analysis will start after this\n\t\t}\n\t\tHigh.Stats[resultIndex] = undefined; //Remove previous data to prevent interference with Global hit find\n\t\tLow.Stats[resultIndex] = undefined;\n\t\tReport.unlock();\n\t\tlet out = {Status: \"Done\", Msg: \"Done\", Hits: o.Counts, Section: o.Title, Resolvable: toResolve};\n\t\tif(o.Overflow !== undefined) { //Hit limit was reached\n\t\t\tout.Status = \"Overflow\";\n\t\t\tout.Msg = \"Hit limit (\" + o.HitLimit + \") reached for parameter: <b>\" + o.Overflow.Param + \"</b>; search aborted\";\n\t\t}\n\t\telse {\n\t\t\tif(this.Cancel === true) {\n\t\t\t\tout.Status = \"Aborted\";\n\t\t\t\tout.Msg = \"Found \" + o.Counts + \" hits. Search aborted by user request\";\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\tgetValuesLocal(High, Low, resultIndex, o, currentPlate, toResolve) { //Gather values from controls and parameters for the current plate, in a single pass\n\t\to.Params.forEach(function(param, i) { //For all parameters\n\t\t\to.Values[i].P = []; //Reset the parameter values before accumulating again\n\t\t\to.Values[i].H = []; //Same for controls\n\t\t\to.Values[i].L = [];\n\t\t});\n\t\tlet f = function(well, plate, row, output, parser) { //The function to run on each line\n\t\t\tif(plate != currentPlate) {return} //Not the right plate\n\t\t\tlet wellIndex = well.Index;\n\t\t\tlet content = this.Layout[wellIndex];\n\t\t\tif(content.Type == 2 || content.Type == 3) { //For wells that were tagged as a range or sample type\n\t\t\t\toutput.Params.forEach(function(param, i) { //Store values for all paramaters\n\t\t\t\t\toutput.Values[i].P.push({Well: well, Value: Number(row[param.Index])}); //Push the values\n\t\t\t\t});\n\t\t\t}\n\t\t\telse { //Other wells (controls)\n\t\t\t\tif(High.Tags.includes(wellIndex)) { //This well belongs to the control high\n\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\n\t\t\t\t\t\toutput.Values[i].H.push(Number(row[param.Index]));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif(Low.Tags.includes(wellIndex)) { //Belongs to control low\n\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\n\t\t\t\t\t\toutput.Values[i].L.push(Number(row[param.Index]));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this);\n\t\treturn new Promise(function(resolve) { //Start the scan\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: f}, o).then(function(data) { //After scan is complete\n\t\t\t\tdata.Params.forEach(function(param, i) { //Log the average values for all parameters\n\t\t\t\t\tHigh.Stats[resultIndex][i] = Coordinate.statValue(data.Values[i].H);\n\t\t\t\t\tLow.Stats[resultIndex][i] = Coordinate.statValue(data.Values[i].L);\n\t\t\t\t});\n\t\t\t\tresolve();\n\t\t\t});\n\t\t}.bind(this));\n\t}\n\tgetHits(High, Low, resultIndex, o, currentPlate, toResolve, running) { //Find the hits in the values stored for the current plate\n\t\tlet t = o.Threshold;\n\t\to.Params.forEach(function(param, i) { //Check values for all paramaters\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(o.Title); //Get the section that was initialized before\n\t\t\tlet diff = High.Stats[resultIndex][i].Average - Low.Stats[resultIndex][i].Average;\n\t\t\tif(diff != 0) { //Do something only if the diff is not zero\n\t\t\t\to.Values[i].P.forEach(function(value) { //Loop all the values for this parameter\n\t\t\t\t\tlet val = value.Value;\n\t\t\t\t\tlet well = value.Well;\n\t\t\t\t\tlet content = this.Layout[well.Index];\n\t\t\t\t\tlet norm = 0;\n\t\t\t\t\tif(diff < 0) {norm = 1 - (High.Stats[resultIndex][i].Average - val) / diff}\n\t\t\t\t\telse {norm = (val - Low.Stats[resultIndex][i].Average) / diff}\n\t\t\t\t\tif(norm >= t) { //Found a hit\n\t\t\t\t\t\to.Counts[i]++; //Update the counts\n\t\t\t\t\t\tlet index = o.Counts[i];\n\t\t\t\t\t\tlet results = [{Type: \"text\", Value: index}, currentPlate, well.Name, content.HTML, val, norm * 100];\n\t\t\t\t\t\tlet json = this.emptyJSON(); //Empty json architecture\n\t\t\t\t\t\tjson.Data[0].Groups.forEach(function(g, j) { //Populate the json with the data\n\t\t\t\t\t\t\tg.DataPoints[0] = [ results[j] ];\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsection.addRow({Data: [json]}, o.Counts[i]); //Push data to the table\n\t\t\t\t\t\tReport_Hits.logRange(content, currentPlate, toResolve); //Log the range/plate if needed\n\t\t\t\t\t\tif(o.Counts[i] >= o.HitLimit) { //Stop the search when too many hits are found for a single parameter\n\t\t\t\t\t\t\to.Overflow = {Param: param.Name}; //Log the parameter that overflowed\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\tlet p = GetId(section.ID).parentElement.getElementsByClassName(\"LineStatus\")[0];\n\t\t\tp.innerHTML = running + 1; //Update with the current plate number\n\t\t}, this);\n\t\treturn this;\n\t}\n\tdone(data, params) { //Screening done, last clean up\n\t\tif(data.Status == \"Fail\") {return this}\n\t\tparams.forEach(function(param, i) { //Process all parameters\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\n\t\t\tlet section = bloc.getSection(data.Section);\n\t\t\tlet p = GetId(section.ID).parentElement.getElementsByClassName(\"ResolveStatus\"); //The div with the resolution status\n\t\t\tif(p.length >0) { //If the html element still exists, update the feedback message\n\t\t\t\tif(this.Stop) {p[0].innerHTML = \"<span class=\\\"Warning\\\">Name resolution stopped</span>\"}\n\t\t\t\telse {p[0].innerHTML = \"\"}\n\t\t\t}\t\n\t\t\tif(this.Cancel) { //Search was cancelled\n\t\t\t\tlet span = GetId(section.ID).parentElement.getElementsByClassName(\"HitStatus\"); //The paragraph with the status\n\t\t\t\tif(span.length > 0) { //If the html element still exists, update the feedback message\n\t\t\t\t\tspan[0].innerHTML = \"<span class=\\\"Warning\\\">Found \" + data.Hits[i] + \" Hits; Search not completed (cancelled)</span>\";\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t\treturn this;\n\t}\n\tplateSummary(High, Low, resultIndex, o, plate, running) { //Log the control values found for each plate\n\t\tlet change = false;\n\t\tif(running == 0) {change = true} //If this is the first plate, reset the section\n\t\to.Params.forEach(function(param, i) { //Process all parameters\n\t\t\tlet json = { //json object architecture for this table\n\t\t\t\tData: [{\n\t\t\t\t\tGroups: [\n\t\t\t\t\t\t{Name: High.Name + \" (100%)\", DataPoints: [ [] ]},\n\t\t\t\t\t\t{Name: Low.Name + \" (0%)\", DataPoints: [ [] ]},\n\t\t\t\t\t],\n\t\t\t\t\tSubGroups: [] //Must be present even if empty\n\t\t\t\t}]\n\t\t\t}\n\t\t\tlet options = {Type: \"StatsTable\", JSON: json, Summary: true, Changed: change};\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Plate Summary\", options);\n\t\t\tsection.addRow({Data: []}, plate, {\n\t\t\t\tStats: [ //No need to supply a json data as the stats are pre-computed\n\t\t\t\t\tHigh.Stats[resultIndex][i],\n\t\t\t\t\tLow.Stats[resultIndex][i]\n\t\t\t\t]\n\t\t\t});\n\t\t}, this);\n\t}\n\temptyJSON() { //Return the base structure of the json needed to build the hit table\n\t\tlet json = {\n\t\t\tData: [\n\t\t\t\t{\n\t\t\t\t\tGroups: [\n\t\t\t\t\t\t{Name: \"#\", DataPoints: [ [] ]},\n\t\t\t\t\t\t{Name: \"Plate\", DataPoints: [ [] ]},\n\t\t\t\t\t\t{Name: \"Well\", DataPoints: [ [] ]},\n\t\t\t\t\t\t{Name: \"Content\", DataPoints: [ [] ]},\n\t\t\t\t\t\t{Name: \"Raw value\", DataPoints: [ [] ]},\n\t\t\t\t\t\t{Name: \"Normalized value\", DataPoints: [ [] ]},\n\t\t\t\t\t],\n\t\t\t\t\tSubGroups: [],\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t\treturn json;\n\t}\n\tconvertRangeNames(data, params) { //In case there are no defintions attached to the result file, convert the html tags back into simple names\n\t\tparams.forEach(function(param) { //Process all parameters\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\n\t\t\tlet section = bloc.getSection(data.Section);\n\t\t\tlet hitStatus = GetId(section.ID).parentElement.getElementsByClassName(\"HitStatus\");\n\t\t\tif(hitStatus.length > 0) { //If clean up has not already be done elsewhere (this happens when hit resolution is cancelled)\n\t\t\t\thitStatus[0].remove(); //clean up the hitStatus that is now indicated as the table title\n\t\t\t}\n\t\t\tlet coll = GetId(section.ID).getElementsByClassName(\"Resolvable\"); //The HTMLcollection of elements to resolve in this section. Recall it each time, because the number of element remaining will decrease after each turn\n\t\t\tlet l = coll.length;\n\t\t\tfor(let i=0;i<l;i++) { //Travel the collection to update the data\n\t\t\t\tlet index = coll[i].parentElement.parentElement.rowIndex; //Index of this line in the hit table\n\t\t\t\tsection.Tables[0].Data.Data[0].Groups[3].DataPoints[0][index] = coll[i].innerText; //Recover only the text\n\t\t\t}\n\t\t\tsection.update(); //Update the section with the new names\n\t\t}, this);\n\t\treturn this;\n\t}\n}"]}