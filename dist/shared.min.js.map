{"version":3,"sources":["shared-forms/Form_Color.js","shared-forms/Form_Import.js","shared-objects/CSSCOLORS.js","shared-objects/Coordinate.js","shared-objects/Decimal.js","shared-objects/InputObject.js","shared-objects/InputParser.js","shared-objects/Mapper.js","shared-objects/Pair.js","shared-objects/Pairing.js","shared-objects/Reporter.js","shared-objects/Unit.js","shared-objects/WorkerGroup.js","shared-tools/GetId.js","shared-objects/InputObject/InputObject_File.js","shared-objects/InputObject/InputObject_Manual.js","shared-objects/InputParser/InputParser_Papa.js","shared-objects/InputParser/InputParser_XLS.js","shared-objects/InputParser/InputParser_XLSX.js","shared-objects/Mapper/Mapper_Direct.js","shared-objects/Mapper/Mapper_Plate.js","shared-objects/Mapper/Mapper_PlateWell.js","shared-objects/Mapper/Mapper_Well.js"],"names":["Form_Color","I","this","Selected","Caller","getValue","txt","CSSCOLORS","list","forEach","c","id","Form","open","ID","HTML","Title","Buttons","Label","Click","color","setValue","after","close","bind","onInit","span","GetId","collection","document","getElementsByClassName","l","length","i","item","addEventListener","e","target","style","backgroundColor","title","Form_Import","[object Object]","init","Single","Multiple","Chain","Controls","File","html","Size","Step1","bindEvents","onCancel","cancel","OnClose","Init","index","undefined","Dialogs","Anchors","Input","Table","InputType","InputSelection","Parsing","Parser","ParserOptions","Preview","PreviewBox","WaitMask","WaitMaskCurrent","WaitMaskTotal","WaitMaskList","ApplyToAll","LinkCtrl","new","Default","Accept","ManualName","Manual","Preserve","Index","RespTable","Fields","RowNumbers","onSelect","S","oldS","oldIndex","selectInput","List","ControlLeft","Change","changeInputType","NewLine","togglePreview","next","Icon","Type","Space","Color","Step2","back","done","ApplyAll","applyConfigToAll","ButtonBar","Spacing","Step","b","button","addInput","append","change","bar","buttonBar","me","Value","focus","download","FileName","insertAdjacentHTML","insertAdjacentElement","T","Length","alert","fileList","f","InputObject","addRow","data","m","Data","Name","input","showParsingControls","InputParser","parse","Limit","hideControls","replaceButtons","parsingStart","Array","selected","SelectedIndices","promises","a","noPrev","push","testParse","NoPreview","NoInit","row","n","parser","inputIndex","FirstParsed","Math","round","children","innerHTML","Complete","parsingUp","Error","parsingError","Promise","all","then","parsingDone","update","display","showControls","bool","resolve","Status","array","ParsedInputs","mask","childs","nextElementSibling","h","max","offsetHeight","w","offsetWidth","height","width","nbRows","error","name","onError","Source","SelectedRows","SelectedCols","Other","Info","Headers","parserType","options","Object","values","Options","toSpliced","disable","NoParse","o","j","reject","enable","empty","reset","type","Luminescence","source","findIndex","returnAsTxt","out","fetchIndex","corr","match","map","v","pow","cutOff","min","colors","r","g","Coordinate","Values","Excluded","fill","Numeric","reduce","acc","val","Decimal","isNumeric","coord","statValue","Average","isArray","x","filter","N","Total","avg","cur","sumVariance","SD","sqrt","CV","way","statObject","Names","s","Types","Titles","Class","InputStr","toString","Sgn","sign","abs","ValueStr","Floor","floor","FloorStr","ExpPosition","indexOf","DecPosition","Power","log10","RawDecimalStr","substring","PowerOffset","Decimals","Number","DecimalStr","PureValueStr","replace","PureValue","toFixed","isNaN","d","nice","above","offset","p","Below","Loose","digit","op","Strict","reverse","niceNumber","ReturnAsObject","A","B","pureResults","power","result","NaN","NoTilde","diff","toExponential","sgnToText","split","decNeeded","tf","changeParser","InputObject_File","InputObject_Manual","console","RawData","WebWorker","TotalRows","TotalCols","Infinity","onChange","NoHeaders","FirstRow","Min","FirstCol","SingleCol","SkipEmptyRows","InputParser_Papa","InputParser_XLSX","InputParser_XLS","highlight","parseInt","LastCol","clean","cleanRow","header","ApplyToHeader","dataFound","previewRow","resetParsing","firstParse","setLimit","preview","stream","parsingConfig","abort","Start","Last","previewHeader","ErrorDetails","insertRow","Mapper","Required","Optional","Guess","first","search","here","inputs","warn","Parameters","inputTable","anchors","NoControls","showMapping","buttons","Validate","validate","Done","BackToImport","unshift","slice","guess","mappingArray","assign","Mapping","t","nodeName","parentElement","rowIndex","col","cellIndex","param","className","includes","previous","OnChange","column","rows","cells","Select","parameter","valid","plateCol","plate","wellCol","well","wellDefined","plateDefined","mapping","modeWellPlate","Mapper_PlateWell","Mapper_Plate","Mapper_Well","Mapper_Direct","output","Items","PlatesID","Column","LimitReached","scan","value","cleanValue","GlobalMax","GlobalMin","start","AreaName","FindAll","RangeIndexBase0","Pair","State","Txt","Html","plural","broken","RangeName","Broken","pair","hasItem","elt","DefPlateIndex","DefPlateName","splice","unpaired","paired","validArray","range","Editor","Tables","Areas","find","def","Definition","PlateIndex","All","sourceArray","O","RangeIndex","oldName","newName","rangeName","Pairing","Result","Pairs","results","ranges","Def","Auto","Ranges","Results","newSelect","ResultManager","draw","autoPairing","state","outerHTML","editPair","ctrl","Plates","NavBar","Lookup","register","Area","plateIndex","status","setDefPlate","pairing","PlateSelect","setLinkedPlate","rename","count","defID","Reporter","htmlHeader","Method","win","window","write","body","report","footer","openPage","k","key","keys","updated","Conc","combineConc","Tags","combineTags","flatConcNames","flatConcTags","allNames","uniqueIndex","uniqueNames","sort","join","controls","zFactor","combination","openReport","areas","conc","Grouped","R","ColumnOnly","layout","Hits","Layout","Definitions","D","Unit","Root","Shift","Invert","units","u","unit","WorkerGroup","Progress","Process","workerProcess","joinResults","checkChunkDone","nextChunk","MaxThread","navigator","hardwareConcurrency","ChunkSize","Max","Thread","Percent","CurrentRow","pause","resume","stop","processStatus","msg","percent","chunk","Workers","spawnWorker","postMessage","Pause","Resume","terminate","WorkerDone","blob","Blob","Worker","URL","createObjectURL","onmessage","onWorkerMessage","Paused","getElementById","file","super","size","Format","lastIndexOf","Help","delimiter","tab","entries","fromEntries","PapaConfig","worker","step","complete","Papa","assignOptions","parsingOptions","processRow","Sheet","SharedStrings","reader","FileReader","onerror","onload","ab","dv","DataView","getOffsets","cursor","getSheets","BIFFversion","getSharedStrings","readAsArrayBuffer","getUint16","SectorSize","dir","getUint32","DirStreamOffset","StreamSize","WorkbookSector","WorkbookOffset","read","end","byteLength","Sheets","newSheet","sheetOffset","sheetType","getUint8","td","TextDecoder","view","Uint8Array","decode","Offset","updateList","parseString","Str","sheet","wbOffset","wbSector","FAT","getFatArray","ordered","maxIndex","getInt32","temp","set","buffer","FATnb","sector","flags","fHighByte","fRichSt","ignored","Uint16Array","code","sst","self","Cursor","dataType","recLen","parsed","Row","Col","getFloat64","parseRK","More","bytes","fX100","num","exponent","mantissa","WBoffset","biff","BIFF","firstRow","lastRow","ceil","blocs","Blocs","FirstCellOffset","RowIndex","firstCellOffset","getRows","cell","cellRow","Buffer","SheetOffset","metaSheet","getMeta","initWorker","parseEnd","sheetAB","buildSheetAB","onmessageerror","message","ZIP","zip","DOMParser","async","str","xml","parseFromString","getElementsByTagName","sheets","attributes","sheetId","shared","inputParser","getSheetNames","chunkSize","MaxChunkSize","Position","LastRow","rowEnd","ColCount","colName","colIndex","valStart","remaining","JSZip","loadAsync","catch","fail","MinMax","scanMinMax","scanPreviewColumns","Interrupt","Custom","lines","Log","Plate","Factor","fillMissingElements","PlateCol","WellCol","Well","parseIndex","Rows","Cols","WellIndex","Resolved","plateNb"],"mappings":"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CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IACA,CAAA,IAAA,IAAA,GAAA,CAAA,EAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KACA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,EAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,EAAA,IAAA,KACA,CAAA,GAAA,IAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,EAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,EAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,EAAA,IAAA,KACA,CAAA,IAAA,IAAA,IAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,EAAA,KACA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,GAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,KAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,EAAA,GAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KAAA,CAAA,EAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,GAAA,IAAA,IAAA,CAAA,GAAA,IAAA,IAAA,CAAA,EAAA,IAAA,KACA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,IAAA,GAAA,KAAA,CAAA,IAAA,GAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,GAAA,KAAA,CAAA,GAAA,IAAA,IAAA,CAAA,IAAA,GAAA,KACA,CAAA,IAAA,EAAA,KAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,GAAA,IAAA,CAAA,EAAA,IAAA,GAAA,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","file":"shared.min.js","sourcesContent":["//**********************************************************************\n// FORM_COLOR - Form displaying a list of colors for the user to choose\n//**********************************************************************\nfunction Form_Color(I) { //I.Caller should be a LinkCtrl Object, or an object with setValue() and getValue() methods defined\n\tthis.Selected = \"white\";\n\tif(I && I.Caller) {this.Selected = I.Caller.getValue()}\n\t//var txt = \"<div>Colors available:</div>\";\n\tvar txt = \"\";\n\tCSSCOLORS.list().forEach(function(c) { //Append all available colors\n\t\ttxt += \"<div class=\\\"ColorBlock\\\" style=\\\"float: left; background-color: \" + c + \"\\\" title=\\\"\" + c + \"\\\"></div>\";\n\t});\n\ttxt += \"<div style=\\\"clear: both; padding-top: 10px; text-align: center\\\">Selected:&nbsp;\";\n\ttxt += \"<span id=\\\"Form_ColorSelected\\\" class=\\\"ColorBlock\\\" style=\\\"background-color: \" + this.Selected + \"\\\" title=\\\"\" + this.Selected + \"\\\">&nbsp;&nbsp;&nbsp;&nbsp;</span>\";\n\ttxt += \"</div>\";\n\tvar id = \"Form_Color\";\n\tForm.open({\n\t\tID: id,\n\t\tHTML: txt,\n\t\tTitle: \"Color Picker\",\n\t\tButtons: [\n\t\t\t{\n\t\t\t\tLabel: \"Ok\",\n\t\t\t\tTitle: \"Apply the selected color\",\n\t\t\t\tClick: function() {\n\t\t\t\t\tif(I) {\n\t\t\t\t\t\tvar color = this.Selected;\n\t\t\t\t\t\tif(I.Caller) {I.Caller.setValue(color)}\n\t\t\t\t\t\tif(I.after) {I.after(color)}\n\t\t\t\t\t}\n\t\t\t\t\tForm.close(id);\n\t\t\t\t}.bind(this),\n\t\t\t},\n\t\t\t{\n\t\t\t\tLabel: \"Cancel\",\n\t\t\t\tClick: function() {Form.close(id)}\n\t\t\t}\n\t\t],\n\t\tonInit: function() {\n\t\t\tvar span = GetId(\"Form_ColorSelected\");\n\t\t\tvar collection = document.getElementsByClassName(\"ColorBlock\");\n\t\t\tvar l = collection.length;\n\t\t\tfor(let i=0;i<l;i++) {\n\t\t\t\tcollection.item(i).addEventListener(\"click\", function(e) {\n\t\t\t\t\tvar c = e.target.style.backgroundColor;\n\t\t\t\t\tthis.Selected = c;\n\t\t\t\t\tspan.style.backgroundColor = c;\n\t\t\t\t\tspan.title = c;\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t}.bind(this),\n\t});\n}","//*******************************************************************************************\n// FORM_IMPORT - Form with options for the selection and parsing of files used to import data\n//*******************************************************************************************\nclass Form_Import {\n\tconstructor() {}\n\t//Static Methods\n\tstatic open(I) { //Open the form. Optional title can be supplied\n\t\tthis.init(I); //Initialize the class\n\t\tif(I.Single) {this.Multiple = false} //Single input mode\n\t\telse {this.Multiple = true}\n\t\tthis.Chain = I.Chain; //Tell the form not to reset after parsing is done, so that the user can come back on this form if needed\n\t\tthis.Controls.File.Multiple = this.Multiple;\n\t\tlet title = \"Data Import\";\n\t\tif(I && I.Title) {title = I.Title}\n\t\tForm.open({\n\t\t\tID: this.ID,\n\t\t\tHTML: this.html(),\n\t\t\tTitle: title,\n\t\t\tSize: 800,\n\t\t\tButtons: this.Buttons.Step1,\n\t\t\tonInit: function() {this.bindEvents()}.bind(this), //Initialize the LinkCtrl inputs\n\t\t\tonCancel: function() {this.cancel()}.bind(this),\n\t\t});\n\t\tif(I && I.OnClose) {this.OnClose = I.OnClose} //The function to run at closure. It will receive the parsed data as an array of structured objects in parameter\n\t\treturn this;\n\t}\n\tstatic init(I) { //Initialize internal (private) properties if not set\n\t\tif(this.Init) {return}\n\t\telse {\n\t\t\tlet id = \"Form_Import_\";\n\t\t\tlet index = 0;\n\t\t\tif(Form.Dialogs !== undefined) {index = Form.Dialogs} //Increment the index to the number of open dialogs, to guarantee unicity\n\t\t\tid = id + index + \"_\";\n\t\t\tthis.ID = id;\n\t\t\tthis.Anchors = {\n\t\t\t\tInput: id + \"_Input\",\n\t\t\t\tTable: id + \"_InputTable\",\n\t\t\t\tInputType: id + \"_InputType\",\n\t\t\t\t//InputOptions: id + \"_InputOptions\",\n\t\t\t\tInputSelection: id + \"_InputSelection\",\n\t\t\t\tParsing: id + \"_Parsing\",\n\t\t\t\tParser: id + \"_Parser\",\n\t\t\t\tParserOptions: id + \"_ParserOptions\",\n\t\t\t\tPreview: id + \"_Preview\",\n\t\t\t\tPreviewBox: id + \"_PreviewBox\",\n\t\t\t\tWaitMask: id + \"_WaitMask\",\n\t\t\t\tWaitMaskCurrent: id + \"_WaitMaskCurrent\",\n\t\t\t\tWaitMaskTotal: id + \"_WaitMaskTotal\",\n\t\t\t\tWaitMaskList: id + \"_WaitMaskList\",\n\t\t\t\tApplyToAll: id + \"_ApplyToAll\",\n\t\t\t\tButtons: id + \"Form_Footer\",\n\t\t\t}\n\t\t\tthis.Controls = {\n\t\t\t\tFile: LinkCtrl.new(\"File\", {ID: this.Anchors.Input, Default: \"\", Accept: \".txt,.csv,.xls,.xlsx\"}),\n\t\t\t\tManualName: LinkCtrl.new(\"Text\", {ID: this.Anchors.Input, Default: \"\", Label: \"Name\", /*NewLine: true,*/ Title: \"Type a name for your data here\"}),\n\t\t\t\tManual: LinkCtrl.new(\"TextArea\", {ID: this.Anchors.Input, Default: \"\", Preserve: true, Index: 1, Title: \"Type or paste your data here\"}),\n\t\t\t\tTable: new RespTable({ID: this.Anchors.Table, Fields: [\"Name\", \"Format\", \"Source\", \"Type\"], RowNumbers: true, Preserve: true, onSelect: function(S, oldS, index, oldIndex) {this.selectInput(index, oldIndex)}.bind(this)}),\n\t\t\t\tInputType: LinkCtrl.new(\"Radio\", {ID: this.Anchors.InputType, List: [\"From file(s)\", \"Manual input\"], Default: 0, ControlLeft: true, Change: function() {this.changeInputType()}.bind(this), Title: \"Type of input desired\"}),\n\t\t\t\tPreview: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Preview, Default: true, Label: \"Show\", NewLine: true, Change: function() {this.togglePreview()}.bind(this), Title: \"Tick to display a preview of the parsing results\"}),\n\t\t\t}\n\t\t\tthis.Buttons = { //Definitions of buttons used in the form\n\t\t\t\tStep1: [ //Form dialog, step 1\n\t\t\t\t\t{Label: \"Next\", Click: function() {this.next()}.bind(this)},\n\t\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {this.cancel()}.bind(this)}\n\t\t\t\t],\n\t\t\t\tStep2: [ //Form dialog, step 2\n\t\t\t\t\t{Label: \"Back\", Icon: {Type: \"Back\", Space: true}, Click: function() {this.back()}.bind(this)},\n\t\t\t\t\t{Label: \"Done\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() {this.done()}.bind(this)},\n\t\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {this.cancel()}.bind(this)}\n\t\t\t\t],\n\t\t\t\tApplyAll: LinkCtrl.new (\"Button\", {ID: this.Anchors.ApplyToAll, Label: \"Apply this config to all\", Click: function() {\n\t\t\t\t\tthis.applyConfigToAll();\n\t\t\t\t}.bind(this), Title: \"Apply the parsing configuration of this selected file to all the other files\"}),\n\t\t\t}\n\t\t\tthis.ButtonBar = LinkCtrl.new(\"ButtonBar\", {ID: this.Anchors.Buttons, Buttons: this.Buttons.Step2, Spacing: true});\n\t\t\tthis.Step = 1; //Initialize the form at its first step\n\t\t\tthis.Init = true;\n\t\t}\n\t\treturn this;\n\t}\n\tstatic bindEvents() { //Initialize the LinkCtrl inputs and dynamic behaviour to the elements of the form\n\t\tvar b = LinkCtrl.button({Label: \"Add\", Title: \"Add these inputs to the list of selected inputs\", Click: function() {this.addInput()}.bind(this)});\n\t\tGetId(this.Anchors.InputSelection).append(b); //Button to add the input to the table\n\t\tthis.Buttons.ApplyAll.init(); //Button to apply the same parsing config to all inputs\n\t\tthis.Controls.Table.init();\n\t\tthis.Controls.InputType.init().change(); //Trigger a change on init to append the correct html attached to the selected input\n\t}\n\tstatic changeInputType() { //Follows a change in the selected input type\n\t\tswitch(this.Controls.InputType.Selected) {\n\t\t\tcase \"From file(s)\": this.Controls.File.init(); break; //In case of file, simply init the LinkCtrl object\n\t\t\tcase \"Manual input\": //In this case, init two LinkCtrls and create buttons to insert a Tab and export the data\n\t\t\t\tthis.Controls.ManualName.init();\n\t\t\t\tlet bar = LinkCtrl.buttonBar([\n\t\t\t\t\t{Label: \"Insert Tab\", Click: function() {\n\t\t\t\t\t\tlet me = this.Controls.Manual;\n\t\t\t\t\t\tme.setValue(me.Value + \"\\t\");\n\t\t\t\t\t\tme.focus(); //Focus back on the textarea to facilitate typing\n\t\t\t\t\t}.bind(this), Title: \"Click to insert a Tabulation\"},\n\t\t\t\t\t{Label: \"Get as txt\", Click: function() {\n\t\t\t\t\t\tForm.download(this.Controls.Manual.getValue(), {FileName: \"Manual_input.txt\"});\n\t\t\t\t\t}.bind(this), Title: \"Click to download your manual input as a txt file\"},\n\t\t\t\t], true); //Set the buttons inline\n\t\t\t\tGetId(this.Anchors.Input).insertAdjacentHTML(\"beforeend\", \"&nbsp;\");\n\t\t\t\tGetId(this.Anchors.Input).insertAdjacentElement(\"beforeend\", bar);\n\t\t\t\tthis.Controls.Manual.init();\n\t\t\t\tbreak;\n\t\t\tdefault: break;\n\t\t}\n\t\treturn this;\n\t}\n\tstatic addInput() { //Add input to the input list\n\t\tlet T = this.Controls.Table;\n\t\tif(this.Multiple == false && T.Length > 0) {alert(\"Only one input allowed!\"); return this}\n\t\tswitch(this.Controls.InputType.Selected) {\n\t\t\tcase \"From file(s)\": //Add a file to the list of input\n\t\t\t\tlet fileList = this.Controls.File.getValue();\n\t\t\t\tlet l = fileList.length;\n\t\t\t\tfor(let i=0;i<l;i++) { //For each file. fileList is a file collection, not an array, so forEach doesn't work here\n\t\t\t\t\tlet f = InputObject.new(\"File\", fileList[i]);\n\t\t\t\t\tT.addRow(f);\n\t\t\t\t}\n\t\t\t\tthis.Controls.File.setValue([]); //Prepare for next import\n\t\t\t\tbreak;\n\t\t\tcase \"Manual input\": //Add manually entered data\n\t\t\t\tlet data = this.Controls.Manual.getValue();\n\t\t\t\tif(data.length > 0) { //Don't input empty values\n\t\t\t\t\tlet m = InputObject.new(\"Manual\", {Data: data, Name: this.Controls.ManualName.getValue()});\n\t\t\t\t\tT.addRow(m);\n\t\t\t\t\tthis.Controls.Manual.setValue(\"\"); //Reset the fields for next import\n\t\t\t\t\tthis.Controls.ManualName.setValue(\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: return this;\n\t\t}\n\t\tif(T.Selected.length == 0) {T.setValue([0])}\n\t\treturn this;\n\t}\n\tstatic selectInput(index, oldIndex) {\n\t\tif(index[0] == oldIndex[0]) {return}\n\t\tlet T = this.Controls.Table;\n\t\tlet input = T.Selected[0];\n\t\tif(input !== undefined && this.Step == 2) {\n\t\t\tthis.showParsingControls(input); //Show controls and init the parsing\n\t\t\tinput.InputParser.parse({Limit: input.Controls.Limit.Selected, Input: input});\n\t\t}\n\t\treturn this;\n\t}\n\tstatic showParsingControls(input) { //Initialize the parsing controls for the input passed. Internal use only\n\t\tthis.Controls.Preview.init(); //Preview show/hide control\n\t\tinput.Controls.Limit.init(); //Preview Limit control\n\t\tinput.Controls.Parser.init(); //Control for the parser selection\n\t\tinput.InputParser.init(); //Init the LinkCtrl options for the parser\n\t}\n\tstatic next() { //Next step in the form input form\n\t\tlet T = this.Controls.Table;\n\t\tif(T.Length == 0) {alert(\"No input selected!\"); return}\n\t\tT.hideControls(); //Hide input table controls\n\t\tthis.Step++;\n\t\tForm.replaceButtons(this.ID, [{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {this.close()}.bind(this)}]); //Remove next button\n\t\tthis.parsingStart(T.Array);\n\t\tlet input = T.Selected[0];\n\t\tif(input === undefined) { //No input selected: force selection of the first element. This can happen when going back to delete an item, then clicking next without selection\n\t\t\tT.setValue([0]);\n\t\t\tinput = T.Selected[0];\n\t\t}\n\t\tlet selected = T.SelectedIndices[0];\n\t\tlet promises = [];\n\t\tT.Array.forEach(function(a, i) { //For Each input, trigger a change to create a parser object and parse the file.\n\t\t\tlet noPrev = true;\n\t\t\tif(i == selected) {noPrev = false} //Only the selected input will need to prepare a preview\n\t\t\tpromises.push( //Start parsing of all inputs as asynchronous tasks (promises)\n\t\t\t\tthis.testParse(a, {\n\t\t\t\t\tIndex: i,\n\t\t\t\t\tNoPreview: noPrev,\n\t\t\t\t\tNoInit: true,\n\t\t\t\t\tStep: function(row, n, parser, inputIndex) {\n\t\t\t\t\t\tlet html = \"\";\n\t\t\t\t\t\tif(parser.FirstParsed == false) {html = \"(Pre-parsing) - \"}\n\t\t\t\t\t\tif(5000 * Math.round(n / 5000) - n == 0) { //Only once every 5000 rows to save FPS\n\t\t\t\t\t\t\tGetId(this.Anchors.WaitMaskList).children[inputIndex].children[1].innerHTML = html + n;\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this),\n\t\t\t\t\tComplete: function(n, inputIndex) {\n\t\t\t\t\t\tthis.parsingUp(inputIndex, n); \n\t\t\t\t\t}.bind(this),\n\t\t\t\t\tError: function(e, inputIndex) {\n\t\t\t\t\t\tthis.parsingError(inputIndex, e);\n\t\t\t\t\t}.bind(this),\n\t\t\t\t}) //No ; here, you are within a push idiot!\n\t\t\t);\n\t\t}, this);\n\t\tPromise.all(promises).then(function() { //After all files have been parsed, swith to next tab\n\t\t\tthis.parsingDone();\n\t\t\tthis.showParsingControls(input);\n\t\t\tT.update(); //Update the table to reflect any file in error\n\t\t\tthis.ButtonBar.init(); //Replace the button with step 2 buttons\n\t\t}.bind(this));\n\t}\n\tstatic back() { //A step backward\n\t\tthis.Step--;\n\t\tGetId(this.Anchors.InputSelection).style.display = \"block\";\n\t\tGetId(this.Anchors.Parsing).style.display = \"none\";\n\t\tthis.Controls.Table.showControls();\n\t\tForm.replaceButtons(this.ID, this.Buttons.Step1);\n\t}\n\tstatic togglePreview() { //Toggle the visibility of the preview box\n\t\tvar bool = this.Controls.Preview.getValue();\n\t\tif(bool) {GetId(this.Anchors.PreviewBox).style.display = \"block\"}\n\t\telse {GetId(this.Anchors.PreviewBox).style.display = \"none\"}\n\t}\n\tstatic testParse(input, I) { //A promise that will complete with the results of the parsing for the given input\n\t\treturn new Promise(function(resolve) {\n\t\t\tinput.Controls.Parser.change(undefined, {\n\t\t\t\tNoInit: I.NoInit,\n\t\t\t\tNoPreview: I.NoPreview,\n\t\t\t\tStep: function(row, n, parser) { //Function running on each step\n\t\t\t\t\tif(I.Step) {\n\t\t\t\t\t\tI.Step(row, n, parser, I.Index);\n\t\t\t\t\t}\n\t\t\t\t}.bind(this),\n\t\t\t\tComplete: function(n) { //when the parsing is completed, update the file counter and resolve\n\t\t\t\t\tif(I.Complete) {\n\t\t\t\t\t\tI.Complete(n, I.Index);\n\t\t\t\t\t}\n\t\t\t\t\tinput.Status = undefined;\n\t\t\t\t\tresolve();\n\t\t\t\t}.bind(this),\n\t\t\t\tError: function(e) { //Catch the error here\n\t\t\t\t\tif(I.Error) {\n\t\t\t\t\t\tI.Error(e, I.Index);\n\t\t\t\t\t}\n\t\t\t\t\tinput.Status = \"Error\";\n\t\t\t\t\tresolve();\n\t\t\t\t}.bind(this), \n\t\t\t});\n\t\t}.bind(this));\n\t}\n\tstatic parsingStart(array) { //Display a wait message for the array of input\n\t\tthis.ParsedInputs = 0;\n\t\tlet n = array.length;\n\t\tGetId(this.Anchors.WaitMaskCurrent).innerHTML = 0;\n\t\tGetId(this.Anchors.WaitMaskTotal).innerHTML = n;\n\t\tlet list = \"\";\n\t\tfor(let i=0;i<n;i++) {\n\t\t\tlist += \"<li><span>\" + array[i].Name + \": </span><span>0</span><span> Rows found</span></li>\";\n\t\t}\n\t\tGetId(this.Anchors.WaitMaskList).innerHTML = list;\n\t\tlet mask = GetId(this.Anchors.WaitMask);\n\t\tlet childs = mask.nextElementSibling.children;\n\t\tlet h = Math.max(childs[0].offsetHeight, childs[1].offsetHeight) + \"px\"; //Adjust the size of the mask, so that it fits on all the content\n\t\tlet w = mask.nextElementSibling.offsetWidth + \"px\";\n\t\tmask.style.height = h;\n\t\tmask.style.width = w;\n\t\tmask.style.display = \"block\";\n\t}\n\tstatic parsingUp(index, nbRows) { //One more file parsed\n\t\tthis.ParsedInputs++;\n\t\tGetId(this.Anchors.WaitMaskCurrent).innerHTML = this.ParsedInputs;\n\t\tlet list = GetId(this.Anchors.WaitMaskList).children[index];\n\t\tlist.children[1].innerHTML = nbRows;\n\t\tlist.insertAdjacentHTML(\"beforeend\", \". DONE\");\n\t\tlist.style.color = \"green\";\n\t}\n\tstatic parsingError(index, error) { //An error occured during file parsing\n\t\tlet list = GetId(this.Anchors.WaitMaskList).children[index];\n\t\tlet name = list.children[0].innerHTML;\n\t\tlist.innerHTML = \"<span>\" + name + \"ERROR</span>\";\n\t\tlist.style.color = \"red\";\n\t}\n\tstatic parsingDone() { //Display controls\n\t\tGetId(this.Anchors.WaitMask).style.display = \"none\";\n\t\tGetId(this.Anchors.InputSelection).style.display = \"none\";\n\t\tGetId(this.Anchors.Parsing).style.display = \"block\";\n\t\tthis.togglePreview();\n\t}\n\tstatic done() { //Done\n\t\tlet data = [];\n\t\tlet onError = false;\n\t\tthis.Controls.Table.Array.forEach(function(input) { //Loop the input objects\n\t\t\tlet parser = input.InputParser;\n\t\t\tif(input.Status !== undefined && input.Status == \"Error\") {onError = true}\n\t\t\telse { //Push only valid inputs\n\t\t\t\tdata.push({\n\t\t\t\t\tSource: input.Source,\n\t\t\t\t\tName: input.Name,\n\t\t\t\t\tSize: parser.SelectedRows + \" Rows &times; \" + parser.SelectedCols + \" Cols\",\n\t\t\t\t\tOther: parser.Info,\n\t\t\t\t\tHeaders: parser.Headers,\n\t\t\t\t\tParser: parser,\n\t\t\t\t\tInput: input,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tif(onError) { //At least one input is in error and won't be exported. Ask confirmation\n\t\t\tForm.open({\n\t\t\t\tID: this.ID + \"_Confirm\",\n\t\t\t\tHTML: \"<p style=\\\"color: tomato; padding:0em 1em\\\">Inputs on error will not be exported. Are you sure you want to continue?</p>\",\n\t\t\t\tTitle: \"Confirm export\",\n\t\t\t\tButtons: [\n\t\t\t\t\t{Label: \"Ok\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() {\n\t\t\t\t\t\tForm.close(this.ID + \"_Confirm\"); //Close the confirmation popup\n\t\t\t\t\t\tthis.close(data); //Close the Form_Import\n\t\t\t\t\t}.bind(this)},\n\t\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {Form.close(this.ID + \"_Confirm\")}.bind(this)}, //Just close the confirmation popup\n\t\t\t\t],\n\t\t\t\tonCancel: function() {Form.close(this.ID + \"_Confirm\")}.bind(this), //Similar to cancel\n\t\t\t});\n\t\t}\n\t\telse {this.close(data)} //Close straight\n\t}\n\tstatic applyConfigToAll() {\n\t\tlet T = this.Controls.Table;\n\t\tlet input = T.Selected[0];\n\t\tif(input === undefined) {return} //Nothing to do if no input selected, but in practice this should not happen\n\t\tlet m = T.SelectedIndices[0];\n\t\tlet parserType = input.Controls.Parser.getValue(); //Index of the Parser in the dropdown list, for the selected input\n\t\tlet options = Object.values(input.InputParser.Options); //Options for the parser of the selected input\n\t\tlet array = T.Array.toSpliced(m, 1); //toSpliced do not change the initial array, remove 1 element starting at the selected index\n\t\tthis.parsingStart(array); //Block the form while files are parsing\n\t\tthis.ButtonBar.disable() ;\n\t\tlet promises = [];\n\t\tarray.forEach(function(a, i) {\n\t\t\ta.Controls.Parser.setValue(parserType).change(undefined, {NoParse: true}); //Start by silently applying the same parser as the target, without parsing\n\t\t\tObject.values(a.InputParser.Options).forEach(function(o, j) { //Copy the values for the options\n\t\t\t\to.setValue(options[j].getValue());\n\t\t\t});\n\t\t\tpromises.push(\n\t\t\t\tnew Promise(function(resolve, reject) {\n\t\t\t\t\ta.InputParser.parse({ //Parse the file using the new parser and configuration\n\t\t\t\t\t\tNoPreview: true, //Parse without preview\n\t\t\t\t\t\tStep: function(row, n, parser) {\n\t\t\t\t\t\t\tif(5000 * Math.round(n / 5000) - n == 0) { //Only once every 5000 rows to save FPS\n\t\t\t\t\t\t\t\tGetId(this.Anchors.WaitMaskList).children[i].children[1].innerHTML = n;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.bind(this),\n\t\t\t\t\t\tComplete: function(n) { //Update status of the input on complete or on error\n\t\t\t\t\t\t\tthis.parsingUp(i, n); //Update file parsing status\n\t\t\t\t\t\t\ta.Status = undefined;\n\t\t\t\t\t\t\tT.update();\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}.bind(this),\n\t\t\t\t\t\tError: function(e) { //Update error status\n\t\t\t\t\t\t\tthis.parsingError(i, e);\n\t\t\t\t\t\t\ta.Status = \"Error\";\n\t\t\t\t\t\t\tT.update();\n\t\t\t\t\t\t\tresolve(); //Error is handled internally, no need to reject here\n\t\t\t\t\t\t}.bind(this),\n\t\t\t\t\t})\n\t\t\t\t}.bind(this)) //No ; here, you are within a push idiot!\n\t\t\t);\n\t\t}, this);\n\t\tPromise.all(promises).then(function() { //After all files have been parsed, release the form\n\t\t\tthis.parsingDone();\n\t\t\tthis.ButtonBar.enable();\n\t\t}.bind(this));\n\t}\n\tstatic reset() { //Reset prior to closure\n\t\tthis.Controls.Table.empty(); //Empty the input list\n\t\tthis.Step = 1; //Move back to step 1\n\t\treturn this;\n\t}\n\tstatic cancel() { //Cancelling import of data: reset the form and close it without calling OnClose method\n\t\tthis.reset();\n\t\tForm.close(this.ID);\n\t}\n\tstatic close(data) { //Close the form. Contrary to cancel, this will call OnClose normally and keep the form open if chain is needed\n\t\tif(this.OnClose) {this.OnClose(data)} //Send data to the close function\n\t\tif(this.Chain === undefined || this.Chain == false) { //Do not reset unless this form is not chained with another\n\t\t\tthis.cancel();\n\t\t}\n\t\treturn this;\n\t}\n\tstatic html() { //The html of the form\n\t\tvar html = \"\";\n\t\thtml += \"<div id=\" + this.Anchors.WaitMask + \" class=\\\"Form_Import_DisableMask\\\">\";\n\t\t\thtml += \"<p><b>Parsing in progress, Please wait...</b></p>\";\n\t\t\thtml += \"<p><i>Parsed: <span id=\" + this.Anchors.WaitMaskCurrent + \">0</span> / <span id=\" + this.Anchors.WaitMaskTotal + \"></span></i></p>\";\n\t\t\thtml += \"<ul id=\" + this.Anchors.WaitMaskList + \"></ul>\";\n\t\thtml += \"</div>\";\n\t\thtml += \"<div>\"; //Main body of the form\n\t\t\thtml += \"<div class=\\\"Form_Import_Left\\\">\";\n\t\t\t\thtml += \"<fieldset><legend>Inputs selected</legend>\"; //Input list\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Table + \"\\\" style=\\\"width: 320px; overflow: auto\\\"></div>\";\n\t\t\t\thtml += \"</fieldset>\"; \n\t\t\thtml += \"</div>\";\n\t\t\thtml += \"<div class=\\\"Form_Import_Right\\\">\";\n\t\t\t\thtml += \"<fieldset id=\\\"\" + this.Anchors.InputSelection + \"\\\"><legend>Input selection</legend>\"; //Input field\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.InputType + \"\\\"></div>\";\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Input + \"\\\"></div>\";\n\t\t\t\thtml += \"</fieldset>\";\n\t\t\t\thtml += \"<fieldset id=\\\"\" + this.Anchors.Parsing + \"\\\" style=\\\"display: none\\\"><legend>Parsing</legend>\"; //Parsing field, hidden at the first place\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Parser + \"\\\" style=\\\"margin-bottom: 10px;\\\"></div>\";\n\t\t\t\t\thtml += \"<fieldset style=\\\"float: left;\\\"><legend><i>Options</i></legend>\";\n\t\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.ParserOptions + \"\\\"></div>\";\n\t\t\t\t\thtml += \"</fieldset>\";\n\t\t\t\t\thtml += \"<fieldset><legend><i>Preview</i></legend>\";\n\t\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Preview + \"\\\"></div>\"; //Control checkbox\n\t\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.PreviewBox + \"\\\" class=\\\"Form_Import_Preview\\\"></div>\"; //Preview \n\t\t\t\t\thtml += \"</fieldset>\";\n\t\t\t\t\t\n\t\t\t\t\thtml += \"<div style=\\\"clear: both\\\" id=\\\"\" + this.Anchors.ApplyToAll + \"\\\">\";\n\t\t\t\t\t//html += {Label: \"Next\", Click: function() {this.next()}.bind(this)}\n\t\t\t\t\thtml += \"</div>\"\n\t\t\t\t\t\n\t\t\t\thtml += \"</fieldset>\";\n\t\t\thtml += \"</div>\";\n\t\thtml += \"</div>\";\n\t\treturn html;\n\t}\n}","//****************************************************\n// CSSCOLORS - Simple object for listing of css colors\n//****************************************************\nclass CSSCOLORS {\n\tconstructor() {}\n\t//Static methods\n\tstatic list(type) {\n\t\tswitch(type) {\n\t\t\tcase \"RGB\": return [ //RGB values\n\t\t\t\t[135,206,250],[144,238,144],[255,182,193],[221,160,221],[240,230,140],[211,211,211],[255,255,240],[224,255,255],[255,240,245],[127,255,212],\n\t\t\t\t[255,218,185],[176,224,230],[176,196,222],[255,160,122],[169,169,169],[218,112,214],[255,255,224],[250,250,210],[255,239,213],[173,255, 47],\n\t\t\t\t[255,255,  0],[  0,255,255],[255,228,181],[102,205,170],[240,255,255],[240,128,128],[245,255,250],[255,192,203],[188,143,143],[255,250,205],\n\t\t\t\t[127,255,  0],[255,250,240],[255,228,196],[255,250,250],[255,255,255],[152,251,152],[238,232,170],[220,220,220],[216,191,216],[ 64,224,208],\n\t\t\t\t[248,248,255],[175,238,238],[240,255,240],[255,248,220],[245,222,179],[  0,255,  0],[240,248,255],[124,252,  0],[255,215,  0],[255,245,238],\n\t\t\t\t[230,230,250],[245,245,245],[173,216,230],[210,180,140],[253,245,230],[250,128,114],[ 32,178,170],[245,245,220],[255,140,  0],[  0,191,255],\n\t\t\t\t[ 50,205, 50],[255,235,205],[  0,250,154],[135,206,235],[250,240,230],[192,192,192],[154,205, 50],[250,235,215],[189,183,107],[255,105,180],\n\t\t\t\t[218,165, 32],[255,228,225],[255,222,173],[  0,255,127],[222,184,135],[255,165,  0],[238,130,238],[143,188,143],[244,164, 96],[  0,206,209],\n\t\t\t\t[255,127, 80],[ 60,179,113],[233,150,122],[ 72,209,204],[255, 99, 71],[100,149,237],[205,133, 63],[ 95,158,160],[219,112,147],[255,  0,255],\n\t\t\t\t[ 30,144,255],[184,134, 11],[255, 69,  0],[210,105, 30],[255, 20,147],[119,136,153],[147,112,219],[107,142, 35],[186, 85,211],[128,128,128],\n\t\t\t\t[205, 92, 92],[255,  0,  0],[112,128,144],[ 70,130,180],[  0,139,139],[123,104,238],[128,128,  0],[ 46,139, 87],[ 34,139, 34],[  0,128,128],\n\t\t\t\t[ 65,105,225],[220, 20, 60],[  0,128,  0],[106, 90,205],[199, 21,133],[105,105,105],[160, 82, 45],[153, 50,204],[ 85,107, 47],[138, 43,226],\n\t\t\t\t[148,  0,211],[178, 34, 34],[165, 42, 42],[139, 69, 19],[  0,100,  0],[139,  0,139],[  0,  0,255],[ 47, 79, 79],[ 72, 61,139],[128,  0,128],\n\t\t\t\t[139,  0,  0],[128,  0,  0],[  0,  0,205],[ 75,  0,130],[ 25, 25,112],[  0,  0,139],[  0,  0,128],[  0,  0,  0]\n\t\t\t]\n\t\t\tcase \"RGBSimple\": return [\n\t\t\t\t[  0,  0,255],[  0,128,  0],[128,  0,  0],[255,165,  0],[238,130,238],[128,128,  0],[128,  0,128],[  0,139,139],[255,  0,  0],[128,128,128],\n\t\t\t\t[255,  0,255],[ 70,130,180],[154,205, 50],[250,128,114],[ 72, 61,139],[  0,  0,  0]\n\t\t\t]\n\t\t\tcase \"Hexa\": return [ //Corresponding hexadecimal values\n\t\t\t\t\"87CEFA\",\"90EE90\",\"FFB6C1\",\"DDA0DD\",\"F0E68C\",\"D3D3D3\",\"FFFFF0\",\"E0FFFF\",\"FFF0F5\",\"7FFFD4\",\"FFDAB9\",\"B0E0E6\",\"B0C4DE\",\"FFA07A\",\"A9A9A9\",\"DA70D6\",\"FFFFE0\",\"FAFAD2\",\"FFEFD5\",\"ADFF2F\",\n\t\t\t\t\"FFFF00\",\"00FFFF\",\"FFE4B5\",\"66CDAA\",\"F0FFFF\",\"F08080\",\"F5FFFA\",\"FFC0CB\",\"BC8F8F\",\"FFFACD\",\"7FFF00\",\"FFFAF0\",\"FFE4C4\",\"FFFAFA\",\"FFFFFF\",\"98FB98\",\"EEE8AA\",\"DCDCDC\",\"D8BFD8\",\"40E0D0\",\n\t\t\t\t\"F8F8FF\",\"AFEEEE\",\"F0FFF0\",\"FFF8DC\",\"F5DEB3\",\"00FF00\",\"F0F8FF\",\"7CFC00\",\"FFD700\",\"FFF5EE\",\"E6E6FA\",\"F5F5F5\",\"ADD8E6\",\"D2B48C\",\"FDF5E6\",\"FA8072\",\"20B2AA\",\"F5F5DC\",\"FF8C00\",\"00BFFF\",\n\t\t\t\t\"32CD32\",\"FFEBCD\",\"00FA9A\",\"87CEEB\",\"FAF0E6\",\"C0C0C0\",\"9ACD32\",\"FAEBD7\",\"BDB76B\",\"FF69B4\",\"DAA520\",\"FFE4E1\",\"FFDEAD\",\"00FF7F\",\"DEB887\",\"FFA500\",\"EE82EE\",\"8FBC8F\",\"F4A460\",\"00CED1\",\n\t\t\t\t\"FF7F50\",\"3CB371\",\"E9967A\",\"48D1CC\",\"FF6347\",\"6495ED\",\"CD853F\",\"5F9EA0\",\"DB7093\",\"FF00FF\",\"1E90FF\",\"B8860B\",\"FF4500\",\"D2691E\",\"FF1493\",\"778899\",\"9370DB\",\"6B8E23\",\"BA55D3\",\"808080\",\n\t\t\t\t\"CD5C5C\",\"FF0000\",\"708090\",\"4682B4\",\"008B8B\",\"7B68EE\",\"808000\",\"2E8B57\",\"228B22\",\"008080\",\"4169E1\",\"DC143C\",\"008000\",\"6A5ACD\",\"C71585\",\"696969\",\"A0522D\",\"9932CC\",\"556B2F\",\"8A2BE2\",\n\t\t\t\t\"9400D3\",\"B22222\",\"A52A2A\",\"8B4513\",\"006400\",\"8B008B\",\"0000FF\",\"2F4F4F\",\"483D8B\",\"800080\",\"8B0000\",\"800000\",\"0000CD\",\"4B0082\",\"191970\",\"00008B\",\"000080\",\"000000\"\n\t\t\t];\n\t\t\tcase \"HexaSimple\": return [\n\t\t\t\t\"0000FF\",\"008000\",\"800000\",\"FFA500\",\"EE82EE\",\"808000\",\"800080\",\"008B8B\",\"FF0000\",\"808080\",\"FF00FF\",\"4682B4\",\"9ACD32\",\"FA8072\",\"483D8B\",\"000000\"\n\t\t\t];\n\t\t\tcase \"Simple\": return [ //Alternative array of 16 unique, css lvl3, shuffled basic colors\n\t\t\t\t\"blue\",\"green\",\"maroon\",\"orange\",\"violet\",\"olive\",\"purple\",\"darkcyan\",\"red\",\"gray\",\"magenta\",\"steelblue\",\"yellowgreen\",\"salmon\",\"darkslateblue\",\"black\"\n\t\t\t];\n\t\t\tdefault: return [ //Array of 138 unique, css lvl3, shuffled color names\n\t\t\t\t\"lightskyblue\",\"lightgreen\",\"lightpink\",\"plum\",\"khaki\",\"lightgray\",\"ivory\",\"lightcyan\",\"lavenderblush\",\"aquamarine\",\"peachpuff\",\"powderblue\",\"lightsteelblue\",\"lightsalmon\",\"darkgray\",\"orchid\",\"lightyellow\",\"lightgoldenrodyellow\",\"papayawhip\",\"greenyellow\",\n\t\t\t\t\"yellow\",\"cyan\",\"moccasin\",\"mediumaquamarine\",\"azure\",\"lightcoral\",\"mintcream\",\"pink\",\"rosybrown\",\"lemonchiffon\",\"chartreuse\",\"floralwhite\",\"bisque\",\"snow\",\"white\",\"palegreen\",\"palegoldenrod\",\"gainsboro\",\"thistle\",\"turquoise\",\n\t\t\t\t\"ghostwhite\",\"paleturquoise\",\"honeydew\",\"cornsilk\",\"wheat\",\"lime\",\"aliceblue\",\"lawngreen\",\"gold\",\"seashell\",\"lavender\",\"whitesmoke\",\"lightblue\",\"tan\",\"oldlace\",\"salmon\",\"lightseagreen\",\"beige\",\"darkorange\",\"deepskyblue\",\n\t\t\t\t\"limegreen\",\"blanchedalmond\",\"mediumspringgreen\",\"skyblue\",\"linen\",\"silver\",\"yellowgreen\",\"antiquewhite\",\"darkkhaki\",\"hotpink\",\"goldenrod\",\"mistyrose\",\"navajowhite\",\"springgreen\",\"burlywood\",\"orange\",\"violet\",\"darkseagreen\",\"sandybrown\",\"darkturquoise\",\n\t\t\t\t\"coral\",\"mediumseagreen\",\"darksalmon\",\"mediumturquoise\",\"tomato\",\"cornflowerblue\",\"peru\",\"cadetblue\",\"palevioletred\",\"magenta\",\"dodgerblue\",\"darkgoldenrod\",\"orangered\",\"chocolate\",\"deeppink\",\"lightslategray\",\"mediumpurple\",\"olivedrab\",\"mediumorchid\",\"gray\",\n\t\t\t\t\"indianred\",\"red\",\"slategray\",\"steelblue\",\"darkcyan\",\"mediumslateblue\",\"olive\",\"seagreen\",\"forestgreen\",\"teal\",\"royalblue\",\"crimson\",\"green\",\"slateblue\",\"mediumvioletred\",\"dimgray\",\"sienna\",\"darkorchid\",\"darkolivegreen\",\"blueviolet\",\n\t\t\t\t\"darkviolet\",\"firebrick\",\"brown\",\"saddlebrown\",\"darkgreen\",\"darkmagenta\",\"blue\",\"darkslategray\",\"darkslateblue\",\"purple\",\"darkred\",\"maroon\",\"mediumblue\",\"indigo\",\"midnightblue\",\"darkblue\",\"navy\",\"black\"\n\t\t\t];\n\t\t}\n\t}\n\tstatic cutOff(I) { //The cutoff value to determine black/white font\n\t\tif(I && I.Luminescence) {return 0.17913} //Higher: black; Lower: white; this threshold ensures highest contrast ratios (min 4.58)\n\t\treturn 109; //Indices 1 to 109 = black font, higher = white font\n\t}\n\tstatic fetch(i, type) { //Return the color corresponding to index i\n\t\tvar source = this.list(type);\n\t\tvar l = source.length;\n\t\treturn source[i%l];\n\t}\n\tstatic fetchIndex(color, type) { //Return the index corresponding to the color name\n\t\tvar source = this.list(type);\n\t\treturn source.findIndex(function(c) {return c == color});\n\t}\n\tstatic fetchRGB(color, returnAsTxt) { //Return the rgb color corresponding to the color name provided. Specify in options the list and whether to return as an array of three numbers [R, G, B] or a css-compatible text string\n\t\tlet source = this.list(\"RGB\");\n\t\tlet index = this.fetchIndex(color);\n\t\tlet out = source[index];\n\t\tif(returnAsTxt) {return \"rgb(\" + out[0] + \",\" + out[1] + \",\" + out[2] + \")\"} //CSS-compatible string for rgb color\n\t\telse {return out} //Return the array\n\t}\n\tstatic font(name, type) { //Return the font color for the color name provided, within the desired list\n\t\tif(type !== undefined && type == \"RGB_Unnamed\") { //For colors without names (generic rgb)\n\t\t\tlet rgb = name.match(/\\d+/g); //Creates an array of RGB values out of the string\n\t\t\tlet corr = rgb.map(function(v) { //Compute RGB to determine color luminance, see https://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\t\t\tlet c = v/255;\n\t\t\t\tif(c <= 0.03928) {return c / 12.92}\n\t\t\t\telse {return Math.pow((c + 0.055) / 1.055, 2.4)}\n\t\t\t});\n\t\t\tlet L = 0.2126 * corr[0] + 0.7152 * corr[1] + 0.0722 * corr[2];\n\t\t\tif(L < this.cutOff({Luminescence: true})) {return \"white\"}\n\t\t\telse {return \"black\"}\n\t\t}\n\t\tlet source = this.list(type);\n\t\tlet index = source.findIndex(function(c) {return (c == name)});\n\t\tif(index > -1) {\n\t\t\tlet cut = this.cutOff();\n\t\t\tif(index < cut) {return \"black\"}\n\t\t\telse {return \"white\"}\n\t\t}\n\t\telse return \"black\"; //Default value if the color is not found in the list\n\t}\n\tstatic heatmap(c, min, max, colors) { //Return the heatmap color for the value c, normalized between min and max, following rgb color gradient given as 2d array [min[R, G, B], middle[R, G, B], max[R, G, B]]\n\t\tif(min == max) {return \"rgb(\" + colors[1][0] + \", \" + colors[1][1] + \", \" + colors[1][2] + \")\"} //Only one value, return the middle color\n\t\tif(c <= min) {c = min} \n\t\tif(c >= max) {c = max}\n\t\tc = (c - min) / (max - min); //normalize value\n\t\tif(c == 0.5) {return \"rgb(\" + colors[1][0] + \", \" + colors[1][1] + \", \" + colors[1][2] + \")\"} //Easy\n\t\tif(c < 0.5) { //First part of the gradient\n\t\t\tvar r = colors[0][0] + (colors[1][0] - colors[0][0]) * 2 * c;\n\t\t\tvar g = colors[0][1] + (colors[1][1] - colors[0][1]) * 2 * c;\n\t\t\tvar b = colors[0][2] + (colors[1][2] - colors[0][2]) * 2 * c;\n\t\t}\n\t\tif(c > 0.5) { //Second part of the gradient\n\t\t\tvar r = colors[1][0] + (colors[2][0] - colors[1][0]) * 2 * (c - 0.5);\n\t\t\tvar g = colors[1][1] + (colors[2][1] - colors[1][1]) * 2 * (c - 0.5);\n\t\t\tvar b = colors[1][2] + (colors[2][2] - colors[1][2]) * 2 * (c - 0.5);\n\t\t}\n\t\treturn \"rgb(\" + Math.round(r) + \", \" + Math.round(g) + \", \" + Math.round(b) + \")\";\n\t}\n\tstatic HMtemplates() { //Return an array of array of colors to be used as template for 3-coloured heatmaps\n\t\treturn [ //Array of Low-Medium-High colors to use as templates\n\t\t\t[\"lightblue\", \"white\", \"tomato\"],\n\t\t\t[\"blue\", \"white\", \"red\"],\n\t\t\t[\"lightgreen\", \"khaki\", \"tomato\"],\n\t\t\t[\"lightgreen\", \"white\", \"tomato\"],\n\t\t\t[\"green\", \"black\", \"red\"],\n\t\t\t[\"black\", \"yellow\", \"white\"],\n\t\t\t[\"black\", \"blue\", \"white\"],\n\t\t];\n\t}\n\t/*static font(i) { //Return the font color for the color of index i from the full list\n\t\tvar cut = this.cutOff();\n\t\tvar index = i % cut;\n\t\tif(index < cut) {return \"black\"}\n\t\telse {return \"white\"}\n\t}*/\n\t/*static hexa(name, I) { //Return the hexadecimal value corresponding to the color name provided\n\t\tvar out = \"\";\n\t\tif(I && I.Sharp) {out += \"#\"} //Add the sharp if needed\n\t\tif(I && I.Simple) {\n\t\t\tvar source = this.ListSimple;\n\t\t\tvar target = this.HexaSimple;\n\t\t}\n\t\telse {\n\t\t\tvar source = this.List;\n\t\t\tvar target = this.Hexa;\n\t\t}\n\t\tvar i = 0;\n\t\tvar l = source.length;\n\t\twhile(i<l) {\n\t\t\tif(source[i] == name) {return out + target[i]}\n\t\t\ti++\n\t\t}\n\t\treturn out + \"000000\"; //black is returned as default if nothing match the name provided\n\t}*/\n}","//******************************************************************************************************\n// COORDINATE object - Object holding the values for a single point, along a given coordinate in a graph\n//******************************************************************************************************\nclass Coordinate {\n\tconstructor(values) {\n\t\tthis.Values = values; //Values for this coordinate, as an array of elements. At least one element should be there, to define a valid point. Elements can be numbers or array of numbers\n\t\tthis.Excluded = Array(this.Values.length).fill(false); //To locate points that are excluded\n\t\tthis.Numeric = this.Values.map(function(v) { //An array of booleans indicating if the values are numerical or text\n\t\t\tif(v instanceof Array) {return v.reduce(function(acc, val) {return acc || Decimal.isNumeric(val)}, false)} //At least one valid value required to be considered numeric\n\t\t\telse {return Decimal.isNumeric(v)}\n\t\t});\n\t\treturn this;\n\t}\n\t//Static methods\n\tstatic exclude(coord, index) { //Exclude the data at the index given for the coordinate passed\n\t\tcoord.Excluded[index] = true;\n\t}\n\tstatic excluded(coord) { //Tell whether the coordinate should be considered excluded, which is true when all the data it contains are excluded\n\t\treturn coord.Excluded.reduce(function(acc, val) {\n\t\t\treturn acc && val;\n\t\t}, true);\n\t}\n\tstatic value(c, index) { //Return the value at index i for the coordinate\n\t\tlet val = c.Values[index];\n\t\tif(val instanceof Array) { //An array of values, return the average only\n\t\t\treturn Coordinate.statValue(val).Average; //Will be undefined if no valid values to build an average\n\t\t}\n\t\telse { //Single value, return as is\n\t\t\treturn val;\n\t\t}\n\t}\n\tstatic statValue(val) { //Compute the stats for a single value of the Values array\n\t\tif(Array.isArray(val)) { //An array of values\n\t\t\tlet l = val.length; //Total number of values in the array\n\t\t\tlet flat = val.map(function(x) { //Flatten objects inside the array\n\t\t\t\tif(x!== undefined && x!== null && x.Value !== undefined) {return x.Value}\n\t\t\t\treturn x;\n\t\t\t});\n\t\t\tlet v = flat.filter(function(x) { //Then get the array of numerical elements only\n\t\t\t\treturn Decimal.isNumeric(x);\n\t\t\t});\n\t\t\tlet n = v.length; //Total number of numerical values\n\t\t\tif(n == 0) {return {N: 0, Total: l} } //No values means no more work to do\n\t\t\tif(n == 1) {return {N: 1, Average: v[0], Total: l}} //Only one value means nothing else to do\n\t\t\tlet total = v.reduce(function(acc, cur) {return acc + cur}, 0);\n\t\t\tlet avg = total / n; //Average value\n\t\t\tlet sumVariance = v.reduce(function(acc, cur) {\n\t\t\t\treturn acc + Math.pow(cur - avg, 2);\n\t\t\t}, 0);\n\t\t\tlet SD = Math.sqrt(sumVariance / n);\n\t\t\treturn {N: n, Average: avg, SD: SD, CV: 100 * SD / avg, Total: l}\n\t\t}\n\t\telse { //Just one value\n\t\t\treturn {N: 1, Average: val, Total: 1}\n\t\t}\n\t}\n\t/*static flatten(c) { //Flatten the Values array of the coordinate into a single, 1D array containing only numerical values\n\t\tlet out = c.Values.reduce(function(acc, cur, i) { //Flatten the 2D array of values into a flat 1D array\n\t\t\tif(c.Excluded[i] === false && c.Numeric[i] === true) {return acc.concat(cur)}\n\t\t\telse {return acc}\n\t\t}, []);\n\t\tout = out.filter(function(v, i) { //Get the array of numerical elements only\n\t\t\treturn (Decimal.isNumeric(v));\n\t\t});\n\t\treturn out;\n\t}\n\tstatic stats(c) { //Compute the stats for the coordinate object passed and return them as a structured object.\n\t\t//let val = c.Values.filter(function(v, i) { //Get the array of numerical elements only\n\t\t//\treturn (c.Excluded[i] === false && c.Numeric[i] === true);\n\t\t//});\n\t\tlet val = Coordinate.flatten(c);\n\t\tlet n = val.length; //Number of numerical values\n\t\tif(n == 0) {return {N: 0} } //No values means no more work to do\n\t\tlet total = val.reduce(function(acc, cur) {return acc + cur}, 0);\n\t\tif(n == 1) {return {N: 1, Average: total}} //Only one value means nothing else to do\n\t\tlet avg = total / n; //Average value\n\t\tlet sumVariance = val.reduce(function(acc, cur) {\n\t\t\treturn acc + Math.pow(cur - avg, 2);\n\t\t}, 0);\n\t\tlet SD = Math.sqrt(sumVariance / n);\n\t\treturn {N: n, Average: avg, SD: SD, CV: 100 * SD / avg}\n\t}*/\n\tstatic headerObject(way, CV) { //Return a structured object representing the header for statistics, either as row or column, including CV or nothing\n\t\tlet o = this.statObject(CV);\n\t\tif(way == \"Row\") { //The output will be as an object including arrays of properties\n\t\t\treturn {\n\t\t\t\tNames: o.map(function(s) {return s.Name}),\n\t\t\t\tTypes: o.map(function(s) {return s.Type}),\n\t\t\t\tTitles: o.map(function(s) {return s.Title}),\n\t\t\t}\n\t\t}\n\t\telse {return o} //The output will be an array of objects with a set of properties\n\t}\n\tstatic statObject(CV) { //Return an array of objects with a set of properties representing the statistics calculated. CV present or not, as a boolean\n\t\tlet out = [\n\t\t\t{Name: \"Average\", Type: \"#\", Title: [\"Average of the numerical values present in this column. Not available for texts\"], Class: \"TotalRows\"},\n\t\t\t{Name: \"SD\", Type: \"#\", Title: [\"Standard Deviation for the numerical values present in this column. Available for 2 or more values\"], Class: \"TotalRows\"},\n\t\t];\n\t\tif(CV) {out.push({Name: \"CV\", Type: \"#\", Title: [\"Coefficient of Variation for the numerical values present in this column (expressed in %). Available for 2 or more values\"], Class: \"TotalRows\"})}\n\t\tout.push(\n\t\t\t{Name: \"N\", Type: \"Text\", Title: [\"Number of numerical and valid values used for the calculation of the statistics\"], Class: \"TotalRows\"}, //Consider the N as text so that it bypasses the decimal formatting\n\t\t\t{Name: \"Total\", Type: \"Text\", Title: [\"Total number of values seen in this column\"], Class: \"TotalRows\"} //Same here\n\t\t);\n\t\treturn out;\n\t}\n\tstatic statToArray(s, CV) { //Return the values in the stat object s as an array, with or w/o the CV\n\t\tlet out = [s.Average, s.SD];\n\t\tif(CV) {out.push(s.CV)}\n\t\tout.push(s.N, s.Total);\n\t\treturn out;\n\t}\n\t//\n\t//\n\t//\n\t//Getter and Setter\n\t//***************************************************************************************\n\t//MAYBE MORE EFFICIENT TO SIMPLY CALL THE STATIC METHOD STATS(), WHICH IS MORE EFFICIENT\n\t//***************************************************************************************\n\t/*get N() { //Number of valid numerical values\n\t\treturn this.Numeric.reduce(function(acc, val) {return acc + Number(val)}, 0); //Return 0 if no numerical values\n\t}\n\tget Average() { //Average for this data point, based on the values\n\t\tlet total = 0;\n\t\tlet n = 0;\n\t\tthis.Values.forEach(function(v, i) {\n\t\t\tif(this.Excluded[i] === false && this.Numeric[i] === true) {\n\t\t\t\tn++;\n\t\t\t\ttotal += v;\n\t\t\t}\n\t\t}, this);\n\t\treturn (total / n); //Return NaN if no numerical values\n\t}\n\tget SD() { //SD of the values\n\t\tlet avg = this.Average;\n\t\tlet n = this.N;\n\t\tlet variance = this.Values.map(function(v) { //return an array for which each element x is now (x-avg)^2, or NaN for text\n\t\t\treturn Math.pow(v - avg, 2);\n\t\t}); \n\t\tlet sumVariance = 0;\n\t\tvariance.forEach(function(v, i) {\n\t\t\tif(this.Excluded[i] === false && this.Numeric[i] === true) {sumVariance += v}\n\t\t}, this);\n\t\treturn Math.sqrt(sumVariance / n); //Population SD, computed with 1/N (For Sample SD, we should use 1/N-1, but population SD is more natural: [8, 12] => pSD = 2; sSD = 2.82)\n\t}\n\tget CV() { //CV(%) of the values\n\t\tlet SD = this.SD;\n\t\tlet avg = this.Average;\n\t\treturn 100 * SD / avg;\n\t}*/\n\t//Methods\n\t\n}","//****************************************************\n// DECIMAL object - For clean mathematics with numbers\n//****************************************************\nclass Decimal {\n\tconstructor(n) {\n\t\tthis.Input = n; //The input number\n\t\tthis.InputStr = n.toString(); //String representation of the input\n\t\tthis.Sgn = Math.sign(n); //Sign: -1; 0; 1\n\t\tthis.Value = Math.abs(n); //Exclude the sign\n\t\tthis.ValueStr = this.Value.toString(); //String of input without sign\n\t\tthis.Floor = Math.floor(this.Value); //Floor part\n\t\tthis.FloorStr = this.Floor.toString(); //Floor part as a string\n\t\tthis.ExpPosition = this.InputStr.indexOf(\"e\"); //Position of the exponential operator in the input string\n\t\tthis.DecPosition = this.ValueStr.indexOf(\".\"); //Position of the decimal separator, in the string without sign\n\t\tthis.Power = Math.floor(Math.log10(this.Value)) //Calculate the power, or exponent, of the number.\n\t\tif(this.ExpPosition > 0) { //Exponential notation used here\n\t\t\tthis.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1, this.ExpPosition); //Raw decimals parts, excluding the \"e+/-xxx\"\n\t\t\tthis.PowerOffset = - (this.RawDecimalStr.length - 1); //The offset power to use when working with the PureValue, in order to get back to the right number\n\t\t}\n\t\telse {\n\t\t\tif(this.DecPosition > 0) {this.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1)} //Raw decimals parts\n\t\t\telse {this.RawDecimalStr = \"\"} //Case where there are no decimals \n\t\t\tthis.PowerOffset = -(this.RawDecimalStr.length + this.Power); //The offset power to use when working with the PureValue, in order to get back to the right number\n\t\t}\n\t\tthis.Decimals = Number(this.RawDecimalStr); //Without leading zeros\n\t\tthis.DecimalStr = this.Decimals.toString(); //String of the pure decimal part, wihtout leading zeros\n\t\tif(this.ExpPosition > 0) { //Exponential notation used here\n\t\t\tthis.PureValueStr = this.ValueStr.substring(0, this.DecPosition) + this.RawDecimalStr; //The pure number value, without power or dot, as a string\n\t\t}\n\t\telse {\n\t\t\tif(this.Floor == 0) {this.PureValueStr = this.DecimalStr}\n\t\t\telse {this.PureValueStr = this.InputStr.replace(/[.]/, \"\")}\n\t\t}\n\t\tthis.PureValue = Number(this.PureValueStr); //The pure number value, without power or dot\n\t\treturn this;\n\t}\n\t//Static methods\n\tstatic isNumeric(v) { //Returns a boolean to indicate if the value is text or number\n\t\treturn (v !== undefined && v !== null && v.toFixed !== undefined && isNaN(v) == false);\n\t}\n\tstatic sgnToText(d) { //Return the txt string corresponding to the sign for the decimal object d\n\t\tif(d.Sgn < 0) {return \"-\"}\n\t\telse {return \"\"}\n\t}\n\tstatic niceNumber(n, I) { //Return the \"nicest\" number which is the closest (above or below) to n. \"Nice\" is defined as being any powers of 2, 5 or 10. The Decimal object will be returned, except if the number is explicitly requested\n\t\tlet nice = 0; //The nice number to return. 0 is used as a default fallback\n\t\tlet above = true; //Whether the nice number should be bigger or smaller than the number provided\n\t\tlet offset = 0; //Offset for the root digits, to make sure they fall as a number between 0 and 10\n\t\tlet d = new Decimal(n);\n\t\tlet p = d.Power;\n\t\tlet array = [1, 1.2, 1.25, 1.5, 1.75, 2, 2.5, 4, 5, 6, 7.5, 8, 10]; //The array to compare the root digits with. Any of these numbers is considered \"nice\" and the aim is to select the closest\n\t\tif(I) {\n\t\t\tif(I.Power) {p = I.Power}\n\t\t\tif(I.Below) {above = false}\n\t\t\tif(I.Loose) {array = [1, 2, 4, 5, 10]} //In case a looser approximation is needed\n\t\t}\n\t\tif(d.Sgn == -1) {above = !above} //In this case, should switch above/below to its opposite\n\t\tlet digit = d.Value / Math.pow(10, p); //The root digits\n\t\tif(digit > 10) { //Bring it back down between 0 and 10\n\t\t\toffset = 10;\n\t\t\tdigit -= offset;\n\t\t}\n\t\tlet op = function(a, b) {return(a <= b)} //The comparison function\n\t\tif(I && I.Strict) {op = function(a, b) {return a < b}} //Strict inequality\n\t\tif(above) { //Nice number should be bigger\n\t\t\tarray.reverse(); //This ensures the \"smallest among the bigger\" will be used\n\t\t\top = function(a, b) {return(a >= b)}\n\t\t\tif(I && I.Strict) {op = function(a, b) {return a > b}} //Strict inequality\n\t\t}\n\t\tarray.forEach(function(a) {if(op(a, digit)) {nice = a}}); //Compare the root digits with all of the nice numbers available and pick the closest one\n\t\tlet niceNumber = d.Sgn * (offset + nice) * Math.pow(10, p); //Restore the nice number to the right power and sign\n\t\tif(I && I.ReturnAsObject) {return(new Decimal(niceNumber))}\n\t\telse {return niceNumber}\n\t}\n\tstatic multiply(a, b, bool) { //Perform a \"clean\" multiplication with the numbers provided and return the corresponding number. This is to avoid rounding issues\n\t\tif(a == 0 || b == 0) {return 0} //Trivial, but problem of power with these cases that need to be excluded\n\t\tlet A = new Decimal(a);\n\t\tlet B = new Decimal(b);\n\t\tlet pureResults = A.PureValue * B.PureValue; //Calculate the pure number out of the inputs. This has no decimals\n\t\tlet power = A.Power + A.PowerOffset + B.Power + B.PowerOffset; //Calculate the power\n\t\tlet result = NaN;\n\t\tif(power >= 0) {\n\t\t\tresult = pureResults * Math.pow(10, power); //No rounding errors in that case\n\t\t}\n\t\telse { //Rounding errors will ensue when multiplying, so simply shift to a division\n\t\t\tresult = pureResults / Math.pow(10, Math.abs(power));\n\t\t}\n\t\t//let result = pureResults * Math.pow(10, power);\n\t\tif(bool) {return new Decimal(result)} //Output\n\t\telse {return result}\n\t}\n\tstatic format(n, digit, I) { //Output the number in a string format, keeping digit as precision and using scientific notation whenever required. In case of rounding, displays a leading tilde if true\n\t\tlet d = new Decimal(n);\n\t\tif(digit == 0 || isNaN(digit)) {return d.InputStr} //no formatting, return a string to be consistent with the other outputs\n\t\tlet out = \"~\"; //Output string\n\t\tif(I && I.NoTilde) {out = \"\"} \n\t\tlet f = d.FloorStr.length;\n\t\tif(d.DecPosition > 0) { //Case xx[...]xx.xx[...]xx, the number has decimals\n\t\t\tif(d.ValueStr.length <= (digit+1 )) {return d.InputStr} //Trivial case, no rounding. +1 for decimal place\n\t\t\tlet diff = d.RawDecimalStr.length - d.DecimalStr.length; //This will get the number of leading zeros for decimals, if any\n\t\t\tif(d.Floor == 0) { //Case 0.xx[...]xx\n\t\t\t\tif(diff > 0) { //Case 0.00[...]00xxx\n\t\t\t\t\tif(d.DecimalStr.length <= digit) {return d.Input.toExponential(d.DecimalStr.length-1)} //Simple case, no rounding necessary\n\t\t\t\t\telse { //Rounding required\n\t\t\t\t\t\tout += Decimal.sgnToText(d); //Add the sign\n\t\t\t\t\t\tlet array = d.DecimalStr.split(\"\");\n\t\t\t\t\t\tif(Number(array[digit]) > 4) {array[digit-1]++} //Rounding\n\t\t\t\t\t\tfor(let i=0;i<digit;i++) { //Add the decimals\n\t\t\t\t\t\t\tif(i == 1) {out += \".\" + array[i]} //Ensures the dot is added only if something comes behind\n\t\t\t\t\t\t\telse {out += array[i]}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn out + \"e-\" + (diff + 1); //Add the power and return\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\telse { //Case 0.xx[...]xx\n\t\t\t\t\tif(d.DecimalStr.length <= digit) {return d.InputStr} //Simplest case, no rounding necessary\n\t\t\t\t\telse { //Round\n\t\t\t\t\t\tout += Decimal.sgnToText(d);\n\t\t\t\t\t\tout += d.Input.toFixed(digit);\n\t\t\t\t\t\treturn out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { //Case xx[...]xx.xx[...]xx\n\t\t\t\tif(f > (digit - 1)) {return out + d.Input.toExponential(digit-1)} //More digits in the floor than required. Use std sci notation\n\t\t\t\telse { //Case xx.xxx[...]xx, too much decimals\n\t\t\t\t\tlet decNeeded = digit - f; //How many decimals should be taken\n\t\t\t\t\tout += Decimal.sgnToText(d) + d.FloorStr + \".\";\n\t\t\t\t\tlet array = d.DecimalStr.split(\"\");\n\t\t\t\t\tif(Number(array[decNeeded]) > 4) {array[decNeeded-1]++} //Rounding\n\t\t\t\t\tfor(let i=0;i<decNeeded;i++) {out += array[i]}\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse { //Case xx[...]xx, no decimals; or exponential notation\n\t\t\tif(d.ValueStr.length <= digit) {return d.InputStr} //Trivial case, no rounding\n\t\t\tvar p = f; //in the remaining, may need to round. First look for trailing zeros\n\t\t\twhile (d.FloorStr.substring(p, p - 1) == \"0\") {p--}\n\t\t\tvar power = f - p; //Get the power\n\t\t\tif(power > 0) { //Case xx[...]xx00[...]00\n\t\t\t\tvar TrueFloor = d.FloorStr.substring(0, p); //Get only the significant digits\n\t\t\t\tvar tf = TrueFloor.length;\n\t\t\t\tif(tf > 0 && tf <= digit) {return d.Input.toExponential(tf-1)} //Exact, no rounding required\n\t\t\t\telse {return out + d.Input.toExponential(digit-1)} //Need to round\n\t\t\t}\n\t\t\telse {return out + d.Input.toExponential(digit-1)} //No trailing zeros, need to round\n\t\t}\n\t}\n\t//Methods\n}\n\n\n/*function Decimal(n) {\n\tthis.Input = n; //The input number\n\t//Constructor\n\tthis.InputStr = n.toString(); //String representation of the input\n\tthis.Sgn = Math.sign(n); //Sign: -1; 0; 1\n\tthis.Value = Math.abs(n); //Exclude the sign\n\tthis.ValueStr = this.Value.toString(); //String of input without sign\n\tthis.Floor = Math.floor(this.Value); //Floor part\n\tthis.FloorStr = this.Floor.toString(); //Floor part as a string\n\tthis.ExpPosition = this.InputStr.indexOf(\"e\"); //Position of the exponential operator in the input string\n\tthis.DecPosition = this.ValueStr.indexOf(\".\"); //Position of the decimal separator, in the string without sign\n\tthis.Power = Math.floor(Math.log10(this.Value)) //Calculate the power, or exponent, of the number.\n\tif(this.ExpPosition > 0) { //Exponential notation used here\n\t\tthis.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1, this.ExpPosition); //Raw decimals parts, excluding the \"e+/-xxx\"\n\t\tthis.PowerOffset = - (this.RawDecimalStr.length - 1); //The offset power to use when working with the PureValue, in order to get back to the right number\n\t}\n\telse {\n\t\tif(this.DecPosition > 0) {this.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1)} //Raw decimals parts\n\t\telse {this.RawDecimalStr = \"\"} //Case where there are no decimals \n\t\tthis.PowerOffset = -(this.RawDecimalStr.length + this.Power); //The offset power to use when working with the PureValue, in order to get back to the right number\n\t}\n\tthis.Decimals = Number(this.RawDecimalStr); //Without leading zeros\n\tthis.DecimalStr = this.Decimals.toString(); //String of the pure decimal part, wihtout leading zeros\n\tif(this.ExpPosition > 0) { //Exponential notation used here\n\t\tthis.PureValueStr = this.ValueStr.substring(0, this.DecPosition) + this.RawDecimalStr; //The pure number value, without power or dot, as a string\n\t}\n\telse {\n\t\tif(this.Floor == 0) {this.PureValueStr = this.DecimalStr}\n\t\telse {this.PureValueStr = this.InputStr.replace(/[.]/, \"\")}\n\t}\n\tthis.PureValue = Number(this.PureValueStr); //The pure number value, without power or dot\n\t//Methods\n\tthis.sgnToText = function() { //Return the txt string corresponding to the sign\n\t\tif(this.Sgn < 0) {return \"-\"}\n\t\telse {return \"\"}\n\t}\n\tthis.format = function(digit, tilde) { //Output the number in a string format, keeping digit as precision and using scientific notation whenever required. In case of rounding, displays a leading tilde if true\n\t\tif(digit == 0) {return this.InputStr} //no formatting, return a string to be consistent with the other outputs\n\t\tif(tilde) {var out = \"~\"} else {var out = \"\"} //Prepare output\n\t\tvar f = this.FloorStr.length;\n\t\tif(this.DecPosition > 0) { //Case xx[...]xx.xx[...]xx, the number has decimals\n\t\t\tif(this.ValueStr.length <= (digit+1 )) {return this.InputStr} //Trivial case, no rounding. +1 for decimal place\n\t\t\tvar diff = this.RawDecimalStr.length - this.DecimalStr.length; //This will get the number of leading zeros for decimals, if any\n\t\t\tif(this.Floor == 0 && diff > 0) { //Case 0.00[...]00xxx\n\t\t\t\tif(this.DecimalStr.length <= digit) {return this.Input.toExponential(this.DecimalStr.length-1)} //Simple case, no rounding necessary\n\t\t\t\telse {return this.roundSCI(this.DecimalStr, -(diff+1), digit, out)} //Rounding required\n\t\t\t}\n\t\t\tif(this.Floor == 0 && diff == 0) { //Case 0.xx[...]xx\n\t\t\t\tif(this.DecimalStr.length <= digit) {return this.InputStr} //Simplest case, no rounding necessary\n\t\t\t\telse { //Avoiding e-1\n\t\t\t\t\tvar array = this.DecimalStr.split(\"\");\n\t\t\t\t\tout += this.sgnToText() + \"0.\"; //Add the sign\n\t\t\t\t\tif(Number(array[digit]) > 4) {array[digit-1]++} //Rounding\n\t\t\t\t\tfor(let i=0;i<digit;i++) {out += array[i]} //Add the decimals\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//In all these remaining cases, Floor is > 0\n\t\t\tif(f > (digit-1)) {return out + this.Input.toExponential(digit-1)} //Case xx[...]xx.xx[...]xx, with more digits in the floor than required. Use std sci notation\n\t\t\telse { //Case xx.xxx[...]xx, few decimals will be needed\n\t\t\t\tvar decNeeded = digit - f; //How many decimals should be taken\n\t\t\t\tvar array = this.DecimalStr.split(\"\");\n\t\t\t\tif(Number(array[decNeeded]) > 4) {array[decNeeded-1]++} //Rounding\n\t\t\t\tout += this.sgnToText() + this.FloorStr + \".\";\n\t\t\t\tfor(let i=0;i<decNeeded;i++) {out += array[i]}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t}\n\t\telse { //Case xx[...]xx, no decimals; or exponential notation\n\t\t\tif(this.ValueStr.length <= digit) {return this.InputStr} //Trivial case, no rounding\n\t\t\tvar p = f; //in the remaining, may need to round. First look for trailing zeros\n\t\t\twhile (this.FloorStr.substring(p, p - 1) == \"0\") {p--}\n\t\t\tvar power = f - p; //Get the power\n\t\t\tif(power > 0) { //Case xx[...]xx00[...]00\n\t\t\t\tvar TrueFloor = this.FloorStr.substring(0, p); //Get only the significant digits\n\t\t\t\tvar tf = TrueFloor.length;\n\t\t\t\tif(tf > 0 && tf <= digit) {return this.Input.toExponential(tf-1)} //Exact, no rounding required\n\t\t\t\telse {return out + this.Input.toExponential(digit-1)} //Need to round\n\t\t\t}\n\t\t\telse {return out + this.Input.toExponential(digit-1)} //No trailing zeros, need to round\n\t\t}\n\t}\n\tthis.roundSCI = function(object, power, digit, out) { //return a string of the scientific notation of object (decimal or floor), using power for the exponential, with digit as precision, displaying \"~\" if tilde\n\t\tvar array = object.split(\"\");\n\t\tout += this.sgnToText(); //Add the sign\n\t\tif(Number(array[digit]) > 4) {array[digit-1]++} //Rounding\n\t\tfor(let i=0;i<digit;i++) { //Add the decimals\n\t\t\tif(i == 1) {out += \".\" + array[i]} //Ensures the dot is added only if something comes behind\n\t\t\telse {out += array[i]}\n\t\t} \n\t\treturn out + \"e\" + power; //Add the power and return\n\t}\n\tthis.formatConc = function(unit, digit, html) { //Format the number with its unit, using html space if true\n\t\tvar space = \" \";\n\t\tif(html) {space = \"&nbsp;\"}\n\t\tswitch(unit) {\n\t\t\tcase \"MOI\": return(unit + space + this.format(digit, true)); // invert in case of MOI\n\t\t\tdefault: return(this.format(digit, true) + space + unit);\n\t\t}\n\t}\n\tthis.niceNumber = function(I) { //Return the \"nicest\" number which is the closest (above or below) to this number. \"Nice\" is defined as being any powers of 2, 5 or 10. The Decimal object will be returned, except if the number is explicitly requested\n\t\tvar nice = 0;\n\t\tvar above = true;\n\t\tvar p = this.Power;\n\t\tvar array = [1, 1.2, 1.25, 1.5, 1.75, 2, 2.5, 4, 5, 6, 7.5, 8, 10];\n\t\tif(I) {\n\t\t\tif(I.Power) {p = I.Power}\n\t\t\tif(I.Below) {above = false}\n\t\t\tif(I.Loose) {array = [1, 2, 4, 5, 10]} //In case only a loose approximation is needed\n\t\t}\n\t\tif(this.Sgn == -1) {above = !above} //In this case, should switch above/below to its opposite\n\t\tvar digit = this.Value / Math.pow(10, p);\n\t\tif(digit > 10) {var offset = 10}\n\t\telse {var offset = 0}\n\t\tdigit -= offset;\n\t\tvar op = function(a, b) {return(a <= b)}\n\t\tif(above) { //Nice number should be bigger\n\t\t\tarray.reverse(); //This ensures the \"smallest among the bigger\" will be used\n\t\t\top = function(a, b) {return(a >= b)}\n\t\t}\n\t\tarray.forEach(function(a) {if(op(a, digit)) {nice = a}});\n\t\tvar niceNumber = this.Sgn * (offset + nice) * Math.pow(10, p);\n\t\tif(I && I.ReturnAsNumber) {return niceNumber}\n\t\telse {return(new Decimal(niceNumber))}\n\t}\n\tthis.multiply = function(a, I) { //Perform a \"clean\" multiplication with the number provided and return the corresponding number. This is to avoid rounding issues\n\t\tif(a == 0 || this.Input == 0) {return 0} //Trivial, but problem of power with these cases that need to be excluded\n\t\tvar input = new Decimal(a);\n\t\tvar pureResults = input.PureValue * this.PureValue; //Calculate the pure number out of the inputs\n\t\tvar power = input.Power + input.PowerOffset + this.Power + this.PowerOffset; //Calculate the power\n\t\tvar resultStr = pureResults + \"e\" + power; //Make up a string\n\t\tvar result = eval(resultStr); //Evaluate the result\n\t\tif(I && I.ReturnAsObject) {return new Decimal(result)} //Output\n\t\telse {return result}\n\t}\n}*/","//********************************************************************************\n// INPUTOBJECT - Object for input files/data and tracking of their parsing options\n//********************************************************************************\nclass InputObject {\n\tconstructor() {\n\t\tthis.Controls = {\n\t\t\tParser: LinkCtrl.new(\"Select\", {\n\t\t\t\tID: Form_Import.Anchors.Parser, Label: \"Parser\", Default: 0, List: [\"TXT/CSV\", \"XLSX\", \"XLS\"], \n\t\t\t\tTitle: \"The parser to use to parse this input\",\n\t\t\t\tChange: function(v, I) {\n\t\t\t\t\tif(I) {I.Input = this}\n\t\t\t\t\telse {\n\t\t\t\t\t\tI = {Input: this}\n\t\t\t\t\t}\n\t\t\t\t\tthis.changeParser(I);\n\t\t\t\t}.bind(this)\n\t\t\t}),\n\t\t\tLimit: LinkCtrl.new(\"Select\", { //The limit to the number of lines to parse for the preview\n\t\t\t\tID: Form_Import.Anchors.Preview, Index: 1, Default: 0, Label: \"Limit\", Preserve: true, List: [\"20\", \"100\", \"500\", \"1000\", \"All\"], Title: \"Only this number of rows will be displayed in the preview. Prevent big files from crashing the browser.\",\n\t\t\t\tChange: function() { //on change, trigger a new parsing of the input and supply the new limit to use\n\t\t\t\t\tthis.InputParser.parse({Limit: this.Controls.Limit.Selected, Input: this});\n\t\t\t\t}.bind(this),\n\t\t\t}),\n\t\t}\n\t}\n\tstatic new(type, data) { //Create a new child InputObject\n\t\tswitch(type) {\n\t\t\tcase \"File\": return new InputObject_File(data); break; //File passed in data\n\t\t\tcase \"Manual\": return new InputObject_Manual(data); break; //Plain input passed in data\n\t\t\tdefault:\n\t\t\t\tconsole.error(\"Unknown type requested for InputObject (\" + type + \"). Aborted.\");\n\t\t\t\treturn;\n\t\t}\n\t}\n\t//Methods\n\tchangeParser(I) { //Change in the parser selected\n\t\tthis.InputParser = InputParser.new({Type: this.Controls.Parser.Selected, Data: this.RawData, Name: this.Name}); //Create a new parser object\n\t\tif(I) {I.Limit = this.Controls.Limit.Selected}\n\t\telse {\n\t\t\tI = {Limit: this.Controls.Limit.Selected}\n\t\t}\n\t\tif(I === undefined || I.NoParse !== true) {this.InputParser.parse(I)} //Parse\n\t\tif(I && I.NoInit) {return}\n\t\tthis.InputParser.init(); //Init the LinkCtrl options for the parser\n\t}\n}","//****************************************************************\n// INPUTPARSER - Object for parsing of data from file/manual input\n//****************************************************************\nclass InputParser {\n\tconstructor(I) {\n\t\tthis.RawData = I.Data; //Raw data to use for the parsing\n\t\tthis.Name = I.Name; //Name of the input\n\t\tthis.WebWorker = true; //Whether to use WebWorker for parsing\n\t\tthis.TotalRows = 0; //Total number of rows available in the raw data\n\t\tthis.TotalCols = 0; //Total number of columns available in the raw data\n\t\tthis.SelectedRows = 0; //Effectively selected number of rows\n\t\tthis.SelectedCols = 0; //Effectively selected number of columns\n\t\tthis.Headers = []; //Array of string summarizing the headers found in the input after parsing\n\t\tthis.Info = \"\"; //Additional info regarding the parsing\n\t\tthis.Limit = Infinity; //This corresponds to the limit of rows to show in the preview\n\t\tthis.FirstParsed = false; //Indicate that the data need to be fully parsed once to initialize total rows/cols counts\n\t\tthis.Error = false; //Whether an error was encountered during parsing\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\n\t\tlet onChange = function() {this.parse()}.bind(this); //function() {this.clean()}.bind(this)\n\t\tthis.Options = {\n\t\t\tNoHeaders: LinkCtrl.new(\"Checkbox\", {ID: target, Label: \"No headers\", Default: false, Change: onChange, NewLine: true, Title: \"If ticked, arbitrary, default headers will be used instead of the values found in the first line\"}),\n\t\t\tFirstRow: LinkCtrl.new(\"Number\", {ID: target, Label: \"First Row\", Default: 1, Min: 1, Preserve: true, NewLine: true, Index: 1, Change: onChange, Title: \"Line at which the import is started\"}),\n\t\t\tFirstCol: LinkCtrl.new(\"Number\", {ID: target, Label: \"First Column\", Default: 1, Min: 1, Preserve: true, NewLine: true, Index: 2, Change: onChange, Title: \"Column at which the import is started\"}),\n\t\t\tSingleCol: LinkCtrl.new(\"Checkbox\", {ID: target, Label: \"Single column\", Default: false, Preserve: true, NewLine: true, Index: 3, Change: onChange,  Title: \"If ticked, only one column of data will be selected for import\"}),\n\t\t\tSkipEmptyRows: LinkCtrl.new(\"Checkbox\", {ID: target, Label: \"Skip empty rows\", Default: true, Preserve: true, NewLine: true, Index: 4, Change: onChange, Title: \"Whether empty rows are skipped\"}),\n\t\t}\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic new(I) { //Create a new InputParser object of the desired type\n\t\tswitch(I.Type) { //Create the desired element\n\t\t\tcase \"TXT/CSV\": return new InputParser_Papa(I);\n\t\t\tcase \"XLSX\": return new InputParser_XLSX(I);\n\t\t\tcase \"XLS\": return new InputParser_XLS(I);\n\t\t\tdefault: //Exit if the type is unknown\n\t\t\t\tconsole.error(\"Unknown type requested for InputParser (\" + I.Type + \"). Aborted.\");\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic highlight(txt) { //Returns an html string containing the text highlighted with a specific style\n\t\treturn \"<b><i><span style=\\\"color: salmon\\\">\" + txt + \"</span></b></i>\"\n\t}\n\t//Methods\n\tinit() { //Display controls for available options\n\t\tObject.values(this.Options).forEach(function(o) {o.init()});\n\t\treturn this;\n\t}\n\tresetParsing(I) { //Reset previous parsing data before parsing again\n\t\tthis.SelectedRows = 0;\n\t\tthis.SelectedCols = 0;\n\t\tthis.Error = false;\n\t\tif(I && I.NoPreview) {return this}\n\t\tGetId(Form_Import.Anchors.PreviewBox).innerHTML = \"<p>\" + InputParser.highlight(\"Preparing preview, please wait...\") + \"</p>\";\n\t\treturn this;\n\t}\n\tsetLimit(I) {\n\t\tif(I && I.Limit != \"All\") { //Set the limit of rows for preview\n\t\t\tthis.Limit = parseInt(I.Limit);\n\t\t}\n\t\telse {this.Limit = Infinity}\n\t\treturn this;\n\t}\n\tparsingOptions() { //Return an object holding parsing options that need to be recalled to clean the row as they come\n\t\tlet o = {\n\t\t\tNoHeaders: this.Options.NoHeaders.getValue(),\n\t\t\tFirstRow: this.Options.FirstRow.getValue() - 1, //Index of the first row\n\t\t\tFirstCol: this.Options.FirstCol.getValue() - 1, //Index of the first col\n\t\t\tSingleCol: this.Options.SingleCol.getValue(),\n\t\t\tSkipEmptyRows: this.Options.SkipEmptyRows.getValue(),\n\t\t\tLastCol: this.TotalCols, //Index of the last column to explore\n\t\t\tFirstParsed: this.FirstParsed,\n\t\t\tIndex: 0, //Tracker for row index\n\t\t\tSelected: -1, //Tracker for the number of selected rows\n\t\t};\n\t\tif(o.SingleCol) {o.LastCol = o.FirstCol + 1} //Only one column is needed\n\t\treturn o;\n\t}\n\tprocessRow(row, parser, f, o) { //Process the incoming row from the parser\n\t\tlet clean = this.cleanRow(row, o);\n\t\tif(clean) { //The row is valid\n\t\t\tif(o.Selected == -1) { //First selected row, prepare the header\n\t\t\t\tthis.header(clean, o); //Prepare the header\n\t\t\t\tif(o.NoHeaders || this.FirstParsed == false || o.ApplyToHeader) { //In special cases, this row is processed normally and we move to the next\n\t\t\t\t\tf(clean, 0, parser, o);\n\t\t\t\t\to.Selected = 1;\n\t\t\t\t}\n\t\t\t\telse {o.Selected = 0} //In normal cases ignore the header and the next row will be the first row of data\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(clean, o.Selected, parser, o);\n\t\t\t\to.Selected++;\n\t\t\t}\n\t\t}\n\t\to.Index++;\n\t}\n\tcleanRow(data, o) { //Clean the row received so that it fits the config\n\t\tif(o.FirstParsed == false) {return data} //There is no cleaning needed when processing the file for the first time\n\t\tif(o.Index >= o.FirstRow) { //If the current row index is higher than the index requested for first line, this line should be processed\n\t\t\tlet row = [];\n\t\t\tlet dataFound = false;\n\t\t\tfor(let i = o.FirstCol; i < o.LastCol; i++) { //Go through the data and check for empty values\n\t\t\t\tif(data[i] === undefined || data[i] === \"\") {row.push(\"\")}\n\t\t\t\telse { //Value found, push it\n\t\t\t\t\trow.push(data[i]);\n\t\t\t\t\tdataFound = true; //At least one value found\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(o.SkipEmptyRows && dataFound == false) {return undefined} //Empty row is excluded\n\t\t\telse {return row}\n\t\t}\n\t\telse {return undefined}\n\t}\n\tparse(I) { //Parse the input using provided options\n\t\tlet T = Form_Import.Controls.Table;\n\t\tif(this.Error) {\n\t\t\tif(I && I.NoPreview !== true) {\n\t\t\t\tthis.previewRow([], undefined, {Error: true});\n\t\t\t}\n\t\t\tif(I && I.Input) {I.Input.Status = \"Error\"; T.update()}\n\t\t\treturn this;\n\t\t}\n\t\tthis.resetParsing(I); //Reset previous parsing data\n\t\tif(this.FirstParsed == false) {this.firstParse(I); return this}\n\t\tif(I) {this.setLimit(I)}\n\t\tlet name = this.Name;\n\t\tlet preview = true;\n\t\tif(I && I.NoPreview) {preview = false}\n\t\tthis.stream(function(row, selected, parser, parsingConfig) { //Step function\n\t\t\tif(preview) {\n\t\t\t\tlet s = T.Selected[0];\n\t\t\t\tif(s.Name != name) {parser.abort()} //Kill the parsing if another row is clicked in between\n\t\t\t\telse {\n\t\t\t\t\tif(selected == 0) {this.previewRow(row, parsingConfig, {Start: true})}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(selected < this.Limit && preview) {this.previewRow(row, parsingConfig)} //Push for the preview, only a subset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(I && I.Step) {I.Step(row, selected, parser)}\n\t\t}.bind(this), function(selected, parsingConfig) { //Completion function\n\t\t\tif(selected == -1) { //No rows were found\n\t\t\t\tthis.SelectedRows = 0;\n\t\t\t\tthis.SelectedCols = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.SelectedRows = selected; \n\t\t\t\tthis.SelectedCols = this.Headers.length;\n\t\t\t}\n\t\t\tif(preview && T.Selected[0].Name == name) { //Preview is not shown if a different file is selected at the moment it should be displayed\n\t\t\t\tthis.previewRow([], parsingConfig, {Last: true});\n\t\t\t}\n\t\t\tif(I && I.Input) {I.Input.Status = undefined; T.update()}\n\t\t\tif(I && I.Complete) {I.Complete(selected)}\n\t\t}.bind(this), {ApplyToHeader: true}); //We need to count the header row as a selected row in case the file contains the header\n\t}\n\tchunk(f, I) { //Chunk a piece of the input and apply the provided function on each chunk\n\t\t//Similar to bulk but there should be a limit in the number of lines accumulated\n\t}\n\tbulk(f) { //Apply the supplied function to the entire bulk of data, once the streaming is complete. This is sure to crash for big files\n\t\tlet out = [];\n\t\tthis.stream(function(row, selected, parser, parsingConfig) { //Step function\n\t\t\tout.push(row); //Accumulate all the data\n\t\t}.bind(this), function(selected, parsingConfig) { //Completion function\n\t\t\tf(out); //Execute function on the bulk\n\t\t});\n\t}\n\theader(row, o) { //Prepare the header based on row parsed\n\t\tthis.Headers = [];\n\t\tif(o.NoHeaders) { //No headers in the file, generate arbitraries column names\n\t\t\trow.forEach(function(r, j) { //For each column, prepare an arbitrary header\n\t\t\t\tthis.Headers.push(\"Col_\" + (j+1));\n\t\t\t}, this);\n\t\t}\n\t\telse {\n\t\t\trow.forEach(function(r, j) { //In this case, just complete empty values with arbitrary headers\n\t\t\t\tif(r == \"\") {this.Headers.push(\"Col_\" + (j+1))}\n\t\t\t\telse {this.Headers.push(r)}\n\t\t\t}, this);\n\t\t}\n\t\treturn this;\n\t}\n\tpreviewHeader() { //Header for the preview\n\t\tlet out = \"<tr>\";\n\t\tthis.Headers.forEach(function(h) { //Preview of the headers\n\t\t\tout += \"<th>\" + h + \"</th>\";\n\t\t});\n\t\tout += \"</tr>\";\n\t\treturn out;\n\t}\n\tpreviewRow(row, o, I) { //Receives a row for the preview and append it to the preview window\n\t\tlet out = \"\";\n\t\tif(I && I.Start) {\n\t\t\tout += \"<div><p>\" + InputParser.highlight(\"Preparing preview, please wait...\") + \"</p>\";\n\t\t\tout += \"* Total available Rows: <b>\" + this.TotalRows + \"</b>; Columns: <b>\" + this.TotalCols + \"</b>\";\n\t\t\tout += \"</div><div><table>\"; //Headings and Table are wrapped in a div for styling\n\t\t\tout += this.previewHeader();\n\t\t\tout += \"</table></div>\";\n\t\t\tGetId(Form_Import.Anchors.PreviewBox).innerHTML = out;\n\t\t\tif(o.NoHeaders) {out = \"\"}\n\t\t\telse {return this}\n\t\t}\n\t\tif(I && I.Last) {\n\t\t\tlet selected = this.SelectedRows;\n\t\t\tout += \"* Total available Rows: <b>\" + this.TotalRows + \"</b>; Columns: <b>\" + this.TotalCols + \"</b>\"; //Reset previous content in out\n\t\t\tout += \"<br>* Selected Rows: <b>\" + selected + \"</b>\";\n\t\t\tif(o.NoHeaders == false) {out += \" (including header row)\"}\n\t\t\tout\t+= \"; Columns: <b>\" + this.SelectedCols + \"</b>\";\n\t\t\tif(selected > this.Limit) {\n\t\t\t\tout += InputParser.highlight(\"<br>Now showing only \" + this.Limit + \" rows.\");\n\t\t\t}\n\t\t\tGetId(Form_Import.Anchors.PreviewBox).children[0].innerHTML = out;\n\t\t\treturn this;\n\t\t}\n\t\tif(I && I.Error) {\n\t\t\tout = \"<p>\" + InputParser.highlight(\"Parsing failed!\") + \"</p><p>Reason:<br>\" + this.ErrorDetails + \"</p><p>Try with a different parser or validate the input before trying again</p>\";\n\t\t\tGetId(Form_Import.Anchors.PreviewBox).innerHTML = out;\n\t\t\treturn this;\n\t\t}\n\t\trow.forEach(function(c, j) { //For each value\n\t\t\tout += \"<td>\"\n\t\t\tif(c === \"\") {out += InputParser.highlight(\"&Oslash;\")}\n\t\t\telse {out += c}\n\t\t\tout += \"</td>\";\n\t\t});\n\t\tGetId(Form_Import.Anchors.PreviewBox).children[1].children[0].insertRow().insertAdjacentHTML(\"beforeend\", out);\n\t}\n}","//******************************************************************************************************************\n// MAPPER object - Allow mapping of columns to specific contents and searching of data within file using the mapping\n//******************************************************************************************************************\nclass Mapper {\n\tconstructor() {return this}\n\t//Static Methods\n\tstatic well(I) { //Required for results, not for definitions\n\t\tlet bool = true;\n\t\tif(I && I.Required) {bool = false}\n\t\treturn {Name: \"Well ID\", Optional: bool, Guess: function(h, first) {return h.toString().search(/well/i) > -1} } //toString is essential to treat correctly cases where the header is a number\n\t}\n\tstatic plate() {return {Name: \"Plate ID\", Optional: true, Guess: function(h, first) {return (h.toString().search(/barcode/i) > -1 || h.toString().search(/plate/i) > -1)}}} //toString is essential to treat correctly cases where the header is a number\n\tstatic definition() {return {Name: \"Definition\"}} //Required\n\tstatic import() {return {Name: \"Import\", Multiple: true}} //Required\n\tstatic numeric() {\n\t\treturn {Name: \"Numeric\", Multiple: true, Optional: true, Guess: function(h, first) {\n\t\t\tif(first.search !== undefined) {return first.search(/[a-z]/gi) == -1}\n\t\t\telse {return true}\n\t\t}}\n\t}\n\tstatic anchors(here) { //Return the text for the anchors requested\n\t\tlet id = \"Mapper\";\n\t\tswitch(here) {\n\t\t\tcase \"Table\": return id + \"_inputTable\";\n\t\t\tcase \"Param\": return id + \"_Parameters\";\n\t\t\tdefault: return id;\n\t\t}\n\t}\n\tstatic map(inputs, I) { //Allow mapping of columns for the passed array of inputs, with mapping configuration passed as object in option\n//*****************************************************************************************\n//\tValidate: true/false, check for mandatory field and reject the mapping if not complete,\n//\tBackToImport: true/false, indicates whether it is possible to go back to the Form_Import on closure of this form\n//\tDone: function(), run after mapping is closed by the user\n//\tParameters: [], array of objects with the following structure:\n//\t\tName, Optional: true/false, Multiple: true/false,\n//\t\tGuess: function(h, f) [a function accepting the header h and first element f, that return true if the parameter should be selected],\n//*****************************************************************************************\n\t\tif(inputs === undefined || inputs.length == 0) {console.warn(\"No inputs provided to the mapper\"); return} //No inputs passed\n\t\tif(I === undefined || I.Parameters == undefined || I.Parameters.length == 0) {console.warn(\"Mandatory options not passed to the mapper\"); return} //No parameters to map\n\t\tlet inputTable = new RespTable({ //RespTable to navigate between the inputs\n\t\t\tID: Mapper.anchors(\"Table\"),\n\t\t\tArray: inputs,\n\t\t\tFields: [\"Name\", \"Size\"],\n\t\t\tPreserve: true, RowNumbers: true, NoControls: true,\n\t\t\tonSelect: function(array) {\n\t\t\t\tif(array.length > 0) {Mapper.showMapping(array[0], inputTable, I)}\n\t\t\t},\n\t\t});\n\t\tlet html = \"\"; //Prepare the html for the form\n\t\thtml += \"<div id=\\\"\" + Mapper.anchors(\"Table\") + \"\\\" style=\\\"float:left; width:300px; overflow:auto;\\\"><p><b>Inputs available:</b></p></div>\";\n\t\thtml += \"<div style=\\\"margin-left:320px\\\">\";\n\t\t\thtml += \"<p><b>Parameter mapping:</b></p>\";\n\t\t\thtml += \"<div id=\\\"\" + Mapper.anchors(\"Param\") + \"\\\" style=\\\"max-height:500px; overflow:auto\\\"></div>\"; \n\t\thtml += \"</div>\";\n\t\tlet id = \"Form_ParameterMapping\";\n\t\tlet buttons = [ //Buttons that will be applied to the form\n\t\t\t{Label: \"Done\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() { //Mapping is completed\n\t\t\t\tif(I.Validate) {\n\t\t\t\t\tif(Mapper.validate(inputs, I) == false) {return}\n\t\t\t\t}\n\t\t\t\tif(I.Done) {I.Done()}\n\t\t\t\tif(I.BackToImport) { //In this case, need to close the Form_Import as well\n\t\t\t\t\tForm_Import.cancel(); //Reset and close the form without calling OnClose again\n\t\t\t\t}\n\t\t\t\tForm.close(id);\n\t\t\t}},\n\t\t];\n\t\tif(I.BackToImport) { //In this case, add a button to close this form, allowing to return to the Form_Import\n\t\t\tbuttons.unshift({Label: \"Back to parsing\", Icon: {Type: \"Back\", Space: true}, Click: function() { //Add the button at the beginning of the array\n\t\t\t\tinputs.slice(0, I.Index); //Newly elements added must be rejected from the input list\n\t\t\t\tForm.close(id);\n\t\t\t}}); \n\t\t}\n\t\tForm.open({\n\t\t\tID: id,\n\t\t\tHTML: html,\n\t\t\tTitle: \"Parameter mapping\",\n\t\t\tSize: 800,\n\t\t\tButtons: buttons,\n\t\t\tonInit: function() { //Initialize the respTable on open\n\t\t\t\tinputTable.init();\n\t\t\t\tlet sel = inputTable.Selected;\n\t\t\t\tif(sel.length == 0) {inputTable.setValue([0])} //Force selection of the first element if nothing selected\n\t\t\t\tMapper.showMapping(inputTable.Selected[0], inputTable, I);\n\t\t\t},\n\t\t});\n\t}\n//************************************************************************************************************\n//Since this method will first run asynchronously to parse the first line of the file for guessing,\n//we need to check that the input selected at the end is same as the one passed, before appending the preview.\n//So it is better to also pass the inputTable here, instead of the selected result object alone\n//************************************************************************************************************\n\tstatic showMapping(input, inputTable, I) { //Show the mapping table for the selected input\n\t\tif(input.FirstRow === undefined) { //Parse the first row so that mapping can be guessed based on the values found\n\t\t\tGetId(Mapper.anchors(\"Param\")).innerHTML = \"<p class=\\\"Error\\\">Processing file, please wait...</p>\";\n\t\t\tinput.Parser.stream(function(row, selected, parser) { //Extract only the first row\n\t\t\t\tinput.FirstRow = row;\n\t\t\t\tparser.abort();\n\t\t\t}, function() { //When parsing is done, process the array\n\t\t\t\tMapper.guess(input, I);\n\t\t\t\tif(input.Name == inputTable.Selected[0].Name) {Mapper.mappingArray(input, inputTable, I)} //Prevent display if something else is clicked in between\n\t\t\t});\n\t\t}\n\t\telse {Mapper.mappingArray(input, inputTable, I)} //First column already parsed, the method can run synchronously\n\t}\n\tstatic guess(input, I) { //For the input provided, compute a guess for the mapping using the functions provided by the user\n\t\tinput.Parser.Headers.forEach(function(h, i) { //Loop the input headers\n\t\t\tI.Parameters.forEach(function(p, j) { //Loop the parameters to map\n\t\t\t\tif(p.Guess && p.Guess(h, input.FirstRow[i])) { //Try the provided guess function and assign the mapping is correct\n\t\t\t\t\tMapper.assign(input, p, i);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\tstatic mappingArray(input, inputTable, I) { //Build the array allowing mapping of parameters for the input\n\t\tlet html = \"<span class=\\\"FootNote\\\">Fields marked with * are mandatory</span>\";\n\t\thtml += \"<table class=\\\"RespTable\\\"><thead><tr><th>#</th><th>Name</th>\";\n\t\tI.Parameters.forEach(function(p) {\n\t\t\thtml += \"<th>\" + p.Name;\n\t\t\tif(!p.Optional) {html += \"<span class=\\\"Error\\\">*</span>\"}\n\t\t\tif(p.Multiple) {html += \"<br><span class=\\\"Hyperlink\\\">All</span>&nbsp;/&nbsp;<span class=\\\"Hyperlink\\\">None</span>\"}\n\t\t\thtml += \"</th>\";\n\t\t});\n\t\thtml += \"</tr></thead>\";\n\t\tinput.Parser.Headers.forEach(function(h, i) { //Loop the input headers to build table rows\n\t\t\thtml += \"<tr><td>\" + (i + 1) + \"</td><td>\" + h + \"</td>\"; //#, Name\n\t\t\tI.Parameters.forEach(function(p, j) { //Loop the parameters to map\n\t\t\t\thtml += \"<td style=\\\"transform: scale(0.8)\\\" class=\\\"RespTable_Row\";\n\t\t\t\tif(input.Mapping !== undefined && input.Mapping[p.Name] !== undefined) { //Reuse existing config if defined\n\t\t\t\t\tif(p.Multiple) { //In this case, mapping is an array with true/false\n\t\t\t\t\t\tif(input.Mapping[p.Name][i]) {html += \" RespTable_Selected Mapped\" + j}\n\t\t\t\t\t}\n\t\t\t\t\telse { //In this case, the mapping directly holds the value\n\t\t\t\t\t\tif(input.Mapping[p.Name] == i) {html += \" RespTable_Selected Mapped\" + j}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thtml += \"\\\"></td>\";\n\t\t\t});\n\t\t\thtml += \"</tr>\";\n\t\t});\n\t\thtml += \"</table>\";\n\t\tlet target = GetId(Mapper.anchors(\"Param\"));\n\t\ttarget.innerHTML = html; //Append the html\n\t\ttarget.children[1].addEventListener(\"click\", function(e) { //Bind events to the table\n\t\t\tlet t = e.target;\n\t\t\tswitch(t.nodeName) {\n\t\t\t\tcase \"TD\": //Table cells are responsive\n\t\t\t\t\tlet row = t.parentElement.rowIndex - 1; //The clicked row minus the table header\n\t\t\t\t\tlet col = t.cellIndex; //Clicked column\n\t\t\t\t\tif(col > 1) { //The 2 first columns are # and name and can be ignored\n\t\t\t\t\t\tlet param = I.Parameters[col - 2];\n\t\t\t\t\t\tif(param.Multiple) { //Multiple choices allowed\n\t\t\t\t\t\t\tif(t.className.includes(\"RespTable_Selected\")) {t.className = \"RespTable_Row\"} //When selected, turn it off\n\t\t\t\t\t\t\telse {t.className = \"RespTable_Row RespTable_Selected Mapped\" + (col - 2)} //The opposite\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { //Only one choice\n\t\t\t\t\t\t\tif(t.className.includes(\"RespTable_Selected\")) { //Strategy differs if optional or not\n\t\t\t\t\t\t\t\tif(param.Optional) {t.className = \"RespTable_Row\"} //When selected, turn it off\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse { //Select this cell and unselect the others\n\t\t\t\t\t\t\t\tlet previous = target.getElementsByClassName(\"Mapped\" + (col - 2));\n\t\t\t\t\t\t\t\tif(previous && previous[0]) {previous[0].className = \"RespTable_Row\"}\n\t\t\t\t\t\t\t\tt.className = \"RespTable_Row RespTable_Selected Mapped\" + (col - 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMapper.assign(input, param, row);\n\t\t\t\t\t\tif(I.OnChange) {I.OnChange(input)}\n\t\t\t\t\t}\n\t\t\t\t\tinputTable.update();\n\t\t\t\tbreak;\n\t\t\t\tcase \"SPAN\": //To select all or nothing at once\n\t\t\t\t\tlet column = t.parentElement.cellIndex;\n\t\t\t\t\tlet c = \"RespTable_Row\"; //The new class\n\t\t\t\t\tlet bool = false;\n\t\t\t\t\tif(t.innerHTML == \"All\") { //Select all\n\t\t\t\t\t\tc = \"RespTable_Row RespTable_Selected Mapped\" + (column - 2);\n\t\t\t\t\t\tbool = true;\n\t\t\t\t\t} \n\t\t\t\t\tinput.Parser.Headers.forEach(function(h, i) {\n\t\t\t\t\t\ttarget.children[1].rows[i + 1].cells[column].className = c;\n\t\t\t\t\t\tMapper.assign(input, I.Parameters[column - 2], i, {Select: bool});\n\t\t\t\t\t});\n\t\t\t\t\tif(I.OnChange) {I.OnChange(input)}\n\t\t\t\t\tinputTable.update();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\tstatic assign(input, parameter, index, I) { //For the input given, assign the parameter to the provided index (as the index in Header array)\n\t\tif(input.Mapping === undefined) {input.Mapping = {}} //Initialize a mapping object if needed\n\t\tlet name = parameter.Name;\n\t\tif(parameter.Multiple) { //The strategy is different is they are multiple assignments or just one\n\t\t\tif(input.Mapping[name] === undefined) { //For multiple assignement, held an array of boolean to indicate selected or not. Initialize the array here if not done\n\t\t\t\tinput.Mapping[name] = Array(input.Parser.Headers.length).fill(false);\n\t\t\t}\n\t\t\tif(I) { //To force a selection\n\t\t\t\tif(I.Select) {input.Mapping[name][index] = true}\n\t\t\t\telse {input.Mapping[name][index] = false}\n\t\t\t}\n\t\t\telse {input.Mapping[name][index] = !input.Mapping[name][index]} //Normal case, switch the value\n\t\t}\n\t\telse { //Only one mapping possible\n\t\t\tif(parameter.Optional && input.Mapping[name] == index) {input.Mapping[name] = -1} //This will neutralize the selection without initiating a guess when editing the mapping\n\t\t\telse {input.Mapping[name] = index}\n\t\t}\n\t}\n\tstatic validate(inputs, I) { //Validate that all mandatory assignments are done in the inputs\n\t\tlet l = I.Parameters.length;\n\t\tlet valid = true;\n\t\tlet i = 0;\n\t\twhile(valid && i < l) { //Loop the parameters\n\t\t\tlet p = I.Parameters[i];\n\t\t\tif(p.Optional === undefined || p.Optional == false) { //Need to validate only the required parameters\n\t\t\t\tlet n = inputs.length;\n\t\t\t\tlet j = 0;\n\t\t\t\twhile(valid && j < n) { //Loop over the inputs\n\t\t\t\t\tif(inputs[j].Mapping === undefined || inputs[j].Mapping[p.Name] === undefined) {valid = false} //Nothing defined, reject\n\t\t\t\t\telse { //Something is here, but it doesn't mean it's ok yet\n\t\t\t\t\t\tif(p.Multiple) { //For this specific case, need to ensure at least one is selected\n\t\t\t\t\t\t\tvalid = inputs[j].Mapping[p.Name].includes(true); //Will be false if all values are false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!valid) { //Stop as soon as a required parameter is not assigned\n\t\t\t\t\t\talert(\"Parameter \\\"\" + p.Name + \"\\\" has not been assigned for input \\\"\" + inputs[j].Name + \"\\\".\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic modeWellPlate(m) { //For the mapping object provided, return the mode needed to find the items: [plate only, well only, plate & well, direct]\n\t\tlet plateCol = m[Mapper.plate().Name];\n\t\tlet wellCol = m[Mapper.well().Name];\n\t\tlet wellDefined = false;\n\t\tlet plateDefined = false;\n\t\tif(wellCol !== undefined && wellCol > -1) {wellDefined = true}\n\t\tif(plateCol !== undefined && plateCol > -1) {plateDefined = true}\n\t\tif(wellDefined && plateDefined) {return \"PlateWell\"} //Both are defined\n\t\telse { //At least one is not defined\n\t\t\tif(wellDefined) {return \"Well\"}\n\t\t\tif(plateDefined) {return \"Plate\"}\n\t\t}\n\t\treturn \"Direct\";\n\t}\n//*********************************************************************************************\n//Justification for the definition of four independent mapper classes: the only alternative\n//way is to check the mode desired (PlateWell, Plate, Well, Direct) within the stream function,\n//then start the right subfunctions. But since this test needs to be performed for each line\n//of the file, it seems more efficient to define separate functions and run then without this\n//switch. It makes more lines of code, but the parsing runs faster, especially for big files.\n//Since the 4 classes are written independently in separated files, this way of doing also\n//does not reduce the code readability and maintenance.\n//*********************************************************************************************\n\tstatic new(mapping) { //Return the mapper object that fits the mapping provided\n\t\tswitch(Mapper.modeWellPlate(mapping)) {\n\t\t\tcase \"PlateWell\": return new Mapper_PlateWell(mapping);\n\t\t\tcase \"Plate\": return new Mapper_Plate(mapping);\n\t\t\tcase \"Well\": return new Mapper_Well(mapping);\n\t\t\tcase \"Direct\": return new Mapper_Direct(mapping);\n\t\t}\n\t}\n//*********************************************************************************************\n\tstatic scan(o, I) { //Scan the file and execute some actions as described in the options passed: Preview(limit), Log, Min/Max. Returns a promise\n\t\tif(o === undefined) {return Promise.resolve({Error: \"No file selected\"})}\n\t\tif(I === undefined) {\n\t\t\tconsole.warn(\"Mapper.scan is missing parameters to run\");\n\t\t\treturn Promise.resolve({Error: \"Internal error, check console for details\"});\n\t\t}\n\t\tlet output = { //Output object\n\t\t\tItems: 0, //The number of valid items\n\t\t\tPlatesID: [], //To log the plate names\n\t\t}\n\t\tif(I.Preview) {\n\t\t\toutput.Preview = \"\"; //To build a preview of the rows within the limit provided\n\t\t\toutput.Column = o.Mapping[I.Preview.Column]; //The column(s) to use for the preview content\n\t\t\toutput.Limit = (I.Preview.Limit || 50); //How many lines in the preview\n\t\t\toutput.LimitReached = false; //Whether the max number of lines has been reached\n\t\t}\n\t\treturn o.Mapper.scan(o, I, output);\n\t}\n\tstatic cleanValue(v) { //Clean the value recovered from the Mapper, to ensure smooth conversion to a number and correct handling of empty/crashing strings\n\t\tif(v === \"\" || v === \"Infinity\") {return undefined}\n\t\telse {return Number(v)}\n\t}\n\tstatic scanMinMax(o, row) { //Evaluate Min/Max and update the properties for the object passed\n\t\to.Parameters.forEach(function(p, i) { //For each numerical parameter, update the global min/max values\n\t\t\tif(p.Numeric) {\n\t\t\t\t//let value = Number(row[i]);\n\t\t\t\tlet value = Mapper.cleanValue(row[i]);\n\t\t\t\tif(value > p.GlobalMax) {p.GlobalMax = value}\n\t\t\t\tif(value < p.GlobalMin) {p.GlobalMin = value}\n\t\t\t}\n\t\t});\n\t}\n\tstatic scanPreviewColumns(output, row, start) { //Append row data to the preview\n\t\tif(output.Items < output.Limit) { //Limit not reached\n\t\t\tlet column = output.Column;\n\t\t\tif(output.Items > 0) {output.Preview += \"\\n\"}\n\t\t\toutput.Preview += start;\n\t\t\tif(column !== undefined) { //Should add the column(s) to the preview\n\t\t\t\tif(column.length) { //In this case we have an array of booleans\n\t\t\t\t\tcolumn.forEach(function(c, i) {\n\t\t\t\t\t\tif(c) {output.Preview += \" \" + row[i]}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {output.Preview += \" \" + row[column]} //Only one value\n\t\t\t}\n\t\t}\n\t\telse {output.LimitReached = true} //Limit reached\n\t}\n\tstatic fillMissingElements(out, I, start, index) { //Check that the definition has enough elements and complete with generic names if required\n\t\tlet name = \"\";\n\t\tif(I.AreaName) {name = I.AreaName + \" \"}\n\t\tif(I.FindAll && out.length < I.RangeIndexBase0) { //This means the definition is missing elements\n\t\t\twhile(index < I.RangeIndexBase0) { //Complete with generic names\n\t\t\t\t//out.push(I.Default + \" #\" + (start + index + 1));\n\t\t\t\tout.push(name + \"#\" + (start + index + 1));\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n}","//**************************************************************************************************\n// Object - To handle data pairing between results and definitions, at the single result plate level\n//**************************************************************************************************\nclass Pair {\n\tconstructor() {\n\t\tthis.Table = []; //An array of objet containing the information required to recover the corresponding plates from the linked definitions\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic unpaired() { //Return an object indicating that the current Pair object is empty (result plate unpaired)\n\t\tlet txt = \"There are currently no definition plates paired to this result plate\";\n\t\tlet html = \"<span style=\\\"font-size: 0.8em; font-style: italic\\\" title=\\\"\" + txt + \"\\\">Unpaired</span>&nbsp;\";\n\t\treturn {State: \"unpaired\", Txt: txt, Html: html}\n\t}\n\tstatic paired(p, n) { //Return an object indicating the current Pairs for the pair object provided\n\t\tlet plural = \" is\";\n\t\tif(n > 1) {plural = \"s are\"}\n\t\tlet txt = \"Currently \" + n + \" definition plate\" + plural + \" paired to this result plate:\\n\";\n\t\tlet broken = 0;\n\t\tp.Table.forEach(function(t, i) {\n\t\t\tif(i > 0) {txt += \"\\n\"}\n\t\t\ttxt += \"- Range: \" + t.RangeName + \"; Plate: \" + t.Name + \" (#\" + (t.Index + 1) + \")\";\n\t\t\tif(t.Broken) {\n\t\t\t\tbroken++;\n\t\t\t\ttxt += \" *Link Broken!*\";\n\t\t\t}\n\t\t});\n\t\tlet html = \"<span class=\\\"\";\n\t\tif(broken > 0) { //At least one definition is broken\n\t\t\thtml += \"Error\\\" style=\\\"font-size: 0.8em\\\" title=\\\"\" + txt + \"\\\">Pair broken (\" + broken + \"/\" + n + \")</span>&nbsp;\";\n\t\t\treturn {State: \"broken\", Txt: txt, Html: html, Length: n}\n\t\t}\n\t\telse { //All is fine\n\t\t\thtml += \"Success\\\" style=\\\"font-size: 0.8em\\\" title=\\\"\" + txt + \"\\\">Paired (\" + n + \")</span>&nbsp;\";\n\t\t\treturn {State: \"paired\", Txt: txt, Html: html, Length: n}\n\t\t}\n\t}\n\tstatic hasItem(pair, I) { //For the pair passed, checked if the item defined in the object is defined and return the index if yes\n\t\treturn pair.Table.findIndex(function(t) {\n\t\t\treturn(t.RangeName == I.RangeName);\n\t\t});\n\t}\n\t//Methods\n\tregister(I) { //Register the item provided\n\t\tlet previous = Pair.hasItem(this, I);\n\t\tif(previous > -1) { //This definition already has an item defined, update it\n\t\t\tlet elt = this.Table[previous];\n\t\t\telt.Index = I.DefPlateIndex;\n\t\t\telt.Name = I.DefPlateName;\n\t\t\telt.Broken = false;\n\t\t}\n\t\telse { //Nothing defined for this definition, define it\n\t\t\tthis.Table.push({ //Push a new element for this definition in the table\n\t\t\t\tRangeName: I.RangeName,\n\t\t\t\tIndex: I.DefPlateIndex,\n\t\t\t\tName: I.DefPlateName,\n\t\t\t\tBroken: false,\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\tremove(I) { //Remove the elt matching the definition provided for this pair\n\t\tlet index = Pair.hasItem(this, I);\n\t\tif(index > -1) { //If it exists...\n\t\t\tthis.Table.splice(index, 1); //...Remove the element\n\t\t}\n\t\treturn this;\n\t}\n\tstate() { //Return the state of the Pair as an object containing overall status and text/html strings of the pair content\n\t\tlet n = this.Table.length;\n\t\tif(n == 0) {return Pair.unpaired()}\n\t\telse {return Pair.paired(this, n)}\n\t}\n\tupdate(I) { //Check that all the definitions and plate listed in this object still exist and match the definition. Update when needed and report the current state\n\t\tlet n = this.Table.length;\n\t\tif(n == 0) {return Pair.unpaired()}\n\t\tlet validArray = []; //An array to push the definitions still existing\n\t\tthis.Table.forEach(function(t, i) { //Loop the paired definitions\n\t\t\tlet range = Editor.Tables.Areas.Array.find(function(a) {return a.Name == t.RangeName});\n\t\t\tif(range !== undefined) { //This range still exist\n\t\t\t\tlet def = range.Definition;\n\t\t\t\tif(def !== undefined) { //If the definition still exists, try to salvage the plates\n\t\t\t\t\tif(def.PlateIndex.getValue() == t.Index && def.PlateIndex.Selected == t.Name) { //This is the expected plate\n\t\t\t\t\t\tt.Broken = false;\n\t\t\t\t\t\tvalidArray.push(t); //Push the valid pair\n\t\t\t\t\t}\n\t\t\t\t\telse { //This is not the expected plate\n\t\t\t\t\t\tif(def.PlateIndex.List[t.Index] == t.Name) { //The plate exist where expected in the definition, keep it and report as broken\n\t\t\t\t\t\t\tif(I === undefined || I.All == false) { //Broken state should not be triggered when updating all pairs following edition of the definitions\n\t\t\t\t\t\t\t\tt.Broken = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalidArray.push(t); //Push the valid pair\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t} //All other cases means the definition has changed and we should delete the entry\n\t\t\t} //If the range doesn't exist, the validArray will be empty\n\t\t});\n\t\tthis.Table = validArray; //Update the array\n\t\tn = validArray.length;\n\t\tif(n == 0) {return Pair.unpaired()} //Report the status\n\t\telse {return Pair.paired(this, n)}\n\t}\n\tsetDefPlate() { //Set the value of the PlateSelect for all the paired definition to their paired values\n\t\tthis.Table.forEach(function(t) {\n\t\t\tlet range = Editor.Tables.Areas.Array.find(function(a) {return a.Name == t.RangeName});\n\t\t\tlet def = range.Definition;\n\t\t\tif(def !== undefined) {def.PlateIndex.setValue(t.Index)} //If the definition exist, set the plate\n\t\t\tt.Broken = false;\n\t\t});\n\t\treturn this;\n\t}\n\tgetDefPlate(sourceArray) { //Return the paired values stored for each definition\n\t\tlet O = []; //Output array\n\t\tsourceArray.forEach(function(r, i) { //For each range in the source array\n\t\t\tlet pair = this.Table.find(function(t) {return r.Name == t.RangeName});\n\t\t\tif(pair !== undefined) {O.push({RangeIndex: i, DefPlateIndex: pair.Index})} //If the definition exist, add it to the output\n\t\t}, this);\n\t\treturn O;\n\t}\n\trename(oldName, newName) { //Rename the definition with oldName to newName\n\t\tthis.Table.forEach(function(t) { //For each element in Table\n\t\t\tif(t.RangeName == oldName) {t.RangeName = newName} //Rename when needed\n\t\t});\n\t\treturn this;\n\t}\n\tgetPair(rangeName) { //Return the object data registered for this pair, for the range having the name passed \n\t\treturn this.Table.find(function(t) {return t.RangeName == rangeName});\n\t}\n}","//***********************************************************************\n//PAIRING Object - To handle data pairing between results and definitions\n//***********************************************************************\nclass Pairing {\n\tconstructor(r) {\n\t\tthis.Result = r;\n\t\tthis.Pairs = Array(r.PlatesID.length); //An array of pair object. Each item corresponds to the pairing data for the plate at the same index in the PlatesID array\n\t\t//this.Mode = undefined;\n\t\treturn this;\n\t}\n\t//Static Methods\n\tstatic form(results, ranges) { //Open a form to manipulate data pairing\n\t\tlet id = \"Form_Pairing\";\n\t\tlet Anchors = {\n\t\t\tDef: id + \"_Def\",\n\t\t\tResult: id + \"_Res\",\n\t\t\tAuto: id + \"_Auto\",\n\t\t\tPreview: id + \"_Preview\",\n\t\t}\n\t\tlet action = function(r) {\n\t\t\tPairing.preview(Tables, Anchors.Preview); //Build the preview of pairing\n\t\t}\n\t\tlet Tables = {\n\t\t\tRanges: new RespTable({ID: Anchors.Def, Array: ranges, Fields: [\"Name\", \"DefInfo\"], Headers: [\"Range\", \"Properties\"], NoControls: true}),\n\t\t\tResults: new RespTable({ID: Anchors.Result, Array: results, Fields: [\"Name\", \"Plate Count\"], NoControls: true,\n\t\t\t\tonSelect: function(newSelect) {action(newSelect[0])}\n\t\t\t}),\n\t\t}\n\t\tForm.open({\n\t\t\tID: id,\n\t\t\tHTML:\n\t\t\t\t\"<fieldset style=\\\"width: 350px; float: left; overflow: auto\\\" title=\\\"Select a result file to display the corresponding pairing table below\\\">\" +\n\t\t\t\t\t\"<legend>Results available</legend><div id=\\\"\" + Anchors.Result + \"\\\"></div></fieldset>\" +\n\t\t\t\t\"<fieldset style=\\\"width: 350px; float: left; overflow: auto\\\">\" +\n\t\t\t\t\t\"<legend>Definitions available</legend><div id=\\\"\" + Anchors.Def + \"\\\"></div></fieldset>\" +\n\t\t\t\t\"<fieldset style=\\\"width: 500px; clear: both; overflow: auto; float: left\\\">\" +\n\t\t\t\t\t\"<legend>Pairing Table</legend><div id=\\\"\" + Anchors.Preview + \"\\\" style=\\\"max-height: 300px; overflow: auto;\\\"></div></fieldset>\" +\n\t\t\t\t\"<fieldset style=\\\"width: 200px; float: left\\\">\" +\n\t\t\t\t\t\"<legend>Auto-pairing</legend><div id=\\\"\" + Anchors.Auto + \"\\\"></div></fieldset>\",\n\t\t\tTitle: \"Data pairing\",\n\t\t\tSize: 800,\n\t\t\tButtons: [\n\t\t\t\t{Label: \"Reset\", Icon: {Type: \"Reset\", Space: true, Color: \"Red\"}, Click: function() {\n\t\t\t\t\tlet r = Tables.Results.Selected[0]; //The selected result file\n\t\t\t\t\tr.Pairing = new Pairing(r); //Reset the pairing object\n\t\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Build the preview\n\t\t\t\t}, Title: \"Delete all pairing data for the selected result\"},\n\t\t\t\t{Label: \"Done\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() { //Finished edited the pairing\n\t\t\t\t\tlet result = Tables.Results.Selected[0]; //The selected result object\n\t\t\t\t\tEditor.ResultManager.Results.update(); //Update the table to have the correct result file selected\n\t\t\t\t\tEditor.ResultManager.draw(result); //Redraw to set the linked plate and update the display\n\t\t\t\t\tForm.close(id);\n\t\t\t\t} }\n\t\t\t],\n\t\t\tonInit: function() {\n\t\t\t\tlet b = LinkCtrl.buttonBar([\n\t\t\t\t\t{Label: \"By plate name\", Click: function() {\n\t\t\t\t\t\tPairing.autoPairing(\"Name\", Tables);\n\t\t\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Re-build the preview after auto-pairing\n\t\t\t\t\t}, Title: \"Click to automatically pair the plates of the selected result and definition, using their names\"},\n\t\t\t\t\t{Label: \"By plate index\", Click: function() {\n\t\t\t\t\t\tPairing.autoPairing(\"Index\", Tables);\n\t\t\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Re-build the preview after auto-pairing\n\t\t\t\t\t}, Title: \"Click to automatically pair the plates of the selected result and definition, using their index\"},\n\t\t\t\t]);\n\t\t\t\tGetId(Anchors.Auto).insertAdjacentElement(\"beforeend\", b);\n\t\t\t\tObject.values(Tables).forEach(function(t) {t.init()}); //Init the tables\n\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Build the pairing preview for the selected elements on opening of the form \n\t\t\t},\n\t\t});\n\t}\n\tstatic preview(Tables, target) { //Build the html preview of the items paired and display it in the element with ID target\n\t\tlet r = Tables.Results.Selected[0]; //The selected result file\n\t\tlet html = \"\";\n\t\tlet b = LinkCtrl.button({Label: \"\", Icon: {Type: \"Edit\"}, Title: \"Click here to edit the pairing for this plate\"});\n\t\tif(r.Pairing === undefined) {r.Pairing = new Pairing(r)}\n\t\thtml = \"<table class=\\\"Table PreviewTable\\\"><tr><th>Result Plate</th><th>Status</th></tr>\";\n\t\tr.PlatesID.forEach(function(p, i) {\n\t\t\thtml += \"<tr><td>\" + p + \"</td><td>\";\n\t\t\tlet pair = r.Pairing.Pairs[i];\n\t\t\tif(pair !== undefined) {\n\t\t\t\tif(pair.state !== undefined) {html += pair.state().Html}\n\t\t\t\t//\n\t\t\t\t//\n\t\t\t\telse {html += pair} //We assume in this case that a text is present, yet to be decided\n\t\t\t\t//\n\t\t\t\t//\n\t\t\t}\n\t\t\telse {html += Pair.unpaired().Html}\n\t\t\thtml += \"</td><td class=\\\"Pairing_Edit_TR\\\">\" + b.outerHTML + \"</td></tr>\";\n\t\t});\n\t\thtml += \"</table>\";\n\t\tlet t = GetId(target);\n\t\tt.innerHTML = html;\n\t\tlet collection = t.getElementsByClassName(\"Pairing_Edit_TR\");\n\t\tlet l = collection.length;\n\t\tfor(let i=0; i<l; i++) {\n\t\t\tcollection[i].children[0].addEventListener(\"click\", function(e) {\n\t\t\t\tPairing.editPair(r, /*d,*/ i, Tables, target);\n\t\t\t});\n\t\t}\n\t}\n\tstatic editPair(r, /*d,*/ i, Tables, target) { //Open a form for edition of the pair for result r, plate index i, definition d. On edit, update the preview using Tables and target\n\t\tlet d = Tables.Ranges.Selected[0].Definition; //The selected definition\n\t\tlet id = \"Form_Pairing_Inner\";\n\t\tlet Anchors = {\n\t\t\tOptions: id + \"_Options\",\n\t\t}\n\t\tlet ctrl = { //LinkCtrl objects in the form\n\t\t\tPlates: LinkCtrl.new(\"Select\", {ID: Anchors.Options, Default: 0, List: d.PlatesID, NavBar: true, Lookup: true}),\n\t\t};\n\t\tForm.open({\n\t\t\tID: id,\n\t\t\tHTML: \"<fieldset><legend>Plates available</legend><div id=\\\"\" + Anchors.Options + \"\\\"></div></fieldset>\",\n\t\t\tTitle: \"Edit pairing\",\n\t\t\tButtons: [\n\t\t\t\t{Label: \"Ok\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() {\n\t\t\t\t\tif(r.Pairing.Pairs[i] === undefined) {r.Pairing.Pairs[i] = new Pair()}\n\t\t\t\t\tr.Pairing.Pairs[i].register({RangeName: d.Area.Name, DefPlateIndex: ctrl.Plates.getValue(), DefPlateName: ctrl.Plates.Selected});\n\t\t\t\t\tPairing.preview(Tables, target);\n\t\t\t\t\tForm.close(id);\n\t\t\t\t}.bind(this)},\n\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {Form.close(id)}}\n\t\t\t],\n\t\t\tonInit: function() {\n\t\t\t\tObject.values(ctrl).forEach(function(c) {c.init()}); //Init the controls\n\t\t\t},\n\t\t});\n\t}\n\tstatic setLinkedPlate(result, plateIndex, target) { //For the result object passed, set the correct plates for the linked definition and show the pairing data in the provided target\n\t\tif(result.Pairing === undefined) { //No pairing set\n\t\t\tthis.status(target, Pair.unpaired());\n\t\t} \n\t\telse { //Pairing available\n\t\t\tlet pair = result.Pairing.Pairs[plateIndex];\n\t\t\tif(pair === undefined || pair.setDefPlate === undefined) {this.status(target, Pair.unpaired())} //Pairing object but empty pair at this location\n\t\t\telse { //Pair object exist, get its status\n\t\t\t\tlet O = pair.setDefPlate().state();\n\t\t\t\tthis.status(target, O);\n\t\t\t}\n\t\t}\n\t}\n\tstatic status(target, I) { //Update the html output in target to match the state provided. Use the options provided when needed to build the message\n\t\tlet ctrl = LinkCtrl.button({ //The button to edit the pairing\n\t\t\tLabel: \"\", Icon: {Type: \"Setting\"}, Title: \"Click here to edit the pairing setting\", Click: function() {Editor.pairing()}\n\t\t});\n\t\tlet html = \"\";\n\t\tswitch(I.State) {\n\t\t\tcase \"unpaired\":\n\t\t\t\thtml = I.Html;\n\t\t\t\tbreak;\n\t\t\tcase \"paired\":\n\t\t\t\thtml = I.Html;\n\t\t\t\tbreak;\n\t\t\tcase \"broken\":\n\t\t\t\tctrl = LinkCtrl.button({ //The button to restore the pairing will replace the button to access the settings\n\t\t\t\t\tLabel: \"\", Icon: {Type: \"Reset\"}, Click: function() {\n\t\t\t\t\t\tlet result = Editor.Tables.Results.Selected[0]; //The selected result\n\t\t\t\t\t\tlet plateIndex = Editor.ResultManager.PlateSelect.getValue(); //The selected result plate (index)\n\t\t\t\t\t\tPairing.setLinkedPlate(result, plateIndex, target); //Set the correct plates. This will call the status() method as well and update the display\n\t\t\t\t\t}, Title: \"Click here to set the definition plates as defined in the pairing setting\"\n\t\t\t\t});\n\t\t\t\thtml = I.Html;\n\t\t\t\tbreak;\n\t\t}\n\t\tGetId(target).innerHTML = html; //Update the message\n\t\tGetId(target).insertAdjacentElement(\"beforeend\", ctrl); //Insert the button\n\t}\n\tstatic update(target) { //Check and update the selected result to reflect current Pairing status\n\t\tlet r = Editor.ResultManager.Results.Selected[0]; //The selected result\n\t\tif(r === undefined) {return} //Nothing to do if no results are selected\n\t\tlet index = Editor.ResultManager.PlateSelect.getValue(); //The selected plate\n\t\tif(r.Pairing !== undefined && r.Pairing.Pairs[index] !== undefined && r.Pairing.Pairs[index].update !== undefined) {\n\t\t\tlet O = r.Pairing.Pairs[index].update();\n\t\t\tPairing.status(target, O);\n\t\t}\n\t}\n\tstatic updateAll(target) { //Update all the pairing data for all the result file. This is typically necessary when definitions are edited/deleted\n\t\tEditor.ResultManager.Results.Array.forEach(function(r) { //For each result file\n\t\t\tif(r.Pairing !== undefined) { //If the result has a pairing defined\n\t\t\t\tlet index = -1; //We use this to track the selected plate. Default is a faulty value for all plates\n\t\t\t\tif(r.Selected) { //If this result file is selected, get the selected plate index to update the status of the pairing\n\t\t\t\t\tindex = Editor.ResultManager.PlateSelect.getValue(); //The selected plate\n\t\t\t\t}\n\t\t\t\tr.Pairing.Pairs.forEach(function(p, i) { //For each pair\n\t\t\t\t\tif(p !== undefined && p.update !== undefined) { //If this item is a pair object, update it\n\t\t\t\t\t\tlet O = p.update({All: true});\n\t\t\t\t\t\tif(i == index) {Pairing.status(target, O)} //Update the display for the element currently visible\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\t}\n\tstatic resize(result) {\n\t\tif(result.Pairing === undefined) {return} //Nothing to do in that case\n\t\tlet n = result.PlatesID.length;\n\t\tlet l = result.Pairing.Pairs.length;\n\t\tif(l == n) {return} //Same size, nothing to change\n\t\tif(l < n) { //Add missing elements\n\t\t\twhile(l < n) {\n\t\t\t\tresult.Pairing.Pairs.push(new Pair());\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\telse { //Too much elements, need to remove the excess\n\t\t\tresult.Pairing.Pairs.splice(n, l-n);\n\t\t}\n\t}\n\tstatic rename(oldName, newName) { //Travel the pair objects and rename the definition using old/new name parameters provided\n\t\tEditor.ResultManager.Results.Array.forEach(function(r) { //For every result available\n\t\t\tif(r.Pairing !== undefined) { //If a pairing object exist\n\t\t\t\tr.Pairing.Pairs.forEach(function(p) {\n\t\t\t\t\tif(p !== undefined && p.rename !== undefined) { //If a pair object is defined here, do the rename\n\t\t\t\t\t\tp.rename(oldName, newName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\tstatic autoPairing(type, Tables) {\n\t\tlet r = Tables.Results.Selected[0]; //Selected result\n\t\tlet d = Tables.Ranges.Selected[0].Definition; //Selected definition\n\t\tlet count = 0; //How many pairs are found\n\t\tlet defID = d.PlatesID;\n\t\tif(type == \"Name\") { //Pair by name\n\t\t\tr.PlatesID.forEach(function(p, i) { //For each plate in the PlatesID array of the result object, search for a match in the Definition array\n\t\t\t\tlet val = defID.findIndex(function(e) {return e == p}); //Search for a match\n\t\t\t\tif(val > -1) { //Pair if a match is found\n\t\t\t\t\tif(r.Pairing.Pairs[i] === undefined) {r.Pairing.Pairs[i] = new Pair()} //Create a new pair when needed\n\t\t\t\t\tr.Pairing.Pairs[i].register({RangeName: d.Area.Name, DefPlateIndex: val, DefPlateName: defID[val]});\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse { //Pair by index\n\t\t\tr.PlatesID.forEach(function(p, i) { //For each plate in the PlatesID array of the result object, match with the equivalent index in the Definition array, if it exists\n\t\t\t\tlet val = defID[i];\n\t\t\t\tif(val !== undefined) { //Pair if a match is found\n\t\t\t\t\tif(r.Pairing.Pairs[i] === undefined) {r.Pairing.Pairs[i] = new Pair()} //Create a new pair when needed\n\t\t\t\t\tr.Pairing.Pairs[i].register({RangeName: d.Area.Name, DefPlateIndex: i, DefPlateName: val});\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif(count == 0) {alert(\"no matches found!\")}\n\t\telse {\n\t\t\tlet plural = \"\";\n\t\t\tif(count > 1) {plural = \"es\"}\n\t\t\talert(count + \" match\" + plural + \" found\");\n\t\t}\n\t}\n\t//Methods\n\t\n}","//********************************************************************************\n// REPORTER object - Allow construction of specific report pages for data analysis\n//********************************************************************************\nclass Reporter {\n\tconstructor() {return this}\n\t//Static Methods\n\tstatic htmlHeader(title) {\n\t\tlet h = \"<!DOCTYPE HTML>\\n\";\n\t\th += \"<html>\\n\";\n\t\th += \"<head>\\n\";\n\t\th += \"\\t<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\";\n\t\th += \"\\t<title>\" + title + \"</title>\\n\";\n\t\th += \"\\t<link href=\\\"dist/ui-styles.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\";\n\t\th += \"\\t<link href=\\\"dist/analyzer-styles.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\";\n\t\th += \"\\t<link href=\\\"dist/shared-styles.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\";\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dist/ui.min.js\\\"></script>\\n\";\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dist/shared.min.js\\\"></script>\\n\";\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dist/analyzer.min.js\\\"></script>\\n\";\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dependencies/jszip.min.js\\\"></script>\\n\";\n\t\treturn h;\n\t}\n\tstatic header(I) { //Prepare the header for the html report page\n\t\tlet title = (I.Title || \"Report\");\n\t\tlet html = this.htmlHeader(I.Method);\n\t\thtml +=\"\\t<script type=\\\"text/javascript\\\">window.onload = function() {Analyzer.init({Method: \\\"\" + I.Method + \"\\\", Title: \\\"\" + title + \"\\\"})}</script>\\n\"; //Script to init the Analyzer on loading the page\n\t\thtml += \"</head>\\n\";\n\t\thtml += \"<body style=\\\"font-family: arial; font-size: 16px\\\">\\n\";\n\t\thtml += \"<div id=\\\"Header\\\">\\n\"; //Header\n\t\thtml += \"\\t<p><b>\" + title + \"</b></p>\\n\";\n\t\thtml += \"</div>\\n\";\n\t\thtml += \"<div id=\\\"Main\\\">\\n\";  //Opening of the main report div\n\t\treturn html;\n\t}\n\tstatic footer() { //Prepare the footer for the html report\n\t\tlet f = \"</div>\\n\"; //Closure of Main report div\n\t\tf += \"<div id=\\\"Footer\\\">\\n\"; //Footer\n\t\tf += \"\\t<p>Generated&nbsp;<script>document.write(Date())</script>.</p>\\n\";\n\t\tf += \"</div>\\n\";\n\t\tf += \"</body>\\n\";\n\t\tf += \"</html>\\n\";\n\t\treturn f;\n\t}\n\tstatic openPage(html) { //Open a page with html as content\n\t\tlet win = window.open(); //Show report\n\t\twin.document.write(html); //Write the html content\n\t\twin.document.close();\n\t\twin.focus(); //Focus on the newly opened page\n\t}\n\tstatic openReport(body, I) { //Open the report as a new HTML page\n\t\tlet report = this.header(I) + body + this.footer(); //Assemble the report\n\t\tthis.openPage(report);\n\t}\n\tstatic printable(html) { //Open a blank page containing only the html provided, that can be used for copy-pasting or printing operations\n\t\tlet h = this.htmlHeader(\"Printable\");\n\t\th += \"</head>\\n\";\n\t\th += \"<body style=\\\"font-family: arial; font-size: 16px\\\">\\n\";\n\t\tthis.openPage(h + html + \"\\n</body></html>\");\n\t}\n\tstatic combination(o, I) { //Compute the combinations of unique elements by checking concentrations and tags overlap\n\t\tlet out = {};\n\t\tObject.values(o).forEach(function(array, k) { //The object contains different categories. Each will be treated separately and the results returned as arrays in their initial categories\n\t\t\tif(Array.isArray(array)) { //Values that are not arrays are ignored\n\t\t\t\tlet key = Object.keys(o)[k]; //The key corresponding to the value\n//************************************************\n//Not sure at this point about the order, so doing\n//like this makes it more flexible for the future\n\t\t\t\tlet updated = array;\n\t\t\t\tif(I.Conc) {updated = this.combineConc(updated)}\n\t\t\t\tif(I.Tags) {updated = this.combineTags(updated)}\n//************************************************\n\t\t\t\tout[key] = updated;\n\t\t\t}\n\t\t}, this);\n\t\treturn out;\n\t}\n\tstatic combineConc(array) { //For the array of objects supplied, use the concentrations data to divide the original arrays into individual arrays of aggregated objects with their own tags\n\t\tlet flatConcNames = [];\n\t\tlet flatConcTags = [];\n\t\tarray.forEach(function(a) { //Loop the array of objects provided. Each element is an object with a name, as well as Tags/Concs properties defined as arrays\n\t\t\ta.Conc.forEach(function(c, i) { //Loop the concentrations\n\t\t\t\tlet name = a.Name;\n\t\t\t\tif(c.length > 0) {name += \" \" + c}\n\t\t\t\tlet index = flatConcNames.indexOf(name);\n\t\t\t\tif(index == -1) {flatConcNames.push(name); flatConcTags.push([a.Tags[i]])} //Does not exist, create it\n\t\t\t\telse {flatConcTags[index].push(a.Tags[i])} //Update existing entry\n\t\t\t});\n\t\t});\n\t\tlet output = [];\n\t\tflatConcNames.forEach(function(n, i) {\n\t\t\toutput.push({Name: n, Tags: flatConcTags[i]});\n\t\t});\n\t\treturn output;\n\t}\n\tstatic combineTags(array) { //For the array of objects supplied, use the tags data to divide the original arrays into individual arrays of aggregated objects with their own tags\n\t\tlet allNames = [];\n\t\tlet uniqueIndex = [];\n\t\tarray.forEach(function(a) { //In the first pass, travel each area tags array and collect all names appearing for each index\n\t\t\ta.Tags.forEach(function(t) { //Go throught the tags\n\t\t\t\tlet index = uniqueIndex.indexOf(t);\n\t\t\t\tif(index == -1) { //New entry found\n\t\t\t\t\tuniqueIndex.push(t);\n\t\t\t\t\tallNames.push([a.Name]);\n\t\t\t\t}\n\t\t\t\telse {allNames[index].push(a.Name)} //Update existing entry\n\t\t\t});\n\t\t});\n\t\tlet output = [];\n\t\tlet uniqueNames = [];\n\t\tallNames.forEach(function(n, i) { //In the second pass, travel the name array and accumulate unique names with their tags\n\t\t\tlet name = n.sort().join(\" / \"); //Sort the name array so that we can compare always the same final name\n\t\t\tlet index = uniqueNames.indexOf(name);\n\t\t\tif(index == -1) { //New entry found\n\t\t\t\tuniqueNames.push(name);\n\t\t\t\toutput.push({Name: name, Tags: [uniqueIndex[i]]});\n\t\t\t}\n\t\t\telse {output[index].Tags.push(uniqueIndex[i])} //Update existing entry\n\t\t});\n\t\treturn output;\n\t}\n\tstatic zFactor(controls) { //Compute z-score for the result file passed, using the controls provided\n\t\twindow.zFactor = {\n\t\t\tControls: this.combination(controls, {Conc: true, Tags: true}),\n\t\t}\n\t\tthis.openReport(\"\", {Title: \"Control Report\", Method: \"zFactor\"});\n\t}\n\t/*static aggregate(areas, conc) { //Compute stats for the result file passed, using the areas provided\n\t\tareas.R.forEach(function(range) {\n\t\t\tareas.A = areas.A.concat(range.Values); //Concat all individual rangeIndex to the areas\n\t\t});\n\t\twindow.Aggregate = {\n\t\t\tCombinations: this.combination({A: areas.A}, {Conc: true, Tags: true}),\n\t\t}\n\t\tthis.openReport(\"\", {Title: \"Column Report\", Method: \"Aggregate\"});\n\t}*/\n\tstatic grouped(areas, conc, I) { //Compute stats for the result file passed, using the areas provided and organizing data as two-entry tables\n\t\twindow.Grouped = {\n\t\t\tAreas: areas.A,\n\t\t\tConc: conc,\n\t\t\tRanges: areas.R,\n\t\t\t//Definitions: areas.D,\n\t\t}\n\t\tif(I && I.ColumnOnly) {\n\t\t\tthis.openReport(\"\", {Title: \"Column Report\", Method: \"Aggregate\"});\n\t\t}\n\t\telse {\n\t\t\tthis.openReport(\"\", {Title: \"Grouped Report\", Method: \"Grouped\"});\n\t\t}\n\t}\n\tstatic hits(controls, areas, layout) { //Finds the hits above the given thresholds\n\t\twindow.Hits = {\n\t\t\tControls: this.combination(controls, {Conc: true, Tags: true}),\n\t\t\tLayout: layout,\n\t\t\tRanges: areas.R,\n\t\t\tDefinitions: areas.D,\n\t\t}\n\t\tthis.openReport(\"\", {Title: \"Hit Selection\", Method: \"Hits\"});\n\t}\n}","//************************************\n// UNIT object - Class to handle units\n//************************************\nclass Unit {\n\tconstructor() {}\n\t//Static Methods\n\tstatic units() { //Returns an array with all the available unit objects\n\t\treturn [\n\t\t\t{Name: \"M\"},\n\t\t\t{Name: \"mM\", Root: \"M\", Shift: -3},\n\t\t\t{Name: \"M\", Root: \"M\", Shift: -6},\n\t\t\t{Name: \"nM\", Root: \"M\", Shift: -9},\n\t\t\t{Name: \"pM\", Root: \"M\", Shift: -12},\n\t\t\t{Name: \"g/L\"},\n\t\t\t{Name: \"g/mL\"},\n\t\t\t{Name: \"mg/mL\", Root: \"g/mL\", Shift: -3},\n\t\t\t{Name: \"g/mL\", Root: \"g/mL\", Shift: -6},\n\t\t\t{Name: \"ng/mL\", Root: \"g/mL\", Shift: -9},\n\t\t\t{Name: \"pg/mL\", Root: \"g/mL\", Shift: -12},\n\t\t\t{Name: \"%\"},\n\t\t\t{Name: \"u/mL\"},\n\t\t\t{Name: \"ku/mL\", Root: \"u/mL\", Shift: 3},\n\t\t\t{Name: \"Mu/mL\", Root: \"u/mL\", Shift: 6},\n\t\t\t{Name: \"MOI\", Invert: true},\n\t\t\t{Name: \"\"},\n\t\t\t{Name: \"a.u\"},\n\t\t];\n\t}\n\tstatic list(I) { //Returns a list of all the available units\n\t\tlet l = this.units();\n\t\tif(I && I.Name) {return l.map(function(u) {return u.Name})} //Only the names\n\t\treturn l;\n\t}\n\tstatic shiftForUnit(unit) { //For the unit provided, return the shift needed to reach the mother unit, in log scale\n\t\tlet l = this.units();\n\t\tlet here = l.find(function(u) {return u.Name == unit});\n\t\treturn (here.Shift || 0);\n\t}\n\tstatic rootForUnit(unit) { //For the unit provided, return the shift needed to reach the mother unit, in log scale\n\t\tlet l = this.units();\n\t\tlet here = l.find(function(u) {return u.Name == unit});\n\t\treturn (here.Root || unit);\n\t}\n\tstatic string(unit, value) { //Return the string for the unit and value given\n\t\tswitch(unit) {\n\t\t\tcase \"MOI\": return unit + \" \" + value; //Unit goes first, need a space\n\t\t\tcase \"%\": //FALL-THROUGH\n\t\t\tcase \"\": return unit + value; //No space\n\t\t\tdefault: return value + \" \" + unit;\n\t\t}\n\t}\n}","//***************************************************************************************\n// WORKER object - Class for spawning and handling input/output to a set of webworkers\n//***************************************************************************************\nclass WorkerGroup {\n\tconstructor(I) {\n\t\tthis.Anchors = {\n\t\t\tRoot: I.ID,\n\t\t\tOptions: I.ID + \"_Options\",\n\t\t\tControls: I.ID + \"_Controls\",\n\t\t\tProgress: I.ID + \"_Progress\",\n\t\t}\n\t\tthis.Process = {\n\t\t\tworkerProcess: I.workerProcess, //function to execute inside the worker\n\t\t\tjoinResults: I.joinResults, //function to execute while receiving data from an independent Worker. Typically the data should be merged together\n\t\t\tcheckChunkDone: I.checkChunkDone, //function to execute to check if the current chunk is done and if it is possible to move to the next chunk\n\t\t\tnextChunk: I.nextChunk, //Function to execute while moving to the next chunk\n\t\t}\n\t\tlet MaxThread = navigator.hardwareConcurrency;\n\t\tlet list = [];\n\t\tfor(let i=1; i <= MaxThread; i++) {list.push(i)} //Create a simple list to select the number of workers desired\n\t\tthis.Options = { //Options for the worker group\n\t\t\tChunkSize: LinkCtrl.new(\"Number\", {\n\t\t\t\tID: this.Anchors.Options, Label: \"Chunk Size\", Title: \"Size of the chunks to be transfered to each worker\",\n\t\t\t\tDefault: 1000, Min: 10, Max: 100000,\n\t\t\t\tChain: {Index: 0}\n\t\t\t}),\n\t\t\tThread: LinkCtrl.new(\"Select\", {\n\t\t\t\tID: this.Anchors.Options, Label: \"Threads\", Title: \"Number of workers to use\",\n\t\t\t\tList: list, Default: MaxThread - 1, //Will use the max number of threads as default\n\t\t\t\tChain: {Index: 1, Last: true}\n\t\t\t}),\n\t\t}\n\t\tGetId(this.Anchors.Root).insertAdjacentHTML(\"afterbegin\", \"<div id='\" + this.Anchors.Options + \"'></div><div id='\" + this.Anchors.Controls + \"'></div><div id='\" + this.Anchors.Progress + \"'></div>\"); //Create the html elements to host the worker options, controls and progress fields\n\t\tObject.values(this.Options).forEach(function(t) {t.init()}); //initialize the options\n\t\tthis.Data = { //Object used to track the progress of the process\n\t\t\tPercent: 0,\n\t\t\tTotalRows: I.TotalRows,\n\t\t\tCurrentRow: 0,\n\t\t}\n\t\tlet buttons = [\n\t\t\t{Label: \"Start\", Click: function() {this.start()}.bind(this), Title: \"Start the process\"},\n\t\t\t{Label: \"Pause\", Click: function() {this.pause()}.bind(this), Title: \"Pause the process\"},\n\t\t\t{Label: \"Resume\", Click: function() {this.resume()}.bind(this), Title: \"Resume the process\"},\n\t\t\t{Label: \"Cancel\", Click: function() {this.stop()}.bind(this), Title: \"Cancel the process\"},\n\t\t];\n\t\tif(this.Anchors.Controls !== null) {\n\t\t\tGetId(this.Anchors.Controls).append(LinkCtrl.buttonBar(buttons)); //initialize the buttons\n\t\t}\n\t\tthis.processStatus(\"start\");\n\t}\n\t//Static Methods\n\t\n\t//Methods\n\tprocessStatus(state) {\n\t\tif(this.Anchors.Progress === null) {return} //No need to do anything if there is no spot to display the status message\n\t\tlet O = this.Data;\n\t\tlet msg = \"\";\n\t\tlet percent = \"Completed \" + O.CurrentRow + \" rows (\" + O.Percent + \"%). \";\n\t\tswitch(state) {\n\t\t\tcase \"start\": msg = \"Ready to go! Click Start to proceed\"; break;\n\t\t\tcase \"pauseWait\":  msg = \"Waiting for worker to pause... \"; break;\n\t\t\tcase \"Paused\": msg = \"Worker paused. \" + percent; break;\n\t\t\tcase \"cancel\": msg = \"Work cancelled. \" + percent; break;\n\t\t\tcase \"resumeWait\": msg = \"Resuming work... \"; break;\n\t\t\tcase \"done\": msg = \"Work completed! \"; break;\n\t\t\tdefault: msg = \"Work on-going... \" + percent;\n\t\t}\n\t\tGetId(this.Anchors.Progress).innerHTML = \"<p>\" + msg + \"</p>\";\n\t}\n\tstart() {\n\t\tlet n = this.Options.Thread.Selected;\n\t\tlet chunk = this.Options.ChunkSize.getValue();\n\t\tthis.Data.Thread = n; //Log the number of thread at the start and always refer to this fixed value during the process\n\t\tthis.Workers = [];\n\t\tfor(let i=0; i < n; i++) { //Initialize all the subworkers\n\t\t\tthis.Workers.push(this.spawnWorker(i));\n\t\t}\n\t\tthis.Data.Results = Array(chunk).fill(\"\"); //Array to store the Results received from each worker\n\t\tthis.Data.Done = Array(n).fill(false); //Array to determine which worker is done or still running\n\t\tthis.processStatus();\n\t\tthis.nextChunk(this.Data);\n\t}\n\tpause() {\n\t\tthis.processStatus(\"pauseWait\");\n\t\tthis.Workers.forEach(function(w) {\n\t\t\tw.postMessage({Pause: true});\n\t\t});\n\t}\n\tresume() {\n\t\tthis.Workers.forEach(function(w) {\n\t\t\tw.postMessage({Resume: true});\n\t\t});\n\t}\n\tcancel() {\n\t\tthis.processStatus(\"cancel\");\n\t\tthis.Workers.forEach(function(w) {w.terminate()}); //Kill the workers\n\t\tthis.Workers = undefined; //Garbage collection\n\t}\n\tonWorkerMessage(n, I) { //The main thread received a message from a worker\n\t\tlet O = this.Data;\n\t\tthis.Process.joinResults(O, I); //Join the results from each worker into a single result output\n\t\tO.Done[I.WorkerDone] = true;\n\t\tlet bool = O.Done.reduce(function(a, b) {return a && b}); //Check if there are still workers processing some data\n\t\tif(bool == false) { //Wait for all worker to submit their results\n\t\t\treturn;\n\t\t}\n\t\telse { //All workers have finished\n\t\t\tif(this.Process.checkChunkDone(O, I)) { //Check if the conditions are met to pass to the next chunk\n\t\t\t\tthis.nextChunk(O, I);\n\t\t\t\tO.Results = Array(O.ChunkSize.getValue()).fill(\"\");\n\t\t\t}\n\t\t\tO.Done = Array(n).fill(false);\n\t\t}\n\t}\n\tnextChunk(O, I) {\t\n\t\tif(O.CurrentRow >= O.TotalRows) { //All rows have been processed, terminate\n\t\t\tthis.processStatus(\"done\");\n\t\t\tthis.stop();\n\t\t\treturn;\n\t\t}\n\t\tthis.Process.nextChunk(O, I);\n\t}\n\tspawnWorker(index) { //Spawn the worker at index i\n\t\t//Prepare the function to be injected inside the worker, to be executed as onmessage event\n\t\tlet f = \"function(e) {\"; //Need to prepare the function as a string to be injected in the embedded worker through blob\n\t\tf+= \"let I = e.data;\"; //Incoming object\n\t\tf+= \"if(I.Pause) {self.Running = false; return}\";\n\t\tf+= \"if(I.Resume) {\";\n\t\tf+= \"\tif(self.Running == false) {\";\n\t\tf+= \"\t\tself.Running = true;\";\n\t\tf+= \"\t\tpostMessage({Resume: true});\";\n\t\tf+= \"\t\treturn;\";\n\t\tf+= \"\t}\";\n\t\tf+= \"}\";\n\t\tf+= \"if(self.Running) {\"\n\t\tf+= this.Process.workerProcess().toString(); //Append the full code of the function to be executed inside the worker\n\t\t\t\t//Instructions with postMessage({Done: true}) is required \n\t\tf+= \"\tif(!self.Running) {postMessage({Paused: true})}\";\n\t\tf+= \"}\";\n\t\tf+= \"else {postMessage({Paused: true})}\";\n\t\tf+= \"}\";\n\t\t//Create the worker with the above instructions\n\t\tlet blob = new Blob([\"self.Index = \" + index + \"; self.Running = true; onmessage = \" + f], {type: \"application/javascript\"});\n\t\tlet w = new Worker(URL.createObjectURL(blob));\n\t\t//Create the code to be executed on the main thread when the worker sends its message\n\t\tw.onmessage = function(e) { //What to do when the worker sends a message\n\t\t\tlet R = e.data; //Data received from the worker\n\t\t\tlet O = this.Data;\n\t\t\tif(R.Done) {\n\t\t\t\tthis.onWorkerMessage(O, I);\n\t\t\t\tthis.processStatus(); //Update the status after the onWorkerMessage function is done, so that changes in % completion are displayed accordingly\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(R.Resume) {\n\t\t\t\tthis.processStatus(\"resumeWait\");\n\t\t\t\tthis.onWorkerMessage(O, I);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(R.Paused) {\n\t\t\t\tthis.processStatus(\"Paused\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}.bind(this);\n\t\treturn w;\n\t}\n}","function GetId(id) {return document.getElementById(id)}","//*******************************************************************************\n// INPUTOBJECT_FILE - Object for input file and tracking of their parsing options\n//*******************************************************************************\nclass InputObject_File extends InputObject {\n\tconstructor(file) {\n\t\tsuper();\n\t\tthis.RawData = file; //Raw data for the input: original file object from the browser\n\t\tthis.Source = \"File\";\n\t\tthis.Type = file.type;\n\t\tthis.Name = file.name;\n\t\tthis.Size = file.size;\n\t\tthis.Format = file.name.substring(file.name.lastIndexOf(\".\")); //Get the extension for the file\n\t\tif(this.Format == \".xlsx\") {this.Controls.Parser.Value = 1} //Set default value for files recognized as excel\n\t\tif(this.Format == \".xls\") {this.Controls.Parser.Value = 2}\n\t\tthis.InputParser = InputParser.new({Type: this.Controls.Parser.Selected, Data: this.RawData, Name: this.Name}); //Parser Object and its configuration\n\t\treturn this;\n\t}\n}","//**********************************************************************************************\n// INPUTOBJECT_MANUAL - Object from manual input of data, with tracking of their parsing options\n//**********************************************************************************************\nclass InputObject_Manual extends InputObject {\n\tconstructor(data) {\n\t\tsuper();\n\t\tlet d = data.Data;\n\t\tif(d === undefined) {console.warn(\"No data transfered to InputObject manual. Aborted\"); return this}\n\t\tthis.RawData = d; //Raw data for the input: original data submitted by the user\n\t\tthis.Source = \"Manual\";\n\t\tthis.Type = \"txt/plain\"; //Mimickry\n\t\tthis.Size = d.length;\n\t\tif(data.Name && data.Name.length > 0) { //Use provided name\n\t\t\tthis.Name = data.Name;\n\t\t}\n\t\telse { //Create a name based on the first characters within the input\n\t\t\tthis.Name = d.substring(0, 7);\n\t\t\tif(this.Size > 7) {this.Name += \"[...]\"}\n\t\t}\n\t\tthis.Format = \"-\"; //No extension because no file, so just a filler is used\n\t\tthis.Controls.Parser.List = [\"TXT/CSV\"]; //Excel not needed\n\t\tthis.InputParser = InputParser.new({Type: this.Controls.Parser.Selected, Data: this.RawData, Name: this.Name}); //Parser Object and its configuration\n\t\treturn this;\n\t}\n}","//**************************************************************\n// INPUTPARSER_PAPA - Object for parsing of data using papaParse\n//**************************************************************\nclass InputParser_Papa extends InputParser {\n\tconstructor(I) {\n\t\tsuper(I);\n\t\tthis.Type = \"Papa\";\n\t\tthis.Help = \"Parsing of text or csv files, based on the PapaParse library\";\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\n\t\tObject.assign(this.Options, {\n\t\t\tdelimiter: LinkCtrl.new(\"Text\", {\n\t\t\t\tID: target, Label: \"Delimiter\", Default: \"\", Preserve: true, /*NewLine: true,*/ Index: 5, Size: 5,\n\t\t\t\tChange: function() {this.parse()}.bind(this), Title: \"Delimiter used for parsing columns. Leave empty for auto-detection\",\n\t\t\t}),\n//*****************************************************\n//Not sure if it is useful because auto works just fine\n//*****************************************************\n\t\t\t/*newline: LinkCtrl.new(\"Text\", {\n\t\t\t\tID: target, Label: \"New line\", Default: \"\", Preserve: true, NewLine: true, Index: 6, Size: 5,\n\t\t\t\tChange: function() {this.parse()}.bind(this), Title: \"Character used as new line for parsing rows. Leave empty for auto-detection\",\n\t\t\t}),*/\n//*****************************************************\n\t\t});\n\t}\n\t//Methods\n\tinit() { //Display controls for available options\n\t\tObject.values(this.Options).forEach(function(o) {o.init()});\n\t\tlet tab = LinkCtrl.button({ID: \"insert-Tab\", Label: \"TAB\", Title: \"Click to insert a Tabulation\", Click: function() {this.Options.delimiter.setValue(\"\\t\").change()}.bind(this)});\n\t\tGetId(Form_Import.Anchors.ParserOptions).insertAdjacentElement(\"beforeend\", tab);\n\t\treturn this;\n\t}\n\tassignOptions(c) { //Assign the value of the options of the inputParser to the parsing config\n\t\tlet entries = Object.entries(this.Options).map(function(array) {return [array[0], array[1].getValue()]}); //Convert the LinkCtrl into their values\n\t\tObject.assign(c, Object.fromEntries(entries)); //Append the key/value pairs to Papa config\n\t\treturn c;\n\t}\n\tfirstParse(I) { //Parse the entire file to get nb of rows and columns available\n\t\tthis.TotalCols = 0; //Reset previous data\n\t\tthis.TotalRows = 0;\n\t\tlet PapaConfig = {\n\t\t\tworker: this.WebWorker, \n\t\t\theader: false,\n\t\t\tstep: function(R, parser) {\n\t\t\t\tparser.FirstParsed = false;\n\t\t\t\tlet l = R.data.length;\n\t\t\t\tif(l > this.TotalCols) {this.TotalCols = l}\n\t\t\t\tthis.TotalRows++;\n\t\t\t\tif(I && I.Step) {I.Step(R.data, this.TotalRows, parser)}\n\t\t\t}.bind(this),\n\t\t\tcomplete: function() { //After complete, parse again to get a preview\n\t\t\t\tthis.FirstParsed = true;\n\t\t\t\tthis.parse(I);\n\t\t\t}.bind(this),\n\t\t\terror: function(e) {\n\t\t\t\tthis.Error = true;\n\t\t\t\tthis.ErrorDetails = e;\n\t\t\t\tthis.parse(I); //We call the parse again so that the error message and status are reflected in the preview box and the input table\n\t\t\t\tif(I && I.Error) {I.Error(e)}\n\t\t\t}.bind(this),\n\t\t}\n\t\tPapa.parse(this.RawData, this.assignOptions(PapaConfig));\n\t}\n\tstream(f, complete, I) { //Stream the input and send the row to the function provided as argument\n\t\tlet o = this.parsingOptions();\n\t\tif(I && I.ApplyToHeader) {o.ApplyToHeader = true}\n\t\tlet PapaConfig = {\n\t\t\theader: false,\n\t\t\tworker: this.WebWorker,\n\t\t\tstep: function(R, parser) {\n\t\t\t\tparser.FirstParsed = this.FirstParsed;\n\t\t\t\tthis.processRow(R.data, parser, f, o);\n\t\t\t}.bind(this),\n\t\t\tcomplete: function() {\n\t\t\t\tif(complete) {complete(o.Selected, o)}\n\t\t\t},\n\t\t}\n\t\tPapa.parse(this.RawData, this.assignOptions(PapaConfig));\n\t}\n\t/*\n\tchunk(f, I) { //Chunk a piece of the input and apply the provided function on each chunk\n\t\tlet o = this.parsingOptions();\n\t\tif(I) {\n\t\t\tif(I.Start) {o.FirstRow += I.Start}\n\t\t\tlet rows = (I.Rows || 1000);\n\t\t}\n\t\tlet selected = -1; //Tracker for selected rows\n\t\tlet chunk = [];\n\t\tlet PapaConfig = {\n\t\t\theader: false,\n\t\t\tworker: this.WebWorker,\n\t\t\tstep: function(R, parser) {\n\t\t\t\tlet row = this.cleanRow(R.data, o);\n\t\t\t\tif(row) {\n\t\t\t\t\tif(selected >= rows) {parser.abort()}\n\t\t\t\t\tif(selected == -1) { //First selected row, exclude the header if present\n\t\t\t\t\t\tif(this.Options.NoHeaders.getValue()) {chunk.push(row); selected = 1}\n\t\t\t\t\t\telse {selected = 0}\n\t\t\t\t\t}\n\t\t\t\t\telse {chunk.push(row); selected++;}\n\t\t\t\t}\n\t\t\t\to.Index++;\n\t\t\t}.bind(this),\n\t\t\tcomplete: function() {f(chunk)},\n\t\t}\n\t\tPapa.parse(this.RawData, this.assignOptions(PapaConfig));\n\t}\n\t*/\n\t/*\n\tchunk(f, complete, I) { //Chunk a piece of the input and apply the provided function on each chunk\n\t\tPapa.LocalChunkSize = 500000; //500 kB\n\t\tvar r = this.Options.FirstRow.getValue() - 1; //Index of the first row\n\t\tvar c = this.Options.FirstCol.getValue() - 1; //Index of the first col\n\t\tvar i = 0; //Tracker for row index\n\t\tvar selected = 0;\n\t\tvar PapaConfig = {\n\t\t\theader: false,\n\t\t\tchunk: function(C, parser) {\n\t\t\t\tif(I && I.Pause) {parser.pause()} //Need pause/resume to ensure the function can run on each chunk one after the other\n\t\t\t\tvar clean_chunk = [];\n\t\t\t\tC.data.forEach(function(R) {\n\t\t\t\t\tvar row = this.cleanRow({Index: i, Data: R, FirstRow: r, FirstCol: c});\n\t\t\t\t\ti++;\n\t\t\t\t\tif(row) { //Exclude the header\n\t\t\t\t\t\tif(selected == 0) {selected++}\n\t\t\t\t\t\telse {clean_chunk.push(row)}\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t\tf(clean_chunk, parser);\n\t\t\t}.bind(this),\n\t\t\tcomplete: function() {\n\t\t\t\tif(complete) {complete()}\n\t\t\t},\n\t\t}\n\t\tif(I && I.Pause) {\n\t\t\tPapaConfig.worker = false; //Need this to access the pause/resume functions in the step\n\t\t}\n\t\telse {PapaConfig.worker = this.WebWorker}\n\t\tvar entries = Object.entries(this.Options).map(function(array) {return [array[0], array[1].getValue()]}); //Convert the LinkCtrl into their values\n\t\tObject.assign(PapaConfig, Object.fromEntries(entries)); //Append the key/value pairs to Papa config\n\t\tPapa.parse(this.RawData, PapaConfig);\n\t}\n\t*/\n}\n\n","//***********************************************************************\n// INPUTPARSER_XLS - A parser for xls files that fully supports streaming\n//***********************************************************************\nclass InputParser_XLS extends InputParser {\n\tconstructor(I) {\n\t\tsuper(I);\n\t\tthis.Type = \"XLS\";\n\t\tthis.Help = \"Parsing of .xls Excel files with streaming capabilities\";\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\n\t\tthis.Options = Object.assign(this.Options, { //These options require a new parsing to be performed\n\t\t\tSheet: LinkCtrl.new(\"Select\", {ID: target, Label: \"Sheet\", Default: 0, List: [], Preserve: true, NewLine: true, Index: 5, Change: function() {\n\t\t\t\tif(this.Worker) {this.Worker.terminate()}\n\t\t\t\tthis.FirstParsed = false; //Need to reevaluate available rows/cols\n\t\t\t\tthis.parse();\n\t\t\t}.bind(this), Title: \"The sheet to import\"}),\n\t\t});\n\t\tthis.Worker = undefined; //WebWorker used to process the file\n\t\tthis.SharedStrings = undefined;\n\t}\n\t//Static methods\n\tstatic getMeta(parser) { //A promise that fulfills after metaData are collected, or reject with the error\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tlet reader = new FileReader();\n\t\t\treader.onerror = function(e) { //Handle reading errors\n\t\t\t\treject(reader.error); //The function receives an event as argument but the error description is in the reader property\n\t\t\t}\n\t\t\treader.onload = function(e) { //After opening the file, process it\n\t\t\t\tlet ab = e.target.result; //ArrayBuffer\n\t\t\t\tlet dv = new DataView(e.target.result);\n\t\t\t\ttry {\n\t\t\t\t\tInputParser_XLS.getOffsets(parser, dv) //Metadata\n\t\t\t\t\tlet cursor = InputParser_XLS.getSheets(parser, ab, dv); //Sheets informations\n\t\t\t\t\tif(parser.BIFFversion == 6) {InputParser_XLS.getSharedStrings(parser, ab, dv, cursor)} //Sharedstring are only present for BIFF8\n\t\t\t\t}\n\t\t\t\tcatch(e) {reject(e); return}\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treader.readAsArrayBuffer(parser.RawData); //Start the file reading process\n\t\t});\n\t}\n\tstatic getOffsets(parser, dv) { //Recover meta data from the file and store them in the object property\n\t\tlet version = dv.getUint16(26, true); //Read the coumpound file version to know the sector size\n\t\tswitch(version) {\n\t\t\tcase 3: parser.SectorSize = 512; break;\n\t\t\tcase 4: parser.SectorSize = 4096; break;\n\t\t\tdefault: throw(new Error(\"Unknown CPF version\"));\n\t\t}\n\t\tlet dir = (dv.getUint32(48, true) + 1) * parser.SectorSize; //Calculate offset based on sector#, this points to the directory stream\n\t\tparser.DirStreamOffset = dir;\n\t\tparser.StreamSize = (dv.getUint32(dir + 128 + 124, true) << 32) + dv.getUint32(dir + 128 + 120, true); //Workbook stream size, read as a Uint64\n\t}\n\tstatic getSheets(parser, ab, dv) { //Collect the sheet informations\n\t\tlet WorkbookSector = dv.getUint32(parser.DirStreamOffset + 128 + 116, true);\n\t\tlet WorkbookOffset = (WorkbookSector + 1 ) * parser.SectorSize;\n\t\tparser.WorkbookSector = WorkbookSector;\n\t\tparser.WorkbookOffset = WorkbookOffset;\n\t\tlet cursor = WorkbookOffset + 4;\n\t\tparser.BIFFversion = dv.getUint16(cursor, false); //Biff version, can be read as big endian. It should be 6 for BIFF8, but can be lower for older versions\n\t\tcursor += 4; //The BOF is 16 bytes long for BIFF8 but only 8 for earlier versions, so we try not to go to far to be sure not to miss the BoundSheet stream\n\t\tlet read = dv.getUint16(cursor, true); //Initial value\n\t\tlet end = dv.byteLength; //Safety against infinite while loop...\n\t\twhile(read != 133 && cursor < end) { //Loop until the BoundSheet code (85 00) is found\n\t\t\tcursor += 1;\n\t\t\tread = dv.getUint16(cursor, true);\n\t\t}\n\t\tif(read != 133) {throw(new Error(\"Could not find BoundSheet stream...\"))}\n\t\tcursor += 2; //Skip the 2 bytes corresponding to the BoundSheet code\n\t\tparser.Sheets = []; //Prepare an array for the sheets\n\t\tlet list = []; //Array of sheet name that is used to populate the select control\n\t\tlet newSheet = true;\n\t\twhile(newSheet && cursor < end) { //Collect all the sheet information\n\t\t\tlet sheetOffset = dv.getUint32(cursor + 2, true) + WorkbookOffset; //Sheet offset is from the start of the workbook offset\n\t\t\tlet sheetType = dv.getUint8(cursor + 6, true); //SheetType, must be 0 for a worksheet\n\t\t\tcursor += 8; //Name length read at offset 8 from BoundSheet code\n\t\t\tlet l = dv.getUint16(cursor, true); //Name length\n\t\t\tif(parser.BIFFversion < 6) { //In older version of BIFF, the length is coded with only one byte, not 2...\n\t\t\t\tl = dv.getUint8(cursor, true);\n\t\t\t\tcursor += 1;\n\t\t\t}\n\t\t\telse {cursor += 2} //Position the cursor just after the name length, at the start of the string\n\t\t\tif(sheetType == 0) { //Sheets other than worksheets are ignored\n\t\t\t\tlet td = new TextDecoder(\"windows-1252\"); //Let's hope text encoding is same for everyone since it is 1 byte per character...\n\t\t\t\tlet view = new Uint8Array(ab, cursor, l);\n\t\t\t\tlet name = td.decode(view);\n\t\t\t\tparser.Sheets.push({Name: name, Offset: sheetOffset});\n\t\t\t\tlist.push(name);\n\t\t\t}\n\t\t\tcursor += l; //Position the cursor just after the sheet name\n\t\t\tif(dv.getUint16(cursor, true) != 133) {newSheet = false} //Last sheet has been read\n\t\t\telse {cursor += 2} //Position the cursor just after the boundsheet code to prepare for reading the next sheet\n\t\t}\n\t\tif(cursor > end) {throw(new Error(\"EOF reached after sheets metadata\"))}\n\t\tlet l = parser.Sheets.length - 1;\n\t\tfor(let i=0; i<l; i++) { //Define the length of each sheet based on the offset of the sheet above\n\t\t\tlet s = parser.Sheets[i];\n\t\t\ts.Length = parser.Sheets[i+1].Offset - s.Offset;\n\t\t}\n\t\tlet lastSheet = parser.Sheets[l];\n\t\tlastSheet.Length = parser.StreamSize; //For the last sheet, use the WB stream size as limit\n\t\tparser.Options.Sheet.updateList(list);\n\t\treturn cursor;\n\t}\n\tstatic getSharedStrings(parser, ab, dv, cursor) { //Gather the shared strings. This only applies for BIFF8 (version 6)\n\t\tparser.SharedStrings = []; //Reset previous values\n\t\tlet read = dv.getUint16(cursor, true); //Initial value\n\t\tlet end = dv.byteLength; //Safety against infinite while loop...\n\t\twhile(read != 252 && cursor < end) { //Loop until the SharedString code (FC 00) is found\n\t\t\tcursor += 1;\n\t\t\tread = dv.getUint16(cursor, true);\n\t\t}\n\t\tif(read != 252) {throw(new Error(\"Could not find SharedString stream...\"))}\n\t\tlet n = dv.getUint16(cursor + 2, true); //The size of the record, in bytes\n\t\tlet offset = 12; //Position the cursor at the beginning of the first string\n\t\twhile(offset < n) { //Get all the shared strings\n\t\t\tlet o = this.parseString(ab, dv, cursor + offset);\n\t\t\tparser.SharedStrings.push(o.Str);\n\t\t\toffset += o.Offset;\n\t\t}\n\t}\n\tstatic buildSheetAB(ab, sheet, SectorSize, wbOffset, wbSector, BIFFversion) { //For older versions of BIFF, there seems to be cases where the FAT are not in a direct sequence and the arraybuffer needs reshuffling\n\t\tif(BIFFversion == 6) {return ab.slice(sheet.Offset, sheet.Offset + sheet.Length)} //BIFF for which there is no INDEX / DBCELL needs reshuffling\n\t\tlet dv = new DataView(ab);\n\t\tlet FAT = InputParser_XLS.getFatArray(dv, SectorSize); //Get the array of FAT, storing how the sectors are chained\n\t\tlet ordered = new Uint8Array(ab.byteLength); //A typed array containing the arraybuffer data in the right order\n\t\tlet maxIndex = SectorSize / 4; //Limited number of sectors per FAT, depending on the sector size (they are all stored over 4 bytes)\n\t\tlet i = 0;\n\t\tlet j = Math.floor(wbSector / maxIndex); //j is the index within the FAT array; Which index to use is calculated from the index\n\t\tlet next = dv.getInt32(FAT[j] + wbSector * 4, true); //Index of the next sector in chain after the wbSector. Signed int is used to quickly recognize Free Sector (FFFF FFFF; -1) that mark the end of the track\n\t\tlet start = wbOffset; //Offset for the start of the workbook\n\t\tlet temp = new Uint8Array(ab.slice(start, start + SectorSize)); //First piece of the buffer\n\t\tordered.set(temp); //Set the first piece at the 0 position\n\t\t//console.log(FAT, next, start, temp);\n\t\twhile(next > -1) { //Loop until the end of the FAT sectors (EOC or FS)\n\t\t\t//console.log(next, i, j);\n\t\t\tstart = (next + 1) * SectorSize;\n\t\t\ttemp = new Uint8Array(ab.slice(start, start + SectorSize)); //Next piece of the buffer\n\t\t\tordered.set(temp, (i + 1) * SectorSize);\n\t\t\ti++;\n\t\t\tj = Math.floor(next / maxIndex); //Update the FAT array index to use to find this sector index\n\t\t\tnext = dv.getInt32(FAT[j] + (next - (j * maxIndex)) * 4, true); //Need to offset next to get the correct byteOffset location in the FAT array index\n\t\t}\n\t\t//console.log(ordered);\n\t\tstart = sheet.Offset - wbOffset; //Since the buffer is reshuffled and starts directly with the workbook sector, the wbOffset should be removed from the sheet offset to get to the right position\n\t\treturn ordered.buffer.slice(start, start + sheet.Length);\n\t}\n\tstatic getFatArray(dv, SectorSize) { //Get the array of FAT. Each element of FAT is a sector storing the next sector in chain for a given sector index\n\t\tlet FATnb = dv.getUint32(44, true); //Number of expected FAT sectors\n\t\tlet FAT = []; //Array of FAT, will be used to store their offset\n\t\tlet i = 76; //From this location, gather the FAT sectors\n\t\tlet sector = dv.getInt32(76, true); //We use the signed int to quickly recognize FS (FFFF FFFF; -1) value that mark the end of the track\n\t\twhile(sector != -1 && i < 512) { //Gather the FAT sectors from the header\n\t\t\tFAT.push((sector + 1) * SectorSize);\n\t\t\ti += 4;\n\t\t\tsector = dv.getInt32(i, true); //Refresh the sector\n\t\t}\n\t\tif(dv.getUint32(72, true) > 0) { //If additional DIFAT are required to locate all the FAT, traverse them the same way\n\t\t\tlet n = 109; //The number of FAT already counted from the header\n\t\t\ti = (dv.getUint32(68, true) + 1) * SectorSize; //1st DIFAT location, the others just follow\n\t\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\n\t\t\twhile(sector != -1 && n < FATnb) { //Gather all the remaining FAT sectors\n\t\t\t\tFAT.push((sector + 1) * SectorSize);\n\t\t\t\ti += 4;\n\t\t\t\tn++;\n\t\t\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\n\t\t\t}\n\t\t}\n\t\treturn FAT;\n\t}\n\tstatic parseString(ab, dv, cursor) { //Parse a string record starting at the cursor position given; also returns the offset needed to reach the next record\n\t\tlet td = new TextDecoder(\"windows-1252\"); //Sorry for other text encoding, it will be for future updates...\n\t\tlet l = dv.getUint16(cursor, true); //Size of the string (characters)\n\t\tlet flags = dv.getUint8(cursor + 2, true);\n\t\tlet offset = 3; //Position the cursor after the meta\n\t\tlet fHighByte = flags & 1; //0000 0001\n\t\tlet fExtSt = flags & 4; //0000 0100\n\t\tlet fRichSt = flags & 8; //0000 1000\n\t\tlet ignored = 0; //Additional Bytes ignored because of weird format shit\n\t\tif(fExtSt) {ignored += dv.getUint32(cursor + offset, true); offset += 4}\n\t\tif(fRichSt) {ignored += dv.getUint16(cursor + offset, true) * 4; offset += 2} //cRun * 4 Bytes each\n\t\tlet view = [];\n\t\tif(fHighByte) { //Each character is encoded over 2 bytes\n\t\t\ttd = new TextDecoder(\"utf-8\");\n\t\t\tl = 2 * l;\n\t\t\tview = new Uint16Array(ab, cursor + offset, l);\n\t\t}\n\t\telse {view = new Uint8Array(ab, cursor + offset, l)}\n\t\treturn {Str: td.decode(view), Offset: offset + ignored + l}\n\t}\n\tstatic initWorker(parser) {\n\t\tlet onMessage = function(e) { //What to do inside the worker when a message is received\n\t\t\t//console.log(\"Receiving data in worker\", e.data);\n\t\t\tlet buffer = e.data.Buffer; //Incoming arrayBuffer containing the excel sheet\n\t\t\tlet l = buffer.byteLength;\n\t\t\tlet sst = e.data.SharedStrings; //Shared strings for resolution of string\n\t\t\tlet WBoffset = e.data.WBoffset;\n\t\t\toffset = e.data.SheetOffset; //Offset of the sheet from the beginning of the file\n\t\t\tlet dv = new DataView(buffer);\n\t\t\tself.metaSheet(dv, WBoffset, l); //Init the parsing by checking sheet structural info and placing the cursor at the right location for cell reading\n\t\t\t//console.log(\"Meta done\", self.Blocs, self.BIFF);\n\t\t\tself.parse(buffer, dv, offset, sst, l);\n\t\t\t//console.log(\"Worker Done\");\n\t\t\tpostMessage({Done: true}); //Process end\n\t\t}\n\t\tlet metaSheet = function(dv, WBoffset, l) { //Init the parsing by checking sheet structural info and placing the cursor at the right location for cell reading\n\t\t\tif(dv.getUint16(0, true) != 2057) {throw(new Error(\"Sheet BOF location incorrect\")); return} //Worksheet BOF code: 0908\n\t\t\tlet cursor = dv.getUint16(2, true) + 4; //Position the cursor at the end of the BOF record\n\t\t\tlet biff = dv.getUint16(4, false); //Should be 6 for BIFF5-8\n\t\t\tself.BIFF = biff; //Biff version for the sheet\n\t\t\tif(biff == 6) { //For these versions, we expect the Index to follow immediately the BOF\n\t\t\t\tif(dv.getUint16(cursor, true) != 523) {throw(new Error(\"No index available after BOF\")); return} //Index code: 0B02\n\t\t\t\tlet length = dv.getUint16(cursor + 2, true); //Length of the index record\n\t\t\t\tlet firstRow = dv.getUint32(cursor + 8, true);\n\t\t\t\tlet lastRow = dv.getUint32(cursor + 12, true);\n\t\t\t\tif(self.BIFFversion < 6) { //In lower versions, the first/last Rows are encoded over 2 bytes\n\t\t\t\t\tfirstRow = dv.getUint16(cursor + 8, true);\n\t\t\t\t\tlastRow = dv.getUint16(cursor + 10, true);\n\t\t\t\t\tcursor += 16; //Position the cursor at the first Row bloc location\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcursor += 20; //Position the cursor at the first Row bloc location\n\t\t\t\t}\n\t\t\t\tlet n = Math.ceil((lastRow - firstRow) / 32); //Blocs of 32 Rows required to fit all the data\n\t\t\t\tlet blocs = [];\n\t\t\t\tfor(let i=0; i<n; i++) { //Store the offset for each DBCEll\n\t\t\t\t\tblocs.push(dv.getUint32(cursor + 4 * i, true) + WBoffset); //Offsets are encoded by 4 bytes and the workbook offset should be added\n\t\t\t\t}\n\t\t\t\tif(blocs.length == 0) {throw(new Error(\"Could not find any Row bloc offset\")); return}\n\t\t\t\tself.Blocs = blocs;\n\t\t\t}\n\t\t\telse { //In older versions of excel, there is no Index, so need to go through all the Cell Table until the first CELL record is found\n\t\t\t\tlet end = dv.byteLength; //Safety against infinite while loop...\n\t\t\t\tlet read = dv.getUint16(cursor, true); //Initial value\n\t\t\t\twhile(read != 520 && cursor < end) { //Loop until the ROW code (08 02) is found\n\t\t\t\t\tcursor += 1;\n\t\t\t\t\tread = dv.getUint16(cursor, true);\n\t\t\t\t}\n\t\t\t\tif(read != 520) {throw(new Error(\"Could not find Cell Table stream...\"))}\n\t\t\t\twhile(read == 520 && cursor < end) { //Now loop until the last ROW record\n\t\t\t\t\tcursor += 20; //All row record are 16 Bytes + 2 bytes code + 2 bytes length = 20 bytes total\n\t\t\t\t\tread = dv.getUint16(cursor, true);\n\t\t\t\t}\n\t\t\t\tif(cursor >= end) {throw(new Error(\"Could not find any Cell records...\"))}\n\t\t\t\tself.FirstCellOffset = cursor; //Save the location of the first cell record\n\t\t\t\t//console.log(cursor);\n\t\t\t}\n\t\t}\n\t\tlet parse = function(ab, dv, offset, sst, l) { //Parse the sheet data\n\t\t\tself.RowIndex = 0; //Starting row Index\n\t\t\tif(self.Blocs) { //The file has DBCell sectors and needs to be parsed bloc per bloc\n\t\t\t\tlet n = self.Blocs.length; //Number of blocs\n\t\t\t\tself.Blocs.forEach(function(o, i) { //For each bloc\n\t\t\t\t\tlet b = o - offset; //Offset stored in blocs are from the begining of the file, so need to remove the sheet offset from it\n\t\t\t\t\tlet firstRowOffset = dv.getUint32(b + 4, true); //Offset of the first row from the start of the DBcell\n\t\t\t\t\tlet firstCellOffset = (b - firstRowOffset) + 20 + dv.getUint16(b + 8, true); //Offset of the first cell of the first row, from the end of the first row record (whose length is 20 bytes)\n\t\t\t\t\tif(i == (n - 1)) {end = l} //For the last bloc, end is set as the end of the sheet\n\t\t\t\t\telse {end = this.Blocs[i + 1] - offset} //Otherwise, the start of the next dBCell is used as end point\n\t\t\t\t\t//console.log(\"Parsing bloc \" + i, b, firstRowOffset, firstCellOffset, end);\n\t\t\t\t\tthis.getRows(ab, dv, sst, firstCellOffset, end);\n\t\t\t\t}, self); //Self is used as the this context in the foreach loop\n\t\t\t}\n\t\t\telse { //In older versions, no dBCell...\n\t\t\t\t//console.log(dv.getUint16(self.FirstCellOffset, true));\n\t\t\t\tthis.getRows(ab, dv, undefined, self.FirstCellOffset, ab.byteLength);\n\t\t\t}\n\t\t}\n\t\tlet getRows = function(ab, dv, sst, start, end) { //Get the rows available from the start to end bytes of the buffer\n\t\t\tself.Cursor = start; //Position the cursor at the first cell location\n\t\t\tlet row = [];\n\t\t\tlet done = false;\n\t\t\twhile(!done && self.Cursor < end) { //Parse all data until the buffer is exhausted\n\t\t\t\tlet c = self.cell(ab, dv, sst);\n\t\t\t\t//console.log(\"Worker cell\", c);\n\t\t\t\tdone = c.Done;\n\t\t\t\tif(!done) { //A valid cell data is received\n\t\t\t\t\tlet cellRow = c.Row;\n\t\t\t\t\twhile(self.RowIndex < cellRow && self.RowIndex < 65536) { //Fill the gaps between rows if any. A second stop condition is added for security (65535 = max number of row possible for XLS files)\n\t\t\t\t\t\t//console.log(\"Worker posting\", row, self.Cursor);\n\t\t\t\t\t\tpostMessage({Row: row}); //Post the completed row and start a new one\n\t\t\t\t\t\trow = [];\n\t\t\t\t\t\tself.RowIndex++;\n\t\t\t\t\t}\n\t\t\t\t\trow[c.Col] = c.Value;\n\t\t\t\t\tif(c.More !== undefined) { //Case of multiple records\n\t\t\t\t\t\tc.More.forEach(function(v, i) {row[c.Col + i + 1] = v}); //Push all the cell values\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { //All data collected, submit the completed row\n\t\t\t\t\t//console.log(\"Worker posting (done)\", row, self.Cursor);\n\t\t\t\t\tpostMessage({Row: row});\n\t\t\t\t\tself.RowIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet cell = function(ab, dv, sst) { //Process the cell at the current cursor location\n\t\t\tlet cursor = self.Cursor;\n\t\t\tlet dataType = dv.getUint16(cursor, true);\n\t\t\tlet recLen = dv.getUint16(cursor + 2, true); //Size of the cell record in Bytes, excluding header code and size\n\t\t\tlet parsed = { //Data for the parsed cells\n\t\t\t\tRow: dv.getUint16(cursor + 4, true),\n\t\t\t\tCol: dv.getUint16(cursor + 6, true),\n\t\t\t\tValue: undefined,\n\t\t\t\tDone: false,\n\t\t\t}\n\t\t\tswitch(dataType) { //Cell value is evaluated depending on the record type\n\t\t\t\tcase 253: //FD00 SharedString\n\t\t\t\t\tparsed.Value = sst[dv.getUint32(cursor + 10, true)]; break;\n\t\t\t\tcase 515: //0302 Number, as a 64bit IEEE floating-point \n\t\t\t\t\tparsed.Value = dv.getFloat64(cursor + 10, true); break;\n\t\t\t\tcase 126: case 638: //7E00 RK or 7E02 RK\n\t\t\t\t\tparsed.Value = self.parseRK(cursor + 10, dv); break;\n\t\t\t\tcase 189: //BD00 MulRK, multiple RK numbers to read\n\t\t\t\t\tparsed.Value = self.parseRK(cursor + 10, dv); //First value read as the others\n\t\t\t\t\tparsed.More = []; //Array to receive additional RK values\n\t\t\t\t\tlet start = cursor + 16; //Position of the next RK record\n\t\t\t\t\tlet stop = cursor + recLen + 2; //Cursor + 4 + recLen is the full size, but two last bytes are for the index of the last column\n\t\t\t\t\twhile(start < stop) { //Accumulate the values until the chain is exhausted\n\t\t\t\t\t\tparsed.More.push(self.parseRK(start, dv));\n\t\t\t\t\t\tstart += 6;\n\t\t\t\t\t}\n\t\t\t\t\t//console.log(\"MULRK\", parsed, cursor, recLen, start, stop);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 215: //D700 DBCell, mark the end of the cell data for BIFF5-8 files\n\t\t\t\t\tparsed.Done = true; break;\n\t\t\t\tcase   6: case 518: case 1030: //0600 Formula or 0602 Formula or 0604 Formula\n\t\t\t\t\tlet bytes = [];\n\t\t\t\t\tfor(let i=0; i<8; i++) {bytes.push(dv.getUint8(cursor + 10 + i, true))} //Collect bytes for the FormulaValue field\n\t\t\t\t\tif(bytes[6] == 255 && bytes[7] == 255) { //fExprO = 0xFFFF, boolean/error/blank/string can be stored\n\t\t\t\t\t\tswitch(bytes[0]) {\n\t\t\t\t\t\t\tcase 0: //A string is stored in this formula\n\t\t\t\t\t\t\t\tlet o = self.parseString(ab, dv, cursor + recLen + 8); //A string record immediately follows the formula record. It starts with the string code (0702) and the record length (total 4 bytes), followed by a string structure\n\t\t\t\t\t\t\t\tparsed.Value = o.Str; //The parsed string\n\t\t\t\t\t\t\t\tself.Cursor += (o.Offset + 4); //Need to offset by the size of the string record to get to the next cell\n\t\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t\tcase 1: //boolean value => Read bytes[2]\n\t\t\t\t\t\t\t\tif(bytes[2] == 0) {parsed.Value = \"FALSE\"}\n\t\t\t\t\t\t\t\telse {parsed.Value = \"TRUE\"}\n\t\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t\tcase 2:  //Error value => Read bytes[2]\n\t\t\t\t\t\t\t\tswitch(bytes[2]) {\n\t\t\t\t\t\t\t\t\tcase 0: parsed.Value = \"#NULL!\"; break;\n\t\t\t\t\t\t\t\t\tcase 7: parsed.Value = \"#DIV/0!\"; break;\n\t\t\t\t\t\t\t\t\tcase 15: parsed.Value = \"#VALUE!\"; break;\n\t\t\t\t\t\t\t\t\tcase 23: parsed.Value = \"#REF!\"; break;\n\t\t\t\t\t\t\t\t\tcase 29: parsed.Value = \"#NAME?\"; break;\n\t\t\t\t\t\t\t\t\tcase 36: parsed.Value = \"#NUM!\"; break;\n\t\t\t\t\t\t\t\t\tcase 42: parsed.Value = \"#N/A\"; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault: break; //Includes case 3, Blank\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {parsed.Value = dv.getFloat64(cursor + 10, true)} //Numerical value\n\t\t\t\t\tbreak;\n\t\t\t\tcase 516: case 214: //0402 Label, D600 RString (for older versions without sst)\n\t\t\t\t\tlet td = new TextDecoder(\"windows-1252\"); //Sorry for other text encoding, it will be for future updates...\n\t\t\t\t\tlet view = new Uint8Array(ab, cursor + 12, dv.getUint16(cursor + 10, true));\n\t\t\t\t\tparsed.Value = td.decode(view);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 513: break; //0102 Blank cell\n\t\t\t\tcase 190: break; //BE00 MulBlank\n\t\t\t\tcase 517: break; //0502 BoolErr\n\t\t\t\t//break;\n\t\t\t\tdefault: //Other values should mark the end of the cell table\n\t\t\t\t\tparsed.Done = true; break;\n\t\t\t}\n\t\t\tself.Cursor += (recLen + 4); //Move the cursor to the next cell\n\t\t\treturn parsed;\n\t\t}\n\t\tlet parseRK = function(cursor, dv) { //Parse and return the value for the RK number\n\t\t\tlet temp = dv.getUint8(cursor, true);\n\t\t\tlet fX100 = temp & 1; //Bitwise comparison with 1: 00000001, will return 1 if and only if the first bit is 1\n\t\t\tlet fInt = temp & 2; //Bitwise comparison with 2: 00000010, will return 2 if and only if the second bit is 1\n\t\t\tlet num = undefined;\n\t\t\t//console.log(temp, fX100, fInt);\n\t\t\tif(fInt == 2) {num = dv.getInt32(cursor, true) >> 2} //The stored number is a signed integer, it should be shifted 2 bits because of the metadata\n\t\t\telse { //30 most significant bits of a 64-bit binary floating point number, see iEEE754\n\t\t\t\tlet bytes = [temp, dv.getUint8(cursor + 1, true), dv.getUint8(cursor + 2, true), dv.getUint8(cursor + 3, true)]; //4 bytes containing the data; first byte has only 6 bits of data\n\t\t\t\tlet sign = 1 - (2 * (bytes[3] >> 7));\n\t\t\t\tlet exponent = ((((bytes[3] << 1) & 0xff) << 3) | (bytes[2] >> 4)) - ((1 << 10) - 1); //0xff = 1111 1111\n\t\t\t\tlet mantissa = ((bytes[2] & 0x0f) * Math.pow(2, 48)) + (bytes[1] * Math.pow(2, 40)) + ((bytes[0] & 0xfc) * Math.pow(2, 32)); //Other bytes are all null; 0x0f = 0000 1111;  0xfc = 1111 1100\n\t\t\t\tif (exponent == 1024) { //Particular cases\n\t\t\t\t\tif (mantissa != 0) {return NaN}\n\t\t\t\t\telse {return sign * Infinity}\n\t\t\t\t}\n\t\t\t\tif (exponent == -1023) {num = sign * mantissa * Math.pow(2, -1022 - 52)} // Denormalized\n\t\t\t\telse {num = sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent)}\n\t\t\t}\n\t\t\tif(fX100 == 1) {return num / 100}\n\t\t\telse {return num}\n\t\t}\n\t\tlet code =\"\";\n\t\tcode += \"self.cell = \" + cell.toString() + \"; \";\n\t\tcode += \"self.parseRK = \" + parseRK.toString() + \"; \";\n\t\tcode += \"self.metaSheet = \" + metaSheet.toString() + \"; \";\n\t\tcode += \"self.parse = \" + parse.toString() + \"; \";\n\t\tcode += \"self.getRows = \" + getRows.toString() + \"; \";\n\t\tcode += \"self.parseString = \" + this.parseString.toString().replace(\"parseString\", \"function\") + \"; \";\n\t\tcode += \"self.Cursor = 0; \";\n\t\tcode += \"self.BIFFversion = \" + parser.BIFFversion + \"; \"; //BIFF Version for the file\n\t\tcode += \"onmessage = \" + onMessage.toString() + \";\";\n\t\tlet blob = new Blob([code], {type: \"application/javascript\"});\n\t\treturn new Worker(URL.createObjectURL(blob));\n\t}\n\t//Methods\n\tfirstParse(I) { //Parse the entire file to get nb of rows and columns available\n\t\tthis.TotalCols = 0; //Reset previous data\n\t\tthis.TotalRows = 0;\n\t\tInputParser_XLS.getMeta(this).then(function() { //Get the metadata\n\t\t\tthis.stream(function(row, selected, parser) { //Step function\n\t\t\t\tlet l = row.length;\n\t\t\t\tif(l > this.TotalCols) {this.TotalCols = l}\n\t\t\t\tthis.TotalRows++;\n\t\t\t\tif(I && I.Step) {I.Step(row, this.TotalRows, parser)}\n\t\t\t}.bind(this), function() { //Completion function\n\t\t\t\tthis.FirstParsed = true;\n\t\t\t\tthis.parse(I);\n\t\t\t}.bind(this), I); //Pass options to the stream to catch errors\n\t\t}.bind(this), function(error) { //What to do if the reading fail\n\t\t\tthis.Error = true;\n\t\t\tthis.ErrorDetails = error;\n\t\t\tthis.parse(I); //We call the parse again so that the error message and status are reflected in the preview box and the input table\n\t\t\tif(I && I.Error) {I.Error(error)}\n\t\t}.bind(this));\n\t}\n\tstream(f, complete, I) { //Stream the input and send the row to the function provided as argument\n\t\tlet w = InputParser_XLS.initWorker(this); //Initialize the webworker\n\t\tthis.Worker = w; //Expose the worker so that the parsing can be killed following outside events\n\t\tlet o = this.parsingOptions();\n\t\tif(I && I.ApplyToHeader) {o.ApplyToHeader = true}\n\t\tlet reader = new FileReader();\n\t\tlet onError = function(e) { //Error loading the file\n\t\t\tthis.Error = true;\n\t\t\tthis.ErrorDetails = e;\n\t\t\tif(I && I.Error) {I.Error(e)}\n\t\t\tthis.parseEnd(w, o, complete);\n\t\t}.bind(this);\n\t\treader.onerror = function(e) {onError(reader.error)} //Catch errors thrown by the FileReader\n\t\treader.onload = function(e) { //After the file is loaded\n\t\t\tlet ab = e.target.result; //the arraybuffer\n\t\t\tlet sheet = this.Sheets[this.Options.Sheet.getValue()]; //Selected sheet object\n\t\t\t//let sheetAB = ab.slice(sheet.Offset, sheet.Offset + sheet.Length); //A slice of the arraybuffer that contains the sheet data\n\t\t\tlet sheetAB = InputParser_XLS.buildSheetAB(ab, sheet, this.SectorSize, this.WorkbookOffset, this.WorkbookSector, this.BIFFversion); //A slice of the arraybuffer that contains the sheet data\n\t\t\tw.postMessage({Buffer: sheetAB, SharedStrings: this.SharedStrings, WBoffset: this.WorkbookOffset, SheetOffset: sheet.Offset}, [sheetAB]); //Transfer ownership of the arraybuffer to the worker and initiate the parsing\n\t\t}.bind(this);\n\t\tlet parser = { //A parser object that is used to catch abort events by the user\n\t\t\tabort: function() {this.parseEnd(w, o, complete)}.bind(this),\n\t\t\tFirstParsed: this.FirstParsed,\n\t\t};\n\t\tw.onmessage = function(e) { //What to do when the worker sends a row\n\t\t\t//console.log(\"Data from worker\", e.data);\n\t\t\t//\n\t\t\t//setTimeout(w.terminate(), 1000); //FOR TEST\n\t\t\t//\n\t\t\t\n\t\t\tif(e.data.Done) {this.parseEnd(w, o, complete)} //Parsing is done\n\t\t\telse { //Parsing is on-going\n\t\t\t\tthis.processRow(e.data.Row, parser, f, o); //Process the row and run the function provided by the user, when needed\n\t\t\t}\n\t\t\t\n\t\t}.bind(this);\n\t\tw.onmessageerror = function(e) {onError(e.message)} //Catch errors thrown by the worker\n\t\tw.onerror = function(e) {onError(e.message)}\n\t\treader.readAsArrayBuffer(this.RawData); //Start the file reading process\n\t}\n\tparseEnd(w, o, complete) { //Completion of the streaming\n\t\tw.terminate(); //Kill the worker\n\t\tthis.Worker = undefined;\n\t\tif(complete) {complete(o.Selected, o)} //Execute the complete function\n\t}\n\t/*chunk(f, I) { //Chunk a piece of the input and apply the provided function on each chunk\n\t\n\t}\n\tbulk(f) { //Fully Parse the input, in a single block, and execute the function passed as argument after cleaning. Don't do this for big files, use stream() instead \n\t\n\t}*/\n\t\n\t/*\n\t//LET'S SEE IF ALL THAT MESS IS USEFUL ONE DAY...\n\tthis.FAT = Array(dv.getUint32(44, true)); //Array of FAT, will be used to store their sector#\n\tthis.FAT = []; //Array of FAT, will be used to store their sector#\n\tthis.MiniFAT = Array(dv.getUint32(64, true)); //Array of miniFAT, will be used to store their sector#\n\tthis.DIFAT = dv.getUint32(72, true); //Number of DIFAT sectors\n\tif(this.MiniFAT.length > 0) {this.MiniFAT[0] = (dv.getUint32(60, true) + 1) * this.SectorSize} //Register 1st miniFAT location\n\tlet i = 76; //From this location, gather the FAT sectors\n\tlet sector = dv.getInt32(76, true); //We use the signed int to quickly recognize FS (FFFF FFFF; -1) value that mark the end of the track\n\twhile(sector != -1 && i < 512) { //Gather the FAT sectors from the header\n\t\tthis.FAT.push((sector + 1) * this.SectorSize);\n\t\ti += 4;\n\t\tsector = dv.getInt32(i, true); //Refresh the sector\n\t}\n\tif(this.DIFAT > 0) { //If additional DIFAT are required to locate all the FAT, traverse them the same way\n\t\tlet max = dv.getUint32(44, true); //The max number of FAT that we expect\n\t\tlet n = 109; //The number of FAT already counted from the header\n\t\ti = (dv.getUint32(68, true) + 1) * this.SectorSize; //1st DIFAT location, the others just follow\n\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\n\t\twhile(sector != -1 && n < max) { //Gather all the remaining FAT sectors\n\t\t\tthis.FAT.push((sector + 1) * this.SectorSize);\n\t\t\ti += 4;\n\t\t\tn++;\n\t\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\n\t\t}\n\t}\n\tlet miniFatOffset = dv.getInt32(60, true); //We use the signed version to quickly recognize FEFF FFFF values (EOC)\n\tif(miniFatOffset < 0) {this.MiniFat = []} //No miniFat\n\telse {this.MiniFat = [dv.getUint32(60, true)]} //Get the offset for the first miniFat location\n\t*/\n}","//************************************************************************\n// INPUTPARSER_XLSX - A parser for xlsx files thatfully supports streaming\n//************************************************************************\nclass InputParser_XLSX extends InputParser {\n\tconstructor(I) {\n\t\tsuper(I);\n\t\tthis.Type = \"XLSX\";\n\t\tthis.Help = \"Parsing of .xlsx Excel files with streaming capabilities\";\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\n\t\tthis.Options = Object.assign(this.Options, { //These options require a new parsing to be performed\n\t\t\tSheet: LinkCtrl.new(\"Select\", {ID: target, Label: \"Sheet\", Default: 0, List: [], Preserve: true, NewLine: true, Index: 5, Change: function() {\n\t\t\t\tif(this.Worker) {this.Worker.terminate()}\n\t\t\t\tthis.FirstParsed = false; //Need to reevaluate available rows/cols\n\t\t\t\tthis.parse();\n\t\t\t}.bind(this), Title: \"The sheet to import\"}),\n\t\t});\n\t\tthis.Worker = undefined; //WebWorker used to process the file\n\t\tthis.ZIP = undefined;\n\t\tthis.SharedStrings = undefined;\n\t}\n\t//Static methods\n\tstatic getSheetNames(zip, DOMParser) { //Parse the input to get the number of sheets and their names\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tif(zip.file(\"xl/workbook.xml\") === null) {\n\t\t\t\tlet e = new Error(\"Cannot access the \\\"xl/workbook.xml\\\" directory! This file is not a standard XLSX file.\");\n\t\t\t\treject(e);\n\t\t\t}\n\t\t\tzip.file(\"xl/workbook.xml\").async(\"string\").then(function(str) {\n\t\t\t\tlet xml = DOMParser.parseFromString(str, \"application/xml\").getElementsByTagName(\"sheet\");\n\t\t\t\tlet l = xml.length;\n\t\t\t\tlet sheets = Array(l);\n\t\t\t\tfor(let i=0; i<l; i++) {\n\t\t\t\t\tlet index = Number(xml[i].attributes.sheetId.value) - 1;\n\t\t\t\t\tsheets[index] = xml[i].attributes.name.value;\n\t\t\t\t}\n\t\t\t\tresolve(sheets);\n\t\t\t}, function(e) {reject(e)});\n\t\t}.bind(this));\n\t}\n\tstatic getSharedStrings(zip, DOMParser) { //Parse the input to get the shared strings available for this file\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tzip.file(\"xl/sharedStrings.xml\").async(\"string\").then(function(str) {\n\t\t\t\tlet xml = DOMParser.parseFromString(str, \"application/xml\").getElementsByTagName(\"t\");\n\t\t\t\tlet l = xml.length;\n\t\t\t\tlet shared = [];\n\t\t\t\tfor(let i=0; i<l; i++) {\n\t\t\t\t\tshared.push(xml[i].innerHTML);\n\t\t\t\t}\n\t\t\t\tresolve(shared);\n\t\t\t}, function(e) {reject(e)});\n\t\t}.bind(this));\n\t}\n\tstatic getMeta(inputParser, zip) { //Recover meta data from the file and store them in the object property\n\t\tlet parser = new DOMParser();\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tlet promises = [this.getSheetNames(zip, parser), this.getSharedStrings(zip, parser)];\n\t\t\tPromise.all(promises).then(function(out) {\n\t\t\t\tinputParser.Options.Sheet.updateList(out[0]);\n\t\t\t\tinputParser.SharedStrings = out[1];\n\t\t\t\tresolve();\n\t\t\t}, function(e) {reject(e)});\n\t\t}.bind(this));\n\t}\n\tstatic initWorker() {\n\t\tlet f = function(e) { //What to do inside the worker when a message is received\n\t\t\tlet buffer = e.data.Buffer; //Incoming arraybuffer containing the excel sheet\n\t\t\tlet shared = e.data.SharedStrings;\n\t\t\tlet alphabet = \"*ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; //Add a first character to shift the index by 1, so that A=1, B=2, C=3...\n\t\t\tlet chunkSize = self.MaxChunkSize; //The length of data to process\n\t\t\tlet l = buffer.byteLength;\n\t\t\twhile(self.Position < l) { //While the buffer has not been fully processed\n\t\t\t\tif((self.Position + self.MaxChunkSize) > l) {chunkSize = l - self.Position} //There are less elements to process than the max allowed\n\t\t\t\tlet view = new Uint8Array(buffer, self.Position, chunkSize); //Get data from arraybuffer\n\t\t\t\tlet data = new TextDecoder(\"utf-8\").decode(view);\n\t\t\t\tif(self.LastRow) {data = self.LastRow + data} //Concate the remaining elements from previous chunk to get it full\n\t\t\t\tdata.split('<row r=\"').forEach(function(str, i) { //Process all the individual row chunks\n\t\t\t\t\tlet rowEnd = str.indexOf(\"</row>\");\n\t\t\t\t\tif(rowEnd > -1) { //This means a complete row is present and can be parsed right away without worrying about missing items\n\t\t\t\t\t\tlet rowIndex = str.substring(0, str.indexOf('\"')); //Recover the row index, as a string!\n\t\t\t\t\t\tlet row = [];\n\t\t\t\t\t\tlet ColCount = 0; //How many columns are counted\n\t\t\t\t\t\tstr.split('<c r=\"').forEach(function(cell, j) { //Further divide it into individual cells\n\t\t\t\t\t\t\tif(j > 0) { //The first piece is the row header, which is not useful here\n\t\t\t\t\t\t\t\tlet colName = cell.substring(0, cell.indexOf('\"') - rowIndex.length); //Recover the letters forming the cell name\n\t\t\t\t\t\t\t\tlet colIndex = -1; //Start at -1 to retrieve a 0-based index\n\t\t\t\t\t\t\t\tcolName.split(\"\").forEach(function(c, k) {colIndex += alphabet.indexOf(c) * Math.pow(26, colName.length - k - 1)}); //Convert colName to colIndex\n\t\t\t\t\t\t\t\twhile(ColCount < colIndex) {ColCount++; row.push(\"\")} //Fill gaps with empty values\n\t\t\t\t\t\t\t\tlet valStart = cell.indexOf(\"<v>\");\n\t\t\t\t\t\t\t\tif(valStart > -1) { //This cell has a value\n\t\t\t\t\t\t\t\t\tlet v = cell.substring(valStart + 3, cell.indexOf(\"</v>\")); //The value\n\t\t\t\t\t\t\t\t\tlet t = cell.indexOf(' t=\"'); //The position of the type property\n\t\t\t\t\t\t\t\t\tif(t > -1) { //If a type property exist, extract it\n\t\t\t\t\t\t\t\t\t\tlet type = cell.substring(t + 4, t + 5); //The type has only one character length\n\t\t\t\t\t\t\t\t\t\tswitch(type) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"b\": //Boolean value\n\t\t\t\t\t\t\t\t\t\t\t\tif(v) {row.push(\"TRUE\")}\n\t\t\t\t\t\t\t\t\t\t\t\telse {row.push(\"FALSE\")}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"s\": //Shared string\n\t\t\t\t\t\t\t\t\t\t\t\trow.push(shared[Number(v)]); //Convert the value using the shared dictionary and push it\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault: //This includes string and error values from formula\n\t\t\t\t\t\t\t\t\t\t\t\trow.push(v); //Push the value\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t/*let type = cell.substring(0, cell.indexOf('</c>')).match(/t=\"(.+?)\"/); //Restrict the search to the current cell. Expecially useful for the last cell\n\t\t\t\t\t\t\t\t\tif(type !== null) {\n\t\t\t\t\t\t\t\t\t\tswitch(type[1]) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"b\": //Boolean value\n\t\t\t\t\t\t\t\t\t\t\t\tif(v) {row.push(\"TRUE\")}\n\t\t\t\t\t\t\t\t\t\t\t\telse {row.push(\"FALSE\")}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"s\": //Shared string\n\t\t\t\t\t\t\t\t\t\t\t\trow.push(shared[Number(v)]); //Convert the value using the shared dictionary and push it\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault: //This includes string and error values from formula\n\t\t\t\t\t\t\t\t\t\t\t\trow.push(v); //Push the value\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}*/\n\t\t\t\t\t\t\t\t\telse {row.push(Number(v))} //Other cases should fall to the number type\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {row.push(\"\")} //No value\n\t\t\t\t\t\t\t\tColCount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpostMessage({Row: row});\n\t\t\t\t\t\tlet remaining = str.substring(rowEnd + 6); //What remains after the rowEnd tag?\n\t\t\t\t\t\tif(remaining.length == 0) {self.LastRow = undefined} //There is nothing left after the closing row tag, lucky you!\n\t\t\t\t\t\telse {self.LastRow = remaining} //Pieces left should be added to the next chunk\n\t\t\t\t\t}\n\t\t\t\t\telse {self.LastRow = str} //This row is not complete so we need to wait for the next chunk\n\t\t\t\t});\n\t\t\t\tself.Position += self.MaxChunkSize; //Increment position to process the next chunk of data\n\t\t\t}\n\t\t\tpostMessage({Done: true});\n\t\t}\n\t\tlet blob = new Blob([\"self.MaxChunkSize = 1024 * 1024; self.LastRow = undefined; self.Position = 0; onmessage = \" + f.toString()], {type: \"application/javascript\"});\n\t\treturn new Worker(URL.createObjectURL(blob));\n\t}\n\t//Methods\n\tfirstParse(I) { //Parse the entire file to get nb of rows and columns available\n\t\tthis.TotalCols = 0; //Reset previous data\n\t\tthis.TotalRows = 0;\n\t\tJSZip.loadAsync(this.RawData).then(function(zip) { //Read the archive to get the structure\n\t\t\tthis.ZIP = zip;\n\t\t\tInputParser_XLSX.getMeta(this, zip).then(function() { //Get the metadata\n\t\t\t\tthis.stream(function(row, selected, parser) { //Step function\n\t\t\t\t\tlet l = row.length;\n\t\t\t\t\tif(l > this.TotalCols) {this.TotalCols = l}\n\t\t\t\t\tthis.TotalRows++;\n\t\t\t\t\tif(I && I.Step) {I.Step(row, this.TotalRows, parser)}\n\t\t\t\t}.bind(this), function() { //Completion function\n\t\t\t\t\tthis.FirstParsed = true;\n\t\t\t\t\tthis.parse(I);\n\t\t\t\t}.bind(this), I);\n\t\t\t}.bind(this)).catch(function(e) { //Errors occuring in getMeta or during parsing are caught here\n\t\t\t\tthis.fail(e, I);\n\t\t\t}.bind(this));\n\t\t}.bind(this), function(e) { //Error during loadAsync are caught here\n\t\t\tthis.fail(e, I);\n\t\t}.bind(this));\n\t}\n\tfail(e, I) { //What to do on failure of archive reading\n\t\tthis.Error = true;\n\t\tthis.ErrorDetails = e;\n\t\tthis.parse(I); //We call the parse again so that the error message and status are reflected in the preview box and the input table\n\t\tif(I && I.Error) {I.Error(e)} //Execute the error callback if provided\n\t}\n\tstream(f, complete, I) { //Stream the input and send the row to the function provided as argument\n\t\tlet w = InputParser_XLSX.initWorker(); //Initialize the webworker\n\t\tthis.Worker = w; //Expose the worker so that the parsing can be killed following outside events\n\t\tlet sheet = this.ZIP.file(\"xl/worksheets/sheet\" + (this.Options.Sheet.getValue() + 1) + \".xml\");\n\t\tlet o = this.parsingOptions();\n\t\tlet onError = function(e) { //Error loading the file\n\t\t\tthis.Error = true;\n\t\t\tthis.ErrorDetails = e;\n\t\t\tif(I && I.Error) {I.Error(e)}\n\t\t\tthis.parseEnd(w, o, complete);\n\t\t}.bind(this);\n\t\tsheet.async(\"arraybuffer\").then(function(ab) { //Get the sheet as an arraybuffer and transfer it to the worker\n\t\t\tif(I && I.ApplyToHeader) {o.ApplyToHeader = true}\n\t\t\tlet parser = { //A parser object that is used to catch abort events by the user\n\t\t\t\tabort: function() {\n\t\t\t\t\tw.terminate(); //Kill the worker\n\t\t\t\t\tthis.Worker = undefined;\n\t\t\t\t\tif(complete) {complete(o.Selected, o)} //Execute the complete function\n\t\t\t\t}.bind(this),\n\t\t\t\tFirstParsed: this.FirstParsed,\n\t\t\t};\n\t\t\tw.onmessage = function(e) { //What to do when the worker sends a row\n\t\t\t\tif(e.data.Done) { //Parsing is done\n\t\t\t\t\t/*if(complete) { //Execute the user function on complete\n\t\t\t\t\t\tcomplete(o.Selected, o);\n\t\t\t\t\t\tw.terminate(); //Close the worker on completion\n\t\t\t\t\t\tthis.Worker = undefined; //Release the exposed worker\n\t\t\t\t\t}*/\n\t\t\t\t\tthis.parseEnd(w, o, complete);\n\t\t\t\t}\n\t\t\t\telse { //Parsing is on-going\n\t\t\t\t\tthis.processRow(e.data.Row, parser, f, o); //Process the row and run the function provided by the user, when needed\n\t\t\t\t}\n\t\t\t}.bind(this);\n\t\t\tw.onmessageerror = function(e) {onError(e.message)} //Catch errors thrown by the worker\n\t\t\tw.onerror = function(e) {onError(e.message)}\n\t\t\tw.postMessage({Buffer: ab, SharedStrings: this.SharedStrings}, [ab]); //Transfer the ownership of the arraybuffer to the worker\n\t\t}.bind(this));\n\t}\n\tparseEnd(w, o, complete) { //Completion of the streaming\n\t\tw.terminate(); //Kill the worker\n\t\tthis.Worker = undefined;\n\t\tif(complete) {complete(o.Selected, o)} //Execute the complete function\n\t}\n}","//**************************************************************************************************\n// MAPPER_DIRECT object - Function to process a file that contains no mapping for plate or well data\n//**************************************************************************************************\nclass Mapper_Direct extends Mapper {\n\tconstructor(mapping) {\n\t\tsuper();\n\t\treturn this;\n\t}\n\t//Methods\n\tscan(o, I, output) { //Scan the file and take the element as they come\n\t\treturn new Promise(function(resolve) {\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\n\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\n\t\t\t\tif(I.Preview) { //Prepare a preview\n\t\t\t\t\tMapper.scanPreviewColumns(output, row, (output.Items + 1) + \".\");\n\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\n\t\t\t\t}\n\t\t\t\toutput.Items++; //Increment the item count\n\t\t\t\tif(I.Custom) {I.Custom(undefined, undefined, row, output, parser)} //No well or plate information\n\t\t\t}, function(lines) { //Do this when done\n\t\t\t\tif(I.Log) {output.PlatesID = undefined} //In this case, the determination of the plate number is not possible\n\t\t\t\tresolve(output);\n\t\t\t});\n\t\t});\n\t}\n\tfind(o, I) { //Find the data when no mapping is available\n\t\tlet plateIndex = Number(I.Plate); //We need to convert the generic plate name in a number\n\t\tlet out = I.Default;\n\t\tlet start = (plateIndex - 1) * I.Factor;\n\t\tlet stop = plateIndex * I.Factor;\n\t\tlet index = 0;\n\t\tif(I.FindAll) {out = []}\n\t\treturn new Promise(function(resolve) {\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\n\t\t\t\tif(selected == stop) {parser.abort()} //Outside the plate dimensions\n\t\t\t\telse {\n\t\t\t\t\tif(selected >= start) { //We are now exploring the definitions for the requested plate\n\t\t\t\t\t\tif(I.FindAll) {out.push(row[I.Column])}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(index == I.RangeIndexBase0) { //The correct element has been found\n\t\t\t\t\t\t\t\tout = row[I.Column];\n\t\t\t\t\t\t\t\tparser.abort();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, function(lines) { //Do this when done\n\t\t\t\tout = Mapper.fillMissingElements(out, I, start, index); //Fill missing elements if required\n\t\t\t\tresolve(out);\n\t\t\t});\n\t\t});\n\t}\n}","//*************************************************************************************************\n// MAPPER_PLATE object - Function to process a file that contains a mapping only for the plate data\n//*************************************************************************************************\nclass Mapper_Plate extends Mapper {\n\tconstructor(mapping) {\n\t\tsuper();\n\t\tthis.PlateCol = mapping[Mapper.plate().Name];\n\t\treturn this;\n\t}\n\t//Methods\n\tscan(o, I, output) { //Scan the file by searching plate data and execute the actions required\n\t\tlet p = this.PlateCol;\n\t\treturn new Promise(function(resolve) {\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\n\t\t\t\tif(row[p] !== undefined) { //A valid entry is found\n\t\t\t\t\tif(I.Log) { //Log the data\n\t\t\t\t\t\tif(output.PlatesID.includes(row[p]) == false) {output.PlatesID.push(row[p])}\n\t\t\t\t\t}\n\t\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\n\t\t\t\t\tif(I.Preview) { //Prepare a preview\n\t\t\t\t\t\tMapper.scanPreviewColumns(output, row, row[p] + \".\");\n\t\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\n\t\t\t\t\t}\n\t\t\t\t\toutput.Items++; //Increment the item count\n\t\t\t\t\tif(I.Custom) {I.Custom(undefined, row[p], row, output, parser)} //No well information\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tresolve(output);\n\t\t\t});\n\t\t});\n\t}\n\tfind(o, I) { //Find the data when only plate mapping is available\n\t\tlet p = this.PlateCol;\n\t\tlet index = 0;\n\t\tlet out = I.Default; //Default fallback if the value is not found\n\t\tif(I.FindAll) {out = []}\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\n\t\t\t\tif(row[p] !== undefined && row[p] == I.Plate) { //Valid entry found for the desired plate, do what is needed\n\t\t\t\t\tif(I.FindAll) {\n\t\t\t\t\t\tout.push(row[I.Column]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(index == I.RangeIndexBase0) { //This is the correct location\n\t\t\t\t\t\t\tout = row[I.Column];\n\t\t\t\t\t\t\tparser.abort(); //Stop here since the data has been found\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tout = Mapper.fillMissingElements(out, I, 0, index); //Fill missing elements if required\n\t\t\t\tresolve(out);\n\t\t\t});\n\t\t});\n\t}\n}","//*********************************************************************************************************\n// MAPPER_PLATEWELL object - Function to process a file that contains a mappin for both plate and well data\n//*********************************************************************************************************\nclass Mapper_PlateWell extends Mapper {\n\tconstructor(mapping) {\n\t\tsuper();\n\t\tthis.WellCol = mapping[Mapper.well().Name];\n\t\tthis.PlateCol = mapping[Mapper.plate().Name];\n\t\treturn this;\n\t}\n\t//Methods\n\tscan(o, I, output) { //Scan the file by searching plate/well data and execute the actions required\n\t\tlet plate = Editor.Plate;\n\t\tif(plate === undefined) {return Promise.resolve({Error: \"No plate defined, cannot validate the well data now\"})} //Failure \n\t\tlet w = this.WellCol;\n\t\tlet p = this.PlateCol;\n\t\treturn new Promise(function(resolve) {\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\n\t\t\t\tlet well = Well.parseIndex(row[w], plate);\n\t\t\t\tif(well !== undefined && row[p] !== undefined) { //Valid well found in a valid plate, do what is needed\n\t\t\t\t\tif(I.Log) { //Log the data\n\t\t\t\t\t\tif(output.PlatesID.includes(row[p]) == false) {output.PlatesID.push(row[p])}\n\t\t\t\t\t}\n\t\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\n\t\t\t\t\tif(I.Preview) { //Prepare a preview\n\t\t\t\t\t\tMapper.scanPreviewColumns(output, row, row[p] + \". \" + row[w] + \".\");\n\t\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\n\t\t\t\t\t}\n\t\t\t\t\toutput.Items++; //Increment the item count\n\t\t\t\t\tif(I.Custom) {I.Custom(well, row[p], row, output, parser)}\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tresolve(output);\n\t\t\t});\n\t\t});\n\t}\n\tfind(o, I) { //Find the data when plate and well mapping are available\n\t\tlet plate = Editor.Plate;\n\t\tif(plate === undefined) {return Promise.resolve(\"\")} //Failure \n\t\tlet w = this.WellCol;\n\t\tlet p = this.PlateCol;\n\t\tlet out = I.Default; //Default fallback if the value is not found\n\t\tif(I.FindAll) {out = Array(plate.Rows * plate.Cols).fill(I.Default)}\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\n\t\t\t\tlet here = Well.parseIndex(row[w], plate);\n\t\t\t\tif(here !== undefined && row[p] !== undefined) { //Valid well found in a valid plate, do what is needed\n\t\t\t\t\tif(row[p] == I.Plate) { //This is the right plate\n\t\t\t\t\t\tif(I.FindAll) {\n\t\t\t\t\t\t\tout[here.Index] = row[I.Column];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(here.Index == I.Well) { //This is the correct location\n\t\t\t\t\t\t\t\tout = row[I.Column];\n\t\t\t\t\t\t\t\tparser.abort(); //Stop here since the data has been found\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tresolve(out);\n\t\t\t});\n\t\t});\n\t}\n\tmatch(o, I) { //Match the array of data against the file and return the matched elements\n\t\tlet plate = Editor.Plate;\n\t\tif(plate === undefined) {return Promise.resolve(\"\")} //Failure \n\t\tlet w = this.WellCol;\n\t\tlet p = this.PlateCol;\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\n\t\t\t\tlet here = Well.parseIndex(row[w], plate);\n\t\t\t\tif(here !== undefined && row[p] !== undefined) { //Valid well found in a valid plate, do what is needed\n\t\t\t\t\tI.Array.forEach(function(a) { //Scan the array for any match\n\t\t\t\t\t\tif(row[p] == a.Plate && here.Index == a.WellIndex) { //Match\n\t\t\t\t\t\t\ta.Resolved = row[I.Column]; //Update the object with the resolved name\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tresolve(I.Array);\n\t\t\t});\n\t\t});\n\t}\n}","//***********************************************************************************************\n// MAPPER_WELL object - Function to process a file that contains a mapping only for the well data\n//***********************************************************************************************\nclass Mapper_Well extends Mapper {\n\tconstructor(mapping) {\n\t\tsuper();\n\t\tthis.WellCol = mapping[Mapper.well().Name];\n\t\treturn this;\n\t}\n\t//Methods\n\tscan(o, I, output) { //Scan the file by searching well data and execute the actions required\n\t\tlet plate = Editor.Plate;\n\t\tif(plate === undefined) {return Promise.resolve({Error: \"No plate defined, cannot validate the well data now\"})} //Failure \n\t\toutput.PlatesID = Array(plate.Rows * plate.Cols).fill(0);\n\t\tlet w = this.WellCol;\n\t\treturn new Promise(function(resolve) {\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\n\t\t\t\tlet well = Well.parseIndex(row[w], plate);\n\t\t\t\tif(well !== undefined) { //Valid well found, do what is needed\n\t\t\t\t\t//if(I.Log) {output.PlatesID[well.Index]++} //Log the data\n\t\t\t\t\toutput.PlatesID[well.Index]++;\n\t\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\n\t\t\t\t\tif(I.Preview) { //Prepare a preview\n\t\t\t\t\t\tMapper.scanPreviewColumns(output, row, row[w] + \".\");\n\t\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\n\t\t\t\t\t}\n\t\t\t\t\toutput.Items++; //Increment the item count\n\t\t\t\t\tif(I.Custom) {I.Custom(well, output.PlatesID[well.Index], row, output, parser)}\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tif(I.Log) {\n\t\t\t\t\tlet plateNb = 0;\n\t\t\t\t\toutput.PlatesID.forEach(function(n) {\n\t\t\t\t\t\tif(n > plateNb) {plateNb = n} //Search the max number of plates\n\t\t\t\t\t});\n\t\t\t\t\tlet array = [];\n\t\t\t\t\tfor(let i=0; i<plateNb; i++) {array.push(i+1)} //Build a default array with incrementing numbers\n\t\t\t\t\toutput.PlatesID = array;\n\t\t\t\t}\n\t\t\t\tresolve(output);\n\t\t\t});\n\t\t});\n\t}\n\tfind(o, I) { //Find the data when only well mapping is available\n\t\tlet plate = Editor.Plate;\n\t\tif(plate === undefined) {return Promise.resolve(\"\")} //Failure \n\t\tlet w = this.WellCol;\n\t\tI.Plate = Number(I.Plate) - 1; //We need to convert the generic plate name in a number. Plate numbering starts at 1\n\t\tlet index = 0;\n\t\tlet out = I.Default; //Default fallback if the value is not found\n\t\tif(I.FindAll) {\n\t\t\tout = Array(plate.Rows * plate.Cols).fill(I.Default);\n\t\t\tindex = Array(plate.Rows * plate.Cols).fill(0); \n\t\t}\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\n\t\t\t\tlet here = Well.parseIndex(row[w], plate);\n\t\t\t\tif(here !== undefined) { //Valid entry found, do what is needed\n\t\t\t\t\tif(I.FindAll) { //Log all the wells\n\t\t\t\t\t\tif(index[here.Index] == I.Plate) { //This entry corresponds to the desired plate\n\t\t\t\t\t\t\tout[here.Index] = row[I.Column];\n\t\t\t\t\t\t} \n\t\t\t\t\t\tindex[here.Index]++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(here.Index == I.Well) { //This is the right well\n\t\t\t\t\t\t\tif(index == I.Plate) { //This is the right plate\n\t\t\t\t\t\t\t\tout = row[I.Column];\n\t\t\t\t\t\t\t\tparser.abort();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {index++}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, function() { //Do this when done\n\t\t\t\tresolve(out);\n\t\t\t});\n\t\t});\n\t}\n}"]}