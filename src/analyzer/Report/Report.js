//****************************************************************************
// REPORT object - Holds the values and controls available to analyze the data
//****************************************************************************
class Report {
	constructor(o) {
		let html = "";
		//html += "<div id=\"Menu\" style=\"width: 350px; overflow: auto; float: left\"></div>";
		//html += "<div id=\"Output\" style=\"margin-left: 370px\"></div>";
		html += "<div id=\"Menu\"></div>";
		html += "<div id=\"Output\"></div>"
		GetId("Main").innerHTML = html;
		this.Title = o.Title;
		let f = o.FileName;
		this.FileName = f; //The complete file name
		let n = this.FileName.lastIndexOf(".");
		if(n > -1) {this.CleanName = Report.cleanFileName(f.substring(0, n))} //The fileName without the extension and cleaned
		else {this.CleanName = Report.cleanFileName(f)} //In case we cannot find the last dot (which is weird, right?)
		this.Blocs = []; //Array of bloc objects
		this.Output = new TabControl({ //Tab to manipulate the Bloc objects
			ID: "Output",
			Layout: "Horizontal",
			Tabs: [],
		});
		this.Menu = new TabControl({
			ID: "Menu",
			Multiple: true,
			Layout: "Menu",
			Tabs: [
				{Label: "Options", Active: true, Content: {Type: "HTML", Value: "<div id=\"Options\"></div>"} },
				{Label: "Export", Active: true, Content: {Type: "HTML", Value: "<div id=\"Export\"></div>"} },
			],
		});
		this.Options = {
			Collapse: LinkCtrl.new("Checkbox", {ID: "Options", Label: "Collapse tables", Default: true, Chain: {Index: 0}, Change: function(v) {
				let r = this.Options.Rows;
				if(v) {r.enable()}
				else {r.disable()}
				this.refresh("Rows", {Collapse: v, Rows: r.getValue()});
			}.bind(this), Title: "Tick to limit the number of rows displayed in tables"}),
			Rows: LinkCtrl.new("Number", {ID: "Options", Label: "Rows", Default: 10, Min: 2, Step: 1, Chain: {Index: 1, Last: true}, Change: function(v) {
				this.refresh("Rows", {Collapse: true, Rows: v});
			}.bind(this), Title: "Maximum number of rows to show for each table"}),
			Decimals: LinkCtrl.new("Select", {ID: "Options", Label: "Decimals", Default: 3, List: [0, 1, 2, 3, 4, 5, 6, "All"], Chain: {Index: 2, NewLine: true}, Change: function(v) {
				this.refresh("Decimals");
			}.bind(this), Title: "Number of decimals to show for the computed values. Parsed values from the file are not affected"}),
			CV: LinkCtrl.new("Checkbox", {ID: "Options", Label: "Show CV", Default: false, Chain: {Index: 3, Last: true}, Change: function(v) {
				this.refresh("CV", {Show: v});
			}.bind(this), Title: "Tick to show the coefficient of varation (CV, %) for the data"}),
		}
		this.UI = {} //Container for specific LinkCtrl elements
		this.Menu.init();
		this.Output.init();
		Object.values(this.Options).forEach(function(o) {o.init()});
		GetId("Export").append(LinkCtrl.buttonBar([ //Export functionalities
			{Label: "Export All", Title: "Export all the data generated by the report, as a zip file containing tab-delimited text files", Click: this.exportAll.bind(this)},
		]));
		return this;
	}
	//Static methods
	static new(o) {
		switch(o.Method) {
			case "zFactor": return new Report_Controls(o);
			case "Aggregate": return new Report_Aggregate(o);
			case "Grouped": return new Report_Grouped(o);
			default: return new Report(o);
		}
	}
	static getBloc(report, name) {
		let found = false;
		let i = 0;
		let blocs = report.Blocs;
		let l = blocs.length;
		while(!found && i<l) {
			if(blocs[i].Name == name) {found = true}
			else {i++}
		}
		if(found) { //Bloc already exists, call it back
			report.Output.jumpTo(i);
			return report.Blocs[i];
		}
		else {return report.newBloc(name, i)} //Create the bloc
	}
	static *plateIterator(source) { //A generator function that create a generator object for counting plates
		let l = source.length;
		for(let i=0; i<l; i++) {
			yield source[i];
		}
	}
	static lock(report, plates) { //Lock the report while parsing data
		let id = "Report_Mask";
		Form.open({
			ID: id,
			HTML: "<p><span class=\"warning\">Parsing in progress, please wait...<span></p><p>Processing plate <span id=\"Mask_PlateNumber\">1</span> / " + plates + "</p>",
			Title: "Analysis in progress...",
			Buttons: [
				{Label: "Abort", Click: function() {report.cancel()}}
			],
			onCancel: function() {report.cancel()},
		});
	}
	static unlock() { //Release the report after parsing
		Form.close("Report_Mask");
	}
	static plateCount(p) { //Update the count of completed plates while analyzing all of them
		let target = GetId("Mask_PlateNumber");
		if(target) {target.innerHTML = p}
	}
	static cleanFileName(n) { //Clean the provided name to make it a safe(r) string to be used for a file name
		if(n == "" || n === undefined) {return "unknown"} //Let's have a fallback for weird cases
		return n.trim() //Starts by removing space characters at both ends
			.replace(/[^a-z0-9_\-\[\]\(\)\.]/gi, "_") //Replace all undesirable characters with "_"
			.replace(/_{2,}/g, "_"); //Collapse consecutive "_" into one
	}
	//Methods
	init() { //Init the controls on the page
		Object.values(this.UI).forEach(function(v) {v.init()});
		return this;
	}
	newBloc(name, index) {
		let id = "Bloc_" + index;
		let bloc = new Bloc({Name: name, ID: id});
		this.Blocs.push(bloc);
		this.Output.addTab({Label: name, SetActive: true, Content: {Type: "HTML", Value: "<div id=\"" + id + "\"><span class=\"warning\">Initializing the report, please wait...</span></div>"} });
		return bloc.init();
	}
	cancel() {
		this.Cancel = true;
		return this;
	}
	refresh(what, I) { //Refresh the report
		switch(what) {
			case "Rows": this.refreshRows(I); break;
			case "Decimals": this.refreshDecimals(I); break;
			case "CV": this.refreshCV(I.Show); break;
		}
		return this;
	}
	refreshRows(I) { //Update the number of rows displayed per table
		let height = "unset";
		if(I.Collapse) {height = Analyzer.divHeight(I.Rows)}
		let HTMLcollection = GetId("Output").getElementsByClassName("InnerTable_Wrapper");
		let l = HTMLcollection.length;
		for(let i=0; i<l; i++) {
			let element = HTMLcollection[i];
			let items = element.children[0].rows.length;
			element.style.maxHeight = height;
			if(items <= I.Rows) {element.style.overflowY = "unset"}
			else {element.style.overflowY = "scroll"}
		}
		return this;
	}
	refreshDecimals(I) { //Update the number of decimals displayed
		let HTMLcollection = GetId("Output").getElementsByClassName("Value_PlaceHolder");
		let l = HTMLcollection.length;
		for(let i=0; i<l; i++) { //Update all the value placeholders
			let element = HTMLcollection[i];
			if(element.hasAttribute("value")) {
				let val = element.getAttribute("value");
				if(val != "" && isNaN(Number(val)) == false) { //If convertion to a number falls into NaN, it means the value is a text, so leave it as it is
					element.innerHTML = Analyzer.roundNb(Number(val));
				}
			}
		}
		let tables = GetId("Output").getElementsByClassName("InnerTableRow");
		let m = tables.length;
		for(let i=0; i<m; i++) { //For each table
			let t = tables[i];
			let n = t.rows[0].cells.length; //Get the number of cells (these tables have only one row)
			let maxLength = 2; //Minimum length
			for(let j=0; j<n; j++) { //Travel each cell for this row
				maxLength = Math.max(maxLength, t.rows[0].cells[j].innerText.length); //Using innerText solve the issue of the <span> for empty cells
			}
			t.style.minWidth = Analyzer.rowWidth(n, maxLength); //Update tables min-width
		}
		return this;
	}
	refreshCV(bool) { //Show or hide the computed CV values
		let HTMLcollection = GetId("Output").getElementsByClassName("CV_Row");
		let l = HTMLcollection.length;
		let display = "none";
		if(bool) {display = "table-row"}
		for(let i=0; i<l; i++) {
			HTMLcollection[i].style.display = display;
		}
		return this;
	}
	exportAll() { //Export all data for available blocs and sections
		let Z = new JSZip();
		let id = "Form_Save";
		let outputID = id + "_Output";
		let fileName = this.CleanName + ".zip";
		Form.open({ //Open a form for feedback to the user
			ID: id,
			HTML: "<p id=\"" + outputID + "\"><span class=\"warning\">Preparing zip archive, please wait...</span></p>",
			Title: "Export data",
			Buttons: [{Label: "Close", Click: function() {Form.close(id)}}],
		});
		this.Blocs.forEach(function(bloc) {
			let dir = Z.folder(Report.cleanFileName(bloc.Name));
			bloc.Sections.forEach(function(section) {
				let blob = section.export({BlobOnly: true});
				dir.file(Report.cleanFileName(section.Name + ".txt"), blob);
			});
		});
		Z.generateAsync({type: "blob"}).then(function (b) {
			let target = GetId(outputID); //Access the element only at the end
			if(target) {
				let url = URL.createObjectURL(b);
				target.innerHTML = "<p>Click <a href=\"" + url + "\" download=\"" + fileName + "\">here</a> to download the generated zip file</p>";
				Form.replaceButtons(id, [{Label: "Close", Click: function() {URL.revokeObjectURL(url); Form.close(id)}}]); //Revoke the URL has it is no longer useful
			}
		});
		return this;
	}
}